{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1479244391071},{"_id":"themes/landscape/README.md","hash":"e7cc82dc79596f36ba05a8139e7d6b2dfc4ae5f9","modified":1479244391080},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1479244391074},{"_id":"themes/landscape/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1479244391258},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1479244391075},{"_id":"themes/landscape/_config.yml","hash":"218c5fb76666696c42dc86e2de4711e6b80befbf","modified":1479244391083},{"_id":"source/_drafts/tt.md","hash":"75211b4260bf38b9d8eeb24ffcd4f64d71552146","modified":1479244391036},{"_id":"source/_drafts/2016-10-27-t.md","hash":"f9cfdc5ff574c8f6d816983cef09f474f0f4b8fe","modified":1479244391031},{"_id":"source/_drafts/red-black-tree.md","hash":"69cfb540bb94dab1fdbcbf2d8725e39dd2e26082","modified":1479330232979},{"_id":"source/_posts/2016-10-21-How-to-work-with-hexo-and-git-pages.md","hash":"0b6ed6e6fb92e3685b2fde045a0284046274fb7a","modified":1479484508597},{"_id":"source/_posts/2016-10-21-zhi-xi.md","hash":"44bacecee935499091485bb4dc75e18f4df66312","modified":1479244391044},{"_id":"source/_posts/2016-11-16-Red-Black-Tree.md","hash":"8f3846811da32624261cba970ed17e921e469d8c","modified":1480452437555},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree.md","hash":"4d9cb391328b6e9b9f722975d0d8e21155e393df","modified":1479244391055},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion.md","hash":"6458bc72e7dae08c65f147cdc65045ddb298f222","modified":1480709407096},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion.md","hash":"cfb44aa30b3be373e4048b6bab58102a87d9ce03","modified":1480606555467},{"_id":"source/_posts/2016-10-24-Multiple-SSH-Keys-settings-for-different-github-account.md","hash":"fdafdcb6c7b74a0164ae7a7c4ad1dc2e08e98588","modified":1479244391048},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1479244391093},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1479244391086},{"_id":"source/_posts/2016-11-08-Most-Beautiful-Mathematical-Equations.md","hash":"1d3f989db8e9430a95bcd6db74ee1f9938464ab9","modified":1479244391051},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1479244391099},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1479244391096},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1479244391103},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1479244391106},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1479244391228},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1479244391231},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1479244391251},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1479244391252},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1479244391235},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1479244391255},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1479244391263},{"_id":"source/_posts/2016-11-15-Tree-Properties.md","hash":"a08549d6b8a7e9e8e75fbdec2930cfd8a2babdda","modified":1480540889115},{"_id":"themes/landscape/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1479244391090},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1479244391248},{"_id":"source/_drafts/2016-10-27-t/red_black_tree_1.png","hash":"fa0ee9e6903fe99520a3d6fe18a2ee6f0b91b8fa","modified":1479244391033},{"_id":"source/_drafts/red-black-tree/rbt_left_rotation_1.jpg","hash":"a34869bbd41d638b27f84f2af6c6587ae9977bb9","modified":1479415983780},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree1.gif","hash":"b23678ef1fec541524159c36c0c5f75114871a7a","modified":1479244391057},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree2.gif","hash":"09bb25f2d9cb00ac87604a3a1777b14c3e224510","modified":1479244391057},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree3.gif","hash":"de92991eaee9177cc072556bc75781cd3eb2b92d","modified":1479244391059},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_height_depth.png","hash":"6dd8e498d9a9410c775f1d9f7bd350fc371fa3c8","modified":1479244391063},{"_id":"source/_drafts/red-black-tree/rbt_right_rotation_1.jpg","hash":"29559a30506e83bc8df5dffa941a317056d6cbbd","modified":1479415996959},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_invertible_rotation.png","hash":"96df5262f4d216882139327cd941954792de5337","modified":1479848025522},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_1.jpg","hash":"c125c3b07e19d7fcc8af1619b3a5b7b6fc927810","modified":1480450072988},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_left_rotation_example_1.png","hash":"16403d3eac21d8dadca42d0e9746ffc82e94794b","modified":1479831511884},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_properties_1.jpg","hash":"09e50f776a3570494a497cc2330d9a205bfecf82","modified":1479332617753},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_right_rotation_example_1.png","hash":"4a78524762a67aa5e79c0af88e7671386bef8084","modified":1479832535212},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_left_rotation_1.jpg","hash":"49d85050b3bfce71707346bb7724840fb0b38c1b","modified":1479416356516},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_4.png","hash":"d0de329133ce7801be9e13a3a4348e5cf15310b1","modified":1480618000101},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_right_rotation_1.jpg","hash":"1ccac37948f03661a96695479bb5bb463f3692f0","modified":1479416346699},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_2.png","hash":"c75b8c06585910d40f66ef49d53660fe32b6d081","modified":1480614564058},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_3.png","hash":"9d9c47626b2875e751f0fb24f564adf28900e42f","modified":1480614440587},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_3.jpg","hash":"7621e739d666fc3498cc6d627aff83f9375dbd37","modified":1479844803246},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_1.png","hash":"ec08f17eecab0001ec04e73035d84025c0447fab","modified":1480610987748},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_4.jpg","hash":"22b02fde27874f935ed2a2a258f1c3c0d7c3660a","modified":1479844735026},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_2.jpg","hash":"b5010e695c4e4c27a198e9f075048b305112a457","modified":1479844845291},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_5.jpg","hash":"beaa25b3945a20834ffaf0154382c314c7362e41","modified":1479845022635},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_6.jpg","hash":"c84f3c167ee981cf8815d280b3284ea2231f6329","modified":1479845292539},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_1.jpg","hash":"15083dd0ec72813d665d5d93238ba31a5a109157","modified":1480436348643},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_7.jpg","hash":"7bbc9be0328dc6534803a7a8bea66a726aefeafd","modified":1479914595109},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_1.jpg","hash":"a85d3db3fe02fb760308ffc025d964171acbd598","modified":1479844943886},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_2.jpg","hash":"2aa3d18ba7e5fde6203cec68cdc46c6af513bc93","modified":1480435439760},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_2.png","hash":"fd7fe83e73506b241e24000b0b2db5320f4dcfc5","modified":1480108084146},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_3.png","hash":"8f650bb94e6e83dfc70338718998a95593ee1b70","modified":1480108089100},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_4.png","hash":"83511b704e19d39ce9ee497a5f11a6294a41d4b6","modified":1480108093283},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_5.png","hash":"dfdb43571ff13a6e8cfd0012496250c7cb319ba9","modified":1480108106967},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_7.png","hash":"6ca60acb6264964747388549910e1c0794a5cac9","modified":1480108125371},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_6.png","hash":"a05f625cbdf9f022c86519c7e322f75a160fd6fa","modified":1480108118752},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_8.png","hash":"a7fa7e89d548e6b97e0ef90803a345e01ada6de8","modified":1480108102477},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1479244391133},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1479244391138},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"3beb0d164acacb6f21e1ca2038158a74ab4a73e4","modified":1479244391122},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1479244391146},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1479244391111},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1479244391163},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"a7faab4f3601b28107af5b1095b3966c2f88fec8","modified":1479244391108},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1479244391206},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"89998e6b2929c4ff5093bbf6b86d611d7420be52","modified":1479244391154},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1479244391217},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1479244391225},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1479244391201},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"148bdf714dd1a7bf55e571f13808ceae079200cc","modified":1479244391160},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1479244391212},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1479244391222},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1479244391267},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1479244391375},{"_id":"themes/landscape/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1479244391322},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1479244391374},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1479244391380},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1479244391376},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1479244391379},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1479244391378},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1479244391381},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1479244391421},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1479244391449},{"_id":"source/_drafts/red-black-tree/rbt_1.jpg","hash":"2911a019c6a632243ffb6722a097fbbc145c5ac3","modified":1479313676445},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1479244391461},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1479244391434},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_1.png","hash":"78d00eba5401dc12b58279406c61280356f7a185","modified":1480108079466},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_3_full.jpg","hash":"8726a5cecb2990f2c1194906a3c8b9a9832c217f","modified":1480446527007},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1479244391174},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1479244391170},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_2_full.jpg","hash":"800ab53a42abf23d67849277b21bf43f09bb8296","modified":1480447060939},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1479244391180},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_1_full.jpg","hash":"fc7992bc0af57c4dca7df1e689fd2e2c636c36f1","modified":1480109793532},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1479244391194},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1479244391191},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1479244391184},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1479244391271},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1479244391277},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1479244391280},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1479244391283},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1479244391296},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1479244391300},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1479244391293},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1479244391287},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1479244391303},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1479244391306},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1479244391329},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1479244391343},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1479244391364},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1479244391312},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1479244391317},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1479244391382},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1479244391385},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1479244391403},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1479244391395},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1479244391359},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1479244391417},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1479244391406},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1479244391352},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1479244391370}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"tt","_content":"","source":"_drafts/tt.md","raw":"---\ntitle: tt\ntags:\n---\n","slug":"tt","published":0,"date":"2016-11-15T21:13:11.034Z","updated":"2016-11-15T21:13:11.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xcu0000mclsa7yw8goe","content":"","excerpt":"","more":""},{"title":"t","date":"2016-10-27T13:53:12.000Z","_content":"\n{% asset_img red_black_tree_1.png Red-Black Tree%}","source":"_drafts/2016-10-27-t.md","raw":"---\ntitle: t\ndate: 2016-10-27 09:53:12\ntags:\n---\n\n{% asset_img red_black_tree_1.png Red-Black Tree%}","slug":"t","published":0,"updated":"2016-11-15T21:13:11.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xcu0001mclsij1u01r6","content":"<img src=\"/archive/2016/10/27/t/red_black_tree_1.png\" alt=\"Red-Black Tree\" title=\"Red-Black Tree\">","excerpt":"","more":"<img src=\"/archive/2016/10/27/t/red_black_tree_1.png\" alt=\"Red-Black Tree\" title=\"Red-Black Tree\">"},{"title":"Red-Black Tree","_content":"\n### Preface ###\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Introduction ###\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n### Properties ###\n1. Every node is colored with either red or black;\n2. All leaf (NULL Pointer) nodes are colored with black; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black._\n3. Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**). We call this number the **black height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a red node must be black nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always black.\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Application of Red-Black Tree ###\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | Black height of the tree;                         |\n| $bh(x)$       | Black height of the node $x$;                     |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 3<sub>rd</sub> property above as each red node strictly requires black children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Theorem ### \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n### Proof by induction ###\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is __black height__ of the node $x$, or $x$'s __black height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sub>rd</sub> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sub>th</sub> **Red-Black Tree** properties, \"Both children of a red node must be black nodes\", we can say starting from the node x to leaf node, the number of black nodes >= the number the red nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __black height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n","source":"_drafts/red-black-tree.md","raw":"---\ntitle: Red-Black Tree\ntags:\n- Algorithm\n- Tree\n---\n\n### Preface ###\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Introduction ###\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n### Properties ###\n1. Every node is colored with either red or black;\n2. All leaf (NULL Pointer) nodes are colored with black; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black._\n3. Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**). We call this number the **black height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a red node must be black nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always black.\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Application of Red-Black Tree ###\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | Black height of the tree;                         |\n| $bh(x)$       | Black height of the node $x$;                     |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 3<sub>rd</sub> property above as each red node strictly requires black children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Theorem ### \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n### Proof by induction ###\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is __black height__ of the node $x$, or $x$'s __black height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sub>rd</sub> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sub>th</sub> **Red-Black Tree** properties, \"Both children of a red node must be black nodes\", we can say starting from the node x to leaf node, the number of black nodes >= the number the red nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __black height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n","slug":"red-black-tree","published":0,"date":"2016-11-15T21:13:39.963Z","updated":"2016-11-16T21:03:52.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xcu0002mclscnyi2o1f","content":"<h3 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h3><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either red or black;</li>\n<li>All leaf (NULL Pointer) nodes are colored with black;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>black height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a red node must be black nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always black.</li>\n</ol>\n<img src=\"/archive/2016/11/15/red-black-tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h3 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h3><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\">Black height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\">Black height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 3<sub>rd</sub> property above as each red node strictly requires black children</em>)</p>\n<hr>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h3 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h3><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is <strong>black height</strong> of the node $x$, or $x$’s <strong>black height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sub>rd</sub> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sub>th</sub> <strong>Red-Black Tree</strong> properties, “Both children of a red node must be black nodes”, we can say starting from the node x to leaf node, the number of black nodes &gt;= the number the red nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>black height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n","excerpt":"","more":"<h3 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h3><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either red or black;</li>\n<li>All leaf (NULL Pointer) nodes are colored with black;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>black height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a red node must be black nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always black.</li>\n</ol>\n<img src=\"/archive/2016/11/15/red-black-tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h3 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h3><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\">Black height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\">Black height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 3<sub>rd</sub> property above as each red node strictly requires black children</em>)</p>\n<hr>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h3 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h3><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is <strong>black height</strong> of the node $x$, or $x$’s <strong>black height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sub>rd</sub> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sub>th</sub> <strong>Red-Black Tree</strong> properties, “Both children of a red node must be black nodes”, we can say starting from the node x to leaf node, the number of black nodes &gt;= the number the red nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>black height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n"},{"title":"How to work with hexo and git pages","date":"2016-10-21T19:20:56.000Z","_content":"\n### 安装Hexo ###\n```\ncd d:/hexo\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo g # 或者hexo generate\nhexo s # 或者hexo server，可以在http://localhost:4000/ 查看\n```\n\n这里有必要提下Hexo常用的几个命令：\nhexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\nhexo server (hexo s) 启动本地web服务，用于博客的预览\nhexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）\n另外还有其他几个常用命令：\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\n```\n\n### 常用简写 ###\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n### 常用组合 ###\n```\nhexo d -g #生成部署\nhexo s -g #生成预览\n```\n\n\n\n### 使用git命令行部署 ###\n\nclone github repo\n```\ncd d:/hexo/blog\ngit clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io\n```\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。\n创建一个deploy脚本文件\n\n```\nhexo generate\ncp -R public/* .deploy/foursquarebehind.github.io\ncd .deploy/foursquarebehind.github.io\ngit add .\ngit commit -m “update”\ngit push origin master\n```\n\n简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。\n需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。\n\n\nto be continued...","source":"_posts/2016-10-21-How-to-work-with-hexo-and-git-pages.md","raw":"---\ntitle: How to work with hexo and git pages\ndate: 2016-10-21 15:20:56\ntags:\n- Hexo\n- GitHub\n---\n\n### 安装Hexo ###\n```\ncd d:/hexo\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo g # 或者hexo generate\nhexo s # 或者hexo server，可以在http://localhost:4000/ 查看\n```\n\n这里有必要提下Hexo常用的几个命令：\nhexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\nhexo server (hexo s) 启动本地web服务，用于博客的预览\nhexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）\n另外还有其他几个常用命令：\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\n```\n\n### 常用简写 ###\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n### 常用组合 ###\n```\nhexo d -g #生成部署\nhexo s -g #生成预览\n```\n\n\n\n### 使用git命令行部署 ###\n\nclone github repo\n```\ncd d:/hexo/blog\ngit clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io\n```\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。\n创建一个deploy脚本文件\n\n```\nhexo generate\ncp -R public/* .deploy/foursquarebehind.github.io\ncd .deploy/foursquarebehind.github.io\ngit add .\ngit commit -m “update”\ngit push origin master\n```\n\n简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。\n需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。\n\n\nto be continued...","slug":"How-to-work-with-hexo-and-git-pages","published":1,"updated":"2016-11-18T15:55:08.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xda0003mcls25nteffe","content":"<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo</div><div class=\"line\">npm install hexo-cli -g</div><div class=\"line\">hexo init blog</div><div class=\"line\">cd blog</div><div class=\"line\">npm install</div><div class=\"line\">hexo g # 或者hexo generate</div><div class=\"line\">hexo s # 或者hexo server，可以在http://localhost:4000/ 查看</div></pre></td></tr></table></figure>\n<p>这里有必要提下Hexo常用的几个命令：<br>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹<br>hexo server (hexo s) 启动本地web服务，用于博客的预览<br>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）<br>另外还有其他几个常用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div></pre></td></tr></table></figure>\n<h3 id=\"常用简写\"><a href=\"#常用简写\" class=\"headerlink\" title=\"常用简写\"></a>常用简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<h3 id=\"常用组合\"><a href=\"#常用组合\" class=\"headerlink\" title=\"常用组合\"></a>常用组合</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -g #生成部署</div><div class=\"line\">hexo s -g #生成预览</div></pre></td></tr></table></figure>\n<h3 id=\"使用git命令行部署\"><a href=\"#使用git命令行部署\" class=\"headerlink\" title=\"使用git命令行部署\"></a>使用git命令行部署</h3><p>clone github repo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo/blog</div><div class=\"line\">git clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io</div></pre></td></tr></table></figure></p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。<br>创建一个deploy脚本文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">cp -R public/* .deploy/foursquarebehind.github.io</div><div class=\"line\">cd .deploy/foursquarebehind.github.io</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m “update”</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n<p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。<br>需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p>\n<p>to be continued…</p>\n","excerpt":"","more":"<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo</div><div class=\"line\">npm install hexo-cli -g</div><div class=\"line\">hexo init blog</div><div class=\"line\">cd blog</div><div class=\"line\">npm install</div><div class=\"line\">hexo g # 或者hexo generate</div><div class=\"line\">hexo s # 或者hexo server，可以在http://localhost:4000/ 查看</div></pre></td></tr></table></figure>\n<p>这里有必要提下Hexo常用的几个命令：<br>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹<br>hexo server (hexo s) 启动本地web服务，用于博客的预览<br>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）<br>另外还有其他几个常用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div></pre></td></tr></table></figure>\n<h3 id=\"常用简写\"><a href=\"#常用简写\" class=\"headerlink\" title=\"常用简写\"></a>常用简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<h3 id=\"常用组合\"><a href=\"#常用组合\" class=\"headerlink\" title=\"常用组合\"></a>常用组合</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -g #生成部署</div><div class=\"line\">hexo s -g #生成预览</div></pre></td></tr></table></figure>\n<h3 id=\"使用git命令行部署\"><a href=\"#使用git命令行部署\" class=\"headerlink\" title=\"使用git命令行部署\"></a>使用git命令行部署</h3><p>clone github repo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo/blog</div><div class=\"line\">git clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io</div></pre></td></tr></table></figure></p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。<br>创建一个deploy脚本文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">cp -R public/* .deploy/foursquarebehind.github.io</div><div class=\"line\">cd .deploy/foursquarebehind.github.io</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m “update”</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n<p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。<br>需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p>\n<p>to be continued…</p>\n"},{"title":"窒息","date":"2016-10-21T21:17:21.000Z","_content":"\n窒息\n\n追逐权利便抛弃良心 维护和平就发动战争\n欲望不断压缩和膨胀 失去了还不懂得珍惜\n闪烁的是人类的智慧 摧残的是古老的文明\n脚踏的是先辈的血肉 手撑的是自已的天空\n\n嘴里念的是道德和法律 背后做的是花天和酒地\n心中想的是金钱和权力 眼睛寻的是公主和王子\n\n为了虚荣可以出卖肉体 为了欢乐可心朝三暮四\n为了刺激可以吸食毒品 为了利益可以拔刀动枪\n\n心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋\n有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕\n\n心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息\n那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡\n我无法留住我的那份清白 我无法拉住要飞的灵魂\n我开始在这世界玩命疯狂 我要冲这世界撕心裂肺\n啊——————\n\n有没有想过 你失去了什么\n\n记忆中的阳光　　何时才能重现\n让我在生死的边缘　　看到一点希望的光芒\n","source":"_posts/2016-10-21-zhi-xi.md","raw":"---\ntitle: 窒息\ndate: 2016-10-21 17:17:21\ntags:\n- 随笔\n---\n\n窒息\n\n追逐权利便抛弃良心 维护和平就发动战争\n欲望不断压缩和膨胀 失去了还不懂得珍惜\n闪烁的是人类的智慧 摧残的是古老的文明\n脚踏的是先辈的血肉 手撑的是自已的天空\n\n嘴里念的是道德和法律 背后做的是花天和酒地\n心中想的是金钱和权力 眼睛寻的是公主和王子\n\n为了虚荣可以出卖肉体 为了欢乐可心朝三暮四\n为了刺激可以吸食毒品 为了利益可以拔刀动枪\n\n心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋\n有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕\n\n心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息\n那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡\n我无法留住我的那份清白 我无法拉住要飞的灵魂\n我开始在这世界玩命疯狂 我要冲这世界撕心裂肺\n啊——————\n\n有没有想过 你失去了什么\n\n记忆中的阳光　　何时才能重现\n让我在生死的边缘　　看到一点希望的光芒\n","slug":"zhi-xi","published":1,"updated":"2016-11-15T21:13:11.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xda0005mclsh7w80fmq","content":"<p>窒息</p>\n<p>追逐权利便抛弃良心 维护和平就发动战争<br>欲望不断压缩和膨胀 失去了还不懂得珍惜<br>闪烁的是人类的智慧 摧残的是古老的文明<br>脚踏的是先辈的血肉 手撑的是自已的天空</p>\n<p>嘴里念的是道德和法律 背后做的是花天和酒地<br>心中想的是金钱和权力 眼睛寻的是公主和王子</p>\n<p>为了虚荣可以出卖肉体 为了欢乐可心朝三暮四<br>为了刺激可以吸食毒品 为了利益可以拔刀动枪</p>\n<p>心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋<br>有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕</p>\n<p>心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息<br>那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡<br>我无法留住我的那份清白 我无法拉住要飞的灵魂<br>我开始在这世界玩命疯狂 我要冲这世界撕心裂肺<br>啊——————</p>\n<p>有没有想过 你失去了什么</p>\n<p>记忆中的阳光　　何时才能重现<br>让我在生死的边缘　　看到一点希望的光芒</p>\n","excerpt":"","more":"<p>窒息</p>\n<p>追逐权利便抛弃良心 维护和平就发动战争<br>欲望不断压缩和膨胀 失去了还不懂得珍惜<br>闪烁的是人类的智慧 摧残的是古老的文明<br>脚踏的是先辈的血肉 手撑的是自已的天空</p>\n<p>嘴里念的是道德和法律 背后做的是花天和酒地<br>心中想的是金钱和权力 眼睛寻的是公主和王子</p>\n<p>为了虚荣可以出卖肉体 为了欢乐可心朝三暮四<br>为了刺激可以吸食毒品 为了利益可以拔刀动枪</p>\n<p>心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋<br>有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕</p>\n<p>心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息<br>那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡<br>我无法留住我的那份清白 我无法拉住要飞的灵魂<br>我开始在这世界玩命疯狂 我要冲这世界撕心裂肺<br>啊——————</p>\n<p>有没有想过 你失去了什么</p>\n<p>记忆中的阳光　　何时才能重现<br>让我在生死的边缘　　看到一点希望的光芒</p>\n"},{"title":"Red-Black Tree","date":"2016-11-16T21:04:28.000Z","_content":"\n# Preface #\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Introduction #\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either **RED** or **BLACK** and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n<a name=\"Properties\"></a>\n### Properties ###\n1. Every node is colored with either **RED** or **BLACK**;\n2. All leaf (NULL Pointer) nodes are colored with **BLACK**; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored **BLACK**._\n3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**). We call this number the **Black-Height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a **RED** node must be **BLACK** nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always **BLACK**;\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Application of Red-Black Tree #\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | **Black-Height** of the tree;                     |\n| $bh(x)$       | **Black-Height** of the node $x$;                 |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 4<sup>th</sup> property above as each **RED** node strictly requires **BLACK** children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Theorem #\nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n# Proof by induction #\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of **BLACK** nodes is __Black-Height__ of the node $x$, or $x$'s __Black-Height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sup>rd</sup> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sup>th</sup> **Red-Black Tree** properties, \"Both children of a **RED** node must be **BLACK** nodes\", we can say starting from the node x to leaf node, the number of **BLACK** nodes >= the number the **RED** nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __Black-Height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n**Corollary**:\nAll operations of a **Red-Black Tree** take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();\nInsert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Structure #\nEvery node of **Red-Black Tree** has $5$ attributes:\n\n```c\nstruct t_red_black_node {\n    enum { \n        RED, BLACK \n    } color;\n    void *key;\n    struct t_red_black_node *left;\n    struct t_red_black_node *right;\n    struct t_red_black_node *parent;\n\tvoid *value;\n\tint numLeft;      //optional\n\tint numRight;     //optional\n}\n```\n\nA **Red-Black Tree** node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated. \nOf course we can add more variables like the count of its children nodes according to the requirements.\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Rotations #\nHow does **inserting** or **deleting** nodes affect a **Red-Black Tree**? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like **inserting** or **deleting**, the **Red-Black Tree** is continue to keep the its properties and balance.\n\n**Rotation** is a basic operation for changing **Black-Red Tree** structure, it's a binary operation, between a **parent** node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).\n\nThere are two types of rotations: **Left Rotation** and **Right Rotation**. \n**Left Rotation** swaps the **parent** node with its right child, \n**Right Rotation** swaps the **parent** node with its left child. \n\n| **Left Rotation**                                           | &nbsp; |**Right Rotation**                                            |\n| :---:                                                       | ---    | :---:                                                        |\n| {% asset_img rbt_left_rotation_1.jpg \" \" \"Left Rotation\" %} | &nbsp; |{% asset_img rbt_right_rotation_1.jpg \" \" \"Right Rotation\" %} |\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n### Left Rotation ###\n\nHere are the steps involved in for **Left Rotation** (for **Right Rotation** just change \"Left\" to \"Right\" below):\n\nWhen do the **Left Rotation** on a **pivot**, assume its right child is not **NIL[T]**. **pivot** is a left child of any nodes but not **NIL[T]**\n**Left Rotation** is based on the axis between the **pivot** node and **y** node, the steps are:\n1. Let node **y** be the **parent** of the **pivot** node;\n2. Let the **pivot** node be the left child of node **y**;\n3. Let the left child of node **y** be the rigth child of the **pivot** node;\n\n\nThe C++ code for **Left Rotation** is below(use **x** as the **pivot** node which is mentioned above):\n\n```C++\nvoid Left_Rotate(Node **T,Node * x) {   // T: tree, x: pivot node\n  Node *y = x->right;  \n   \n  x->right = y->left;                   // Turn y's left subtree into x's right subtree\n  if (y->left != T_NIL)                 // If y->left is not null, set x as the parent of y's left child\n      y->left->p = x;  \n  y->p = x->p;                          // Link x's parent to y\n  if(x->p == T_NIL)                     // Means x is root, so its parent is nil\n     *T = y;                            // Case 1： first see whether we're at the root, set root as y if we are\n  else if (x == x->p->left)             // Case 2： x was on the left of its parent\n     x->p->left = y;                    //         set y as the left child of x's parent\n  else                                  // Case 3: x must have been on the right\n     x->p->right = y;                   //         so set y as the right child of x's parent;\n  y->left = x;                          // Set x as y's left child \n  x->p = y;                             // Set y as x's parent;\n}  \n```\n\nSo as the figure below, **Left Rotation** on node **X** means make node **X**'s right child as node **X**'s **parent** node, that is make node **X** as a left child node (node **X** becomes the left child of node **Z**)!\nSo **Left** means the **Rotated** node will be turned to a left child node.\n{% asset_img rbt_left_rotation_example_1.png \" \" \"Left Rotation\" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n### Right Rotation ###\n\nThe C++ code for **Right Rotation** is below(use **y** as the **pivot** node which is mentioned above):\n\n```C++\nvoid Right_Rotate(Node **T,Node *y) {   // T: tree, y: pivot node\n  Node *x = y->left;  \n   \n  y->left = x->right;                  // Turn x's right subtree into y's left subtree\n  if (x->right != T_NIL)               // If x->right is not null, set y as the parent of x's right child\n      x->right->p = y;  \n  x->p = y->p;                         // Link y's parent to x\n  if(y->p == T_NIL)                    // Means y is root, so its parent is nil\n     *T = x;                           // Case 1： first see whether we're at the root, set root as x if we are\n  else if (y == y->p->left)            // Case 2： y was on the left of its parent\n     y->p->left = x;                   //         set x as the left child of y's parent\n  else                                 // Case 3: y must have been on the right\n     y->p->right = x;                  //         so set x as the right child of y's parent\n  x->right = y;                        // Set y as x's right child \n  y->p = x;                            // Set x as y's parent\n}  \n```\n\nSo as the figure below, **Reft Rotation** on **x** means make **x**'s left child as **x**'s **parent**, that is make **x** as a right child node (**x** becomes the right child of **y**)!\nSo **Right** means the **Rotated** node will be turned to a right child node.\n{% asset_img rbt_right_rotation_example_1.png \" \" \"Right Rotation\" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\nSo **Left Rotation** and **Right Rotation** are a pair of **invertible** operations. \n{% asset_img rbt_invertible_rotation.png \" \" \"Invertible Operations between Left/Right Rotation\" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n\n\n# References #\nhttp://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm\nhttp://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/\nhttps://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html\nhttps://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html\nhttps://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md\nhttps://www.cs.duke.edu/~reif/courses/alglectures/skiena.lectures/lecture10.pdf\nhttp://www.cnblogs.com/skywang12345/p/3245399.html\nhttp://blog.csdn.net/luoshixian099/article/details/45786665","source":"_posts/2016-11-16-Red-Black-Tree.md","raw":"---\ntitle: Red-Black Tree\ndate: 2016-11-16 16:04:28\ntags:\n- Algorithm\n- Tree\n---\n\n# Preface #\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Introduction #\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either **RED** or **BLACK** and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n<a name=\"Properties\"></a>\n### Properties ###\n1. Every node is colored with either **RED** or **BLACK**;\n2. All leaf (NULL Pointer) nodes are colored with **BLACK**; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored **BLACK**._\n3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**). We call this number the **Black-Height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a **RED** node must be **BLACK** nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always **BLACK**;\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Application of Red-Black Tree #\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | **Black-Height** of the tree;                     |\n| $bh(x)$       | **Black-Height** of the node $x$;                 |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 4<sup>th</sup> property above as each **RED** node strictly requires **BLACK** children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Theorem #\nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n# Proof by induction #\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of **BLACK** nodes is __Black-Height__ of the node $x$, or $x$'s __Black-Height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sup>rd</sup> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sup>th</sup> **Red-Black Tree** properties, \"Both children of a **RED** node must be **BLACK** nodes\", we can say starting from the node x to leaf node, the number of **BLACK** nodes >= the number the **RED** nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __Black-Height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n**Corollary**:\nAll operations of a **Red-Black Tree** take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();\nInsert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Structure #\nEvery node of **Red-Black Tree** has $5$ attributes:\n\n```c\nstruct t_red_black_node {\n    enum { \n        RED, BLACK \n    } color;\n    void *key;\n    struct t_red_black_node *left;\n    struct t_red_black_node *right;\n    struct t_red_black_node *parent;\n\tvoid *value;\n\tint numLeft;      //optional\n\tint numRight;     //optional\n}\n```\n\nA **Red-Black Tree** node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated. \nOf course we can add more variables like the count of its children nodes according to the requirements.\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n# Rotations #\nHow does **inserting** or **deleting** nodes affect a **Red-Black Tree**? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like **inserting** or **deleting**, the **Red-Black Tree** is continue to keep the its properties and balance.\n\n**Rotation** is a basic operation for changing **Black-Red Tree** structure, it's a binary operation, between a **parent** node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).\n\nThere are two types of rotations: **Left Rotation** and **Right Rotation**. \n**Left Rotation** swaps the **parent** node with its right child, \n**Right Rotation** swaps the **parent** node with its left child. \n\n| **Left Rotation**                                           | &nbsp; |**Right Rotation**                                            |\n| :---:                                                       | ---    | :---:                                                        |\n| {% asset_img rbt_left_rotation_1.jpg \" \" \"Left Rotation\" %} | &nbsp; |{% asset_img rbt_right_rotation_1.jpg \" \" \"Right Rotation\" %} |\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n### Left Rotation ###\n\nHere are the steps involved in for **Left Rotation** (for **Right Rotation** just change \"Left\" to \"Right\" below):\n\nWhen do the **Left Rotation** on a **pivot**, assume its right child is not **NIL[T]**. **pivot** is a left child of any nodes but not **NIL[T]**\n**Left Rotation** is based on the axis between the **pivot** node and **y** node, the steps are:\n1. Let node **y** be the **parent** of the **pivot** node;\n2. Let the **pivot** node be the left child of node **y**;\n3. Let the left child of node **y** be the rigth child of the **pivot** node;\n\n\nThe C++ code for **Left Rotation** is below(use **x** as the **pivot** node which is mentioned above):\n\n```C++\nvoid Left_Rotate(Node **T,Node * x) {   // T: tree, x: pivot node\n  Node *y = x->right;  \n   \n  x->right = y->left;                   // Turn y's left subtree into x's right subtree\n  if (y->left != T_NIL)                 // If y->left is not null, set x as the parent of y's left child\n      y->left->p = x;  \n  y->p = x->p;                          // Link x's parent to y\n  if(x->p == T_NIL)                     // Means x is root, so its parent is nil\n     *T = y;                            // Case 1： first see whether we're at the root, set root as y if we are\n  else if (x == x->p->left)             // Case 2： x was on the left of its parent\n     x->p->left = y;                    //         set y as the left child of x's parent\n  else                                  // Case 3: x must have been on the right\n     x->p->right = y;                   //         so set y as the right child of x's parent;\n  y->left = x;                          // Set x as y's left child \n  x->p = y;                             // Set y as x's parent;\n}  \n```\n\nSo as the figure below, **Left Rotation** on node **X** means make node **X**'s right child as node **X**'s **parent** node, that is make node **X** as a left child node (node **X** becomes the left child of node **Z**)!\nSo **Left** means the **Rotated** node will be turned to a left child node.\n{% asset_img rbt_left_rotation_example_1.png \" \" \"Left Rotation\" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n### Right Rotation ###\n\nThe C++ code for **Right Rotation** is below(use **y** as the **pivot** node which is mentioned above):\n\n```C++\nvoid Right_Rotate(Node **T,Node *y) {   // T: tree, y: pivot node\n  Node *x = y->left;  \n   \n  y->left = x->right;                  // Turn x's right subtree into y's left subtree\n  if (x->right != T_NIL)               // If x->right is not null, set y as the parent of x's right child\n      x->right->p = y;  \n  x->p = y->p;                         // Link y's parent to x\n  if(y->p == T_NIL)                    // Means y is root, so its parent is nil\n     *T = x;                           // Case 1： first see whether we're at the root, set root as x if we are\n  else if (y == y->p->left)            // Case 2： y was on the left of its parent\n     y->p->left = x;                   //         set x as the left child of y's parent\n  else                                 // Case 3: y must have been on the right\n     y->p->right = x;                  //         so set x as the right child of y's parent\n  x->right = y;                        // Set y as x's right child \n  y->p = x;                            // Set x as y's parent\n}  \n```\n\nSo as the figure below, **Reft Rotation** on **x** means make **x**'s left child as **x**'s **parent**, that is make **x** as a right child node (**x** becomes the right child of **y**)!\nSo **Right** means the **Rotated** node will be turned to a right child node.\n{% asset_img rbt_right_rotation_example_1.png \" \" \"Right Rotation\" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\nSo **Left Rotation** and **Right Rotation** are a pair of **invertible** operations. \n{% asset_img rbt_invertible_rotation.png \" \" \"Invertible Operations between Left/Right Rotation\" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n\n\n# References #\nhttp://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm\nhttp://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/\nhttps://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html\nhttps://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html\nhttps://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md\nhttps://www.cs.duke.edu/~reif/courses/alglectures/skiena.lectures/lecture10.pdf\nhttp://www.cnblogs.com/skywang12345/p/3245399.html\nhttp://blog.csdn.net/luoshixian099/article/details/45786665","slug":"Red-Black-Tree","published":1,"updated":"2016-11-29T20:47:17.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xdp0006mclsh19ywdzn","content":"<h1 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h1><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either <strong>RED</strong> or <strong>BLACK</strong> and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<p><a name=\"Properties\"></a></p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong>;</li>\n<li>All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong>;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored <strong>BLACK</strong>.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>Black-Height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always <strong>BLACK</strong>;</li>\n</ol>\n<img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h1 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h1><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\"><strong>Black-Height</strong> of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\"><strong>Black-Height</strong> of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 4<sup>th</sup> property above as each <strong>RED</strong> node strictly requires <strong>BLACK</strong> children</em>)</p>\n<hr>\n<h1 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h1><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h1 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h1><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of <strong>BLACK</strong> nodes is <strong>Black-Height</strong> of the node $x$, or $x$’s <strong>Black-Height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sup>rd</sup> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sup>th</sup> <strong>Red-Black Tree</strong> properties, “Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes”, we can say starting from the node x to leaf node, the number of <strong>BLACK</strong> nodes &gt;= the number the <strong>RED</strong> nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>Black-Height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<p><strong>Corollary</strong>:<br>All operations of a <strong>Red-Black Tree</strong> take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();<br>Insert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;</p>\n<hr>\n<h1 id=\"Structure\"><a href=\"#Structure\" class=\"headerlink\" title=\"Structure\"></a>Structure</h1><p>Every node of <strong>Red-Black Tree</strong> has $5$ attributes:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> t_red_black_node &#123;</div><div class=\"line\">    <span class=\"keyword\">enum</span> &#123; </div><div class=\"line\">        RED, BLACK </div><div class=\"line\">    &#125; color;</div><div class=\"line\">    <span class=\"keyword\">void</span> *key;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *left;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *right;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *parent;</div><div class=\"line\">\t<span class=\"keyword\">void</span> *value;</div><div class=\"line\">\t<span class=\"keyword\">int</span> numLeft;      <span class=\"comment\">//optional</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> numRight;     <span class=\"comment\">//optional</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>A <strong>Red-Black Tree</strong> node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated.<br>Of course we can add more variables like the count of its children nodes according to the requirements.</p>\n<hr>\n<h1 id=\"Rotations\"><a href=\"#Rotations\" class=\"headerlink\" title=\"Rotations\"></a>Rotations</h1><p>How does <strong>inserting</strong> or <strong>deleting</strong> nodes affect a <strong>Red-Black Tree</strong>? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like <strong>inserting</strong> or <strong>deleting</strong>, the <strong>Red-Black Tree</strong> is continue to keep the its properties and balance.</p>\n<p><strong>Rotation</strong> is a basic operation for changing <strong>Black-Red Tree</strong> structure, it’s a binary operation, between a <strong>parent</strong> node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).</p>\n<p>There are two types of rotations: <strong>Left Rotation</strong> and <strong>Right Rotation</strong>.<br><strong>Left Rotation</strong> swaps the <strong>parent</strong> node with its right child,<br><strong>Right Rotation</strong> swaps the <strong>parent</strong> node with its left child. </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>Left Rotation</strong></th>\n<th>&nbsp;</th>\n<th style=\"text-align:center\"><strong>Right Rotation</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_1.jpg\" alt=\" Left Rotation\" title=\" Left Rotation\"></td>\n<td>&nbsp;</td>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_1.jpg\" alt=\" Right Rotation\" title=\" Right Rotation\"></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"Left-Rotation\"><a href=\"#Left-Rotation\" class=\"headerlink\" title=\"Left Rotation\"></a>Left Rotation</h3><p>Here are the steps involved in for <strong>Left Rotation</strong> (for <strong>Right Rotation</strong> just change “Left” to “Right” below):</p>\n<p>When do the <strong>Left Rotation</strong> on a <strong>pivot</strong>, assume its right child is not <strong>NIL[T]</strong>. <strong>pivot</strong> is a left child of any nodes but not <strong>NIL[T]</strong><br><strong>Left Rotation</strong> is based on the axis between the <strong>pivot</strong> node and <strong>y</strong> node, the steps are:</p>\n<ol>\n<li>Let node <strong>y</strong> be the <strong>parent</strong> of the <strong>pivot</strong> node;</li>\n<li>Let the <strong>pivot</strong> node be the left child of node <strong>y</strong>;</li>\n<li>Let the left child of node <strong>y</strong> be the rigth child of the <strong>pivot</strong> node;</li>\n</ol>\n<p>The C++ code for <strong>Left Rotation</strong> is below(use <strong>x</strong> as the <strong>pivot</strong> node which is mentioned above):</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Left_Rotate</span><span class=\"params\">(Node **T,Node * x)</span> </span>&#123;   <span class=\"comment\">// T: tree, x: pivot node</span></div><div class=\"line\">  Node *y = x-&gt;right;  </div><div class=\"line\">   </div><div class=\"line\">  x-&gt;right = y-&gt;left;                   <span class=\"comment\">// Turn y's left subtree into x's right subtree</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (y-&gt;left != T_NIL)                 <span class=\"comment\">// If y-&gt;left is not null, set x as the parent of y's left child</span></div><div class=\"line\">      y-&gt;left-&gt;p = x;  </div><div class=\"line\">  y-&gt;p = x-&gt;p;                          <span class=\"comment\">// Link x's parent to y</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(x-&gt;p == T_NIL)                     <span class=\"comment\">// Means x is root, so its parent is nil</span></div><div class=\"line\">     *T = y;                            <span class=\"comment\">// Case 1： first see whether we're at the root, set root as y if we are</span></div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x == x-&gt;p-&gt;left)             <span class=\"comment\">// Case 2： x was on the left of its parent</span></div><div class=\"line\">     x-&gt;p-&gt;left = y;                    <span class=\"comment\">//         set y as the left child of x's parent</span></div><div class=\"line\">  <span class=\"keyword\">else</span>                                  <span class=\"comment\">// Case 3: x must have been on the right</span></div><div class=\"line\">     x-&gt;p-&gt;right = y;                   <span class=\"comment\">//         so set y as the right child of x's parent;</span></div><div class=\"line\">  y-&gt;left = x;                          <span class=\"comment\">// Set x as y's left child </span></div><div class=\"line\">  x-&gt;p = y;                             <span class=\"comment\">// Set y as x's parent;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So as the figure below, <strong>Left Rotation</strong> on node <strong>X</strong> means make node <strong>X</strong>‘s right child as node <strong>X</strong>‘s <strong>parent</strong> node, that is make node <strong>X</strong> as a left child node (node <strong>X</strong> becomes the left child of node <strong>Z</strong>)!<br>So <strong>Left</strong> means the <strong>Rotated</strong> node will be turned to a left child node.<br><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_example_1.png\" alt=\" Left Rotation\" title=\" Left Rotation\"> </p>\n<hr>\n<h3 id=\"Right-Rotation\"><a href=\"#Right-Rotation\" class=\"headerlink\" title=\"Right Rotation\"></a>Right Rotation</h3><p>The C++ code for <strong>Right Rotation</strong> is below(use <strong>y</strong> as the <strong>pivot</strong> node which is mentioned above):</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Right_Rotate</span><span class=\"params\">(Node **T,Node *y)</span> </span>&#123;   <span class=\"comment\">// T: tree, y: pivot node</span></div><div class=\"line\">  Node *x = y-&gt;left;  </div><div class=\"line\">   </div><div class=\"line\">  y-&gt;left = x-&gt;right;                  <span class=\"comment\">// Turn x's right subtree into y's left subtree</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (x-&gt;right != T_NIL)               <span class=\"comment\">// If x-&gt;right is not null, set y as the parent of x's right child</span></div><div class=\"line\">      x-&gt;right-&gt;p = y;  </div><div class=\"line\">  x-&gt;p = y-&gt;p;                         <span class=\"comment\">// Link y's parent to x</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(y-&gt;p == T_NIL)                    <span class=\"comment\">// Means y is root, so its parent is nil</span></div><div class=\"line\">     *T = x;                           <span class=\"comment\">// Case 1： first see whether we're at the root, set root as x if we are</span></div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y == y-&gt;p-&gt;left)            <span class=\"comment\">// Case 2： y was on the left of its parent</span></div><div class=\"line\">     y-&gt;p-&gt;left = x;                   <span class=\"comment\">//         set x as the left child of y's parent</span></div><div class=\"line\">  <span class=\"keyword\">else</span>                                 <span class=\"comment\">// Case 3: y must have been on the right</span></div><div class=\"line\">     y-&gt;p-&gt;right = x;                  <span class=\"comment\">//         so set x as the right child of y's parent</span></div><div class=\"line\">  x-&gt;right = y;                        <span class=\"comment\">// Set y as x's right child </span></div><div class=\"line\">  y-&gt;p = x;                            <span class=\"comment\">// Set x as y's parent</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So as the figure below, <strong>Reft Rotation</strong> on <strong>x</strong> means make <strong>x</strong>‘s left child as <strong>x</strong>‘s <strong>parent</strong>, that is make <strong>x</strong> as a right child node (<strong>x</strong> becomes the right child of <strong>y</strong>)!<br>So <strong>Right</strong> means the <strong>Rotated</strong> node will be turned to a right child node.<br><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_example_1.png\" alt=\" Right Rotation\" title=\" Right Rotation\"> </p>\n<hr>\n<p>So <strong>Left Rotation</strong> and <strong>Right Rotation</strong> are a pair of <strong>invertible</strong> operations.<br><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_invertible_rotation.png\" alt=\" Invertible Operations between Left/Right Rotation\" title=\" Invertible Operations between Left/Right Rotation\"> </p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm\" target=\"_blank\" rel=\"external\">http://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm</a><br><a href=\"http://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/\" target=\"_blank\" rel=\"external\">http://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/</a><br><a href=\"https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html\" target=\"_blank\" rel=\"external\">https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html</a><br><a href=\"https://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html\" target=\"_blank\" rel=\"external\">https://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html</a><br><a href=\"https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md\" target=\"_blank\" rel=\"external\">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a><br><a href=\"https://www.cs.duke.edu/~reif/courses/alglectures/skiena.lectures/lecture10.pdf\" target=\"_blank\" rel=\"external\">https://www.cs.duke.edu/~reif/courses/alglectures/skiena.lectures/lecture10.pdf</a><br><a href=\"http://www.cnblogs.com/skywang12345/p/3245399.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/skywang12345/p/3245399.html</a><br><a href=\"http://blog.csdn.net/luoshixian099/article/details/45786665\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luoshixian099/article/details/45786665</a></p>\n","excerpt":"","more":"<h1 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h1><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either <strong>RED</strong> or <strong>BLACK</strong> and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<p><a name=\"Properties\"></a></p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong>;</li>\n<li>All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong>;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored <strong>BLACK</strong>.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>Black-Height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always <strong>BLACK</strong>;</li>\n</ol>\n<img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h1 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h1><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\"><strong>Black-Height</strong> of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\"><strong>Black-Height</strong> of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 4<sup>th</sup> property above as each <strong>RED</strong> node strictly requires <strong>BLACK</strong> children</em>)</p>\n<hr>\n<h1 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h1><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h1 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h1><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of <strong>BLACK</strong> nodes is <strong>Black-Height</strong> of the node $x$, or $x$’s <strong>Black-Height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sup>rd</sup> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sup>th</sup> <strong>Red-Black Tree</strong> properties, “Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes”, we can say starting from the node x to leaf node, the number of <strong>BLACK</strong> nodes &gt;= the number the <strong>RED</strong> nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>Black-Height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<p><strong>Corollary</strong>:<br>All operations of a <strong>Red-Black Tree</strong> take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();<br>Insert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;</p>\n<hr>\n<h1 id=\"Structure\"><a href=\"#Structure\" class=\"headerlink\" title=\"Structure\"></a>Structure</h1><p>Every node of <strong>Red-Black Tree</strong> has $5$ attributes:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> t_red_black_node &#123;</div><div class=\"line\">    <span class=\"keyword\">enum</span> &#123; </div><div class=\"line\">        RED, BLACK </div><div class=\"line\">    &#125; color;</div><div class=\"line\">    <span class=\"keyword\">void</span> *key;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *left;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *right;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *parent;</div><div class=\"line\">\t<span class=\"keyword\">void</span> *value;</div><div class=\"line\">\t<span class=\"keyword\">int</span> numLeft;      <span class=\"comment\">//optional</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> numRight;     <span class=\"comment\">//optional</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>A <strong>Red-Black Tree</strong> node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated.<br>Of course we can add more variables like the count of its children nodes according to the requirements.</p>\n<hr>\n<h1 id=\"Rotations\"><a href=\"#Rotations\" class=\"headerlink\" title=\"Rotations\"></a>Rotations</h1><p>How does <strong>inserting</strong> or <strong>deleting</strong> nodes affect a <strong>Red-Black Tree</strong>? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like <strong>inserting</strong> or <strong>deleting</strong>, the <strong>Red-Black Tree</strong> is continue to keep the its properties and balance.</p>\n<p><strong>Rotation</strong> is a basic operation for changing <strong>Black-Red Tree</strong> structure, it’s a binary operation, between a <strong>parent</strong> node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).</p>\n<p>There are two types of rotations: <strong>Left Rotation</strong> and <strong>Right Rotation</strong>.<br><strong>Left Rotation</strong> swaps the <strong>parent</strong> node with its right child,<br><strong>Right Rotation</strong> swaps the <strong>parent</strong> node with its left child. </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>Left Rotation</strong></th>\n<th>&nbsp;</th>\n<th style=\"text-align:center\"><strong>Right Rotation</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_1.jpg\" alt=\" Left Rotation\" title=\" Left Rotation\"></td>\n<td>&nbsp;</td>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_1.jpg\" alt=\" Right Rotation\" title=\" Right Rotation\"></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"Left-Rotation\"><a href=\"#Left-Rotation\" class=\"headerlink\" title=\"Left Rotation\"></a>Left Rotation</h3><p>Here are the steps involved in for <strong>Left Rotation</strong> (for <strong>Right Rotation</strong> just change “Left” to “Right” below):</p>\n<p>When do the <strong>Left Rotation</strong> on a <strong>pivot</strong>, assume its right child is not <strong>NIL[T]</strong>. <strong>pivot</strong> is a left child of any nodes but not <strong>NIL[T]</strong><br><strong>Left Rotation</strong> is based on the axis between the <strong>pivot</strong> node and <strong>y</strong> node, the steps are:</p>\n<ol>\n<li>Let node <strong>y</strong> be the <strong>parent</strong> of the <strong>pivot</strong> node;</li>\n<li>Let the <strong>pivot</strong> node be the left child of node <strong>y</strong>;</li>\n<li>Let the left child of node <strong>y</strong> be the rigth child of the <strong>pivot</strong> node;</li>\n</ol>\n<p>The C++ code for <strong>Left Rotation</strong> is below(use <strong>x</strong> as the <strong>pivot</strong> node which is mentioned above):</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Left_Rotate</span><span class=\"params\">(Node **T,Node * x)</span> </span>&#123;   <span class=\"comment\">// T: tree, x: pivot node</span></div><div class=\"line\">  Node *y = x-&gt;right;  </div><div class=\"line\">   </div><div class=\"line\">  x-&gt;right = y-&gt;left;                   <span class=\"comment\">// Turn y's left subtree into x's right subtree</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (y-&gt;left != T_NIL)                 <span class=\"comment\">// If y-&gt;left is not null, set x as the parent of y's left child</span></div><div class=\"line\">      y-&gt;left-&gt;p = x;  </div><div class=\"line\">  y-&gt;p = x-&gt;p;                          <span class=\"comment\">// Link x's parent to y</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(x-&gt;p == T_NIL)                     <span class=\"comment\">// Means x is root, so its parent is nil</span></div><div class=\"line\">     *T = y;                            <span class=\"comment\">// Case 1： first see whether we're at the root, set root as y if we are</span></div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x == x-&gt;p-&gt;left)             <span class=\"comment\">// Case 2： x was on the left of its parent</span></div><div class=\"line\">     x-&gt;p-&gt;left = y;                    <span class=\"comment\">//         set y as the left child of x's parent</span></div><div class=\"line\">  <span class=\"keyword\">else</span>                                  <span class=\"comment\">// Case 3: x must have been on the right</span></div><div class=\"line\">     x-&gt;p-&gt;right = y;                   <span class=\"comment\">//         so set y as the right child of x's parent;</span></div><div class=\"line\">  y-&gt;left = x;                          <span class=\"comment\">// Set x as y's left child </span></div><div class=\"line\">  x-&gt;p = y;                             <span class=\"comment\">// Set y as x's parent;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So as the figure below, <strong>Left Rotation</strong> on node <strong>X</strong> means make node <strong>X</strong>‘s right child as node <strong>X</strong>‘s <strong>parent</strong> node, that is make node <strong>X</strong> as a left child node (node <strong>X</strong> becomes the left child of node <strong>Z</strong>)!<br>So <strong>Left</strong> means the <strong>Rotated</strong> node will be turned to a left child node.<br><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_example_1.png\" alt=\" Left Rotation\" title=\" Left Rotation\"> </p>\n<hr>\n<h3 id=\"Right-Rotation\"><a href=\"#Right-Rotation\" class=\"headerlink\" title=\"Right Rotation\"></a>Right Rotation</h3><p>The C++ code for <strong>Right Rotation</strong> is below(use <strong>y</strong> as the <strong>pivot</strong> node which is mentioned above):</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Right_Rotate</span><span class=\"params\">(Node **T,Node *y)</span> </span>&#123;   <span class=\"comment\">// T: tree, y: pivot node</span></div><div class=\"line\">  Node *x = y-&gt;left;  </div><div class=\"line\">   </div><div class=\"line\">  y-&gt;left = x-&gt;right;                  <span class=\"comment\">// Turn x's right subtree into y's left subtree</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (x-&gt;right != T_NIL)               <span class=\"comment\">// If x-&gt;right is not null, set y as the parent of x's right child</span></div><div class=\"line\">      x-&gt;right-&gt;p = y;  </div><div class=\"line\">  x-&gt;p = y-&gt;p;                         <span class=\"comment\">// Link y's parent to x</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(y-&gt;p == T_NIL)                    <span class=\"comment\">// Means y is root, so its parent is nil</span></div><div class=\"line\">     *T = x;                           <span class=\"comment\">// Case 1： first see whether we're at the root, set root as x if we are</span></div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (y == y-&gt;p-&gt;left)            <span class=\"comment\">// Case 2： y was on the left of its parent</span></div><div class=\"line\">     y-&gt;p-&gt;left = x;                   <span class=\"comment\">//         set x as the left child of y's parent</span></div><div class=\"line\">  <span class=\"keyword\">else</span>                                 <span class=\"comment\">// Case 3: y must have been on the right</span></div><div class=\"line\">     y-&gt;p-&gt;right = x;                  <span class=\"comment\">//         so set x as the right child of y's parent</span></div><div class=\"line\">  x-&gt;right = y;                        <span class=\"comment\">// Set y as x's right child </span></div><div class=\"line\">  y-&gt;p = x;                            <span class=\"comment\">// Set x as y's parent</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So as the figure below, <strong>Reft Rotation</strong> on <strong>x</strong> means make <strong>x</strong>‘s left child as <strong>x</strong>‘s <strong>parent</strong>, that is make <strong>x</strong> as a right child node (<strong>x</strong> becomes the right child of <strong>y</strong>)!<br>So <strong>Right</strong> means the <strong>Rotated</strong> node will be turned to a right child node.<br><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_example_1.png\" alt=\" Right Rotation\" title=\" Right Rotation\"> </p>\n<hr>\n<p>So <strong>Left Rotation</strong> and <strong>Right Rotation</strong> are a pair of <strong>invertible</strong> operations.<br><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_invertible_rotation.png\" alt=\" Invertible Operations between Left/Right Rotation\" title=\" Invertible Operations between Left/Right Rotation\"> </p>\n<hr>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><p><a href=\"http://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm\">http://www.cs.virginia.edu/~luebke/cs332.fall00/lecture10/index.htm</a><br><a href=\"http://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/\">http://pages.cs.wisc.edu/~paton/readings/Red-Black-Trees/</a><br><a href=\"https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html\">https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html</a><br><a href=\"https://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html\">https://www.cs.auckland.ac.nz/software/AlgAnim/red_black_op.html</a><br><a href=\"https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md\">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a><br><a href=\"https://www.cs.duke.edu/~reif/courses/alglectures/skiena.lectures/lecture10.pdf\">https://www.cs.duke.edu/~reif/courses/alglectures/skiena.lectures/lecture10.pdf</a><br><a href=\"http://www.cnblogs.com/skywang12345/p/3245399.html\">http://www.cnblogs.com/skywang12345/p/3245399.html</a><br><a href=\"http://blog.csdn.net/luoshixian099/article/details/45786665\">http://blog.csdn.net/luoshixian099/article/details/45786665</a></p>\n"},{"title":"Height of a Complete Binary Tree","date":"2016-11-09T05:28:17.000Z","_content":"\nThe height of a complete binary tree is $O(log n)$\n\n### Theorem ###\nThe height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .\n\n### Intuition ###\n| Tree | Nodes($n$) | Height $log(n+1)$ |\n| :--- | :---: | :---: | \n| {% asset_img min_tree1.gif \" \" \" \" %} | 1 | 1 |\n| {% asset_img min_tree2.gif \" \" \" \" %} | 3 | 2 |\n| {% asset_img min_tree3.gif \" \" \" \" %} | 7 | 3 |\n\n### Proof ###\n\n$n$ : Number of nodes in the tree.\n$h$ : Height of the tree.\n\n##### Precondition #####\nSince the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.\nSo $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub>\nAnd $n$<sub>left</sub> $=$ $n$<sub>right</sub>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub>\n\n##### Basis #####\n$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1\n\n##### Inductive Hypothesis #####\nAssume that the theorem is **true** for heights <= $k$ .\n\t\n##### Inductive Step #####\nProve that the inductive hypothhesis is **true** for height $k + 1$\n\t\nLet $h$ as the height of the Complete Binary Tree with $n$ nodes, \nand let $h = k + 1$ .\n\nSo $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, \n\nso $k = log_2(n$<sub>left</sub> $+$ $1)$ --------- *by the inductive hypothesis*\n \nNote that the theorem is **true** (by the inductive hypothesis) of the subtrees of the root, since they have height $k$\n\n| &nbsp;   | &nbsp;              | &nbsp; | &nbsp;                                         | &nbsp; |\n| :---     | ---:                | :---:  | :---                                           | ---: |\n| &nbsp;   | $n$                 | $=$    | $1 + n$<sub>left</sub> $+$ $n$<sub>right</sub> | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $1 + 2n$<sub>left</sub>                        | *since the tree is complete* |\n| **BUT**  | $k$                 | $=$    | $log_2(n$<sub>left</sub> $+$ $1)$              | *by the inductive hypothesis* |\n| **SO**   | $n$<sub>left</sub>  | $=$    | $2^k - 1$                                      | &nbsp; |\n| **THEN** | $n$                 | $=$    | $1 + 2(2^k - 1)$                               | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $2^{k + 1} - 1$                                | &nbsp; |\n| &nbsp;   | $log_2(n+1)$        | $=$    | $log_2(2^{k + 1})$                             | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $k + 1$                                        | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $h$                                            | &nbsp; |\n\n\n\nThus, the inductive hypothesis is **true** for height $k + 1$ and, hence (by induction), **true** for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .\n\n##### Reference ######\n* http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/","source":"_posts/2016-11-09-Height-of-a-Complete-Binary-Tree.md","raw":"---\ntitle: Height of a Complete Binary Tree\ndate: 2016-11-09 00:28:17\ntags:\n- Algorithm\n- Tree\n---\n\nThe height of a complete binary tree is $O(log n)$\n\n### Theorem ###\nThe height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .\n\n### Intuition ###\n| Tree | Nodes($n$) | Height $log(n+1)$ |\n| :--- | :---: | :---: | \n| {% asset_img min_tree1.gif \" \" \" \" %} | 1 | 1 |\n| {% asset_img min_tree2.gif \" \" \" \" %} | 3 | 2 |\n| {% asset_img min_tree3.gif \" \" \" \" %} | 7 | 3 |\n\n### Proof ###\n\n$n$ : Number of nodes in the tree.\n$h$ : Height of the tree.\n\n##### Precondition #####\nSince the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.\nSo $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub>\nAnd $n$<sub>left</sub> $=$ $n$<sub>right</sub>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub>\n\n##### Basis #####\n$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1\n\n##### Inductive Hypothesis #####\nAssume that the theorem is **true** for heights <= $k$ .\n\t\n##### Inductive Step #####\nProve that the inductive hypothhesis is **true** for height $k + 1$\n\t\nLet $h$ as the height of the Complete Binary Tree with $n$ nodes, \nand let $h = k + 1$ .\n\nSo $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, \n\nso $k = log_2(n$<sub>left</sub> $+$ $1)$ --------- *by the inductive hypothesis*\n \nNote that the theorem is **true** (by the inductive hypothesis) of the subtrees of the root, since they have height $k$\n\n| &nbsp;   | &nbsp;              | &nbsp; | &nbsp;                                         | &nbsp; |\n| :---     | ---:                | :---:  | :---                                           | ---: |\n| &nbsp;   | $n$                 | $=$    | $1 + n$<sub>left</sub> $+$ $n$<sub>right</sub> | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $1 + 2n$<sub>left</sub>                        | *since the tree is complete* |\n| **BUT**  | $k$                 | $=$    | $log_2(n$<sub>left</sub> $+$ $1)$              | *by the inductive hypothesis* |\n| **SO**   | $n$<sub>left</sub>  | $=$    | $2^k - 1$                                      | &nbsp; |\n| **THEN** | $n$                 | $=$    | $1 + 2(2^k - 1)$                               | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $2^{k + 1} - 1$                                | &nbsp; |\n| &nbsp;   | $log_2(n+1)$        | $=$    | $log_2(2^{k + 1})$                             | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $k + 1$                                        | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $h$                                            | &nbsp; |\n\n\n\nThus, the inductive hypothesis is **true** for height $k + 1$ and, hence (by induction), **true** for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .\n\n##### Reference ######\n* http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/","slug":"Height-of-a-Complete-Binary-Tree","published":1,"updated":"2016-11-15T21:13:11.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xdp0007mcls8qjnyt7d","content":"<p>The height of a complete binary tree is $O(log n)$</p>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>The height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .</p>\n<h3 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Tree</th>\n<th style=\"text-align:center\">Nodes($n$)</th>\n<th style=\"text-align:center\">Height $log(n+1)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree1.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree2.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree3.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Proof\"><a href=\"#Proof\" class=\"headerlink\" title=\"Proof\"></a>Proof</h3><p>$n$ : Number of nodes in the tree.<br>$h$ : Height of the tree.</p>\n<h5 id=\"Precondition\"><a href=\"#Precondition\" class=\"headerlink\" title=\"Precondition\"></a>Precondition</h5><p>Since the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.<br>So $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub><br>And $n$<sub>left</sub> $=$ $n$<sub>right</sub><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub></p>\n<h5 id=\"Basis\"><a href=\"#Basis\" class=\"headerlink\" title=\"Basis\"></a>Basis</h5><p>$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1</p>\n<h5 id=\"Inductive-Hypothesis\"><a href=\"#Inductive-Hypothesis\" class=\"headerlink\" title=\"Inductive Hypothesis\"></a>Inductive Hypothesis</h5><p>Assume that the theorem is <strong>true</strong> for heights &lt;= $k$ .</p>\n<h5 id=\"Inductive-Step\"><a href=\"#Inductive-Step\" class=\"headerlink\" title=\"Inductive Step\"></a>Inductive Step</h5><p>Prove that the inductive hypothhesis is <strong>true</strong> for height $k + 1$</p>\n<p>Let $h$ as the height of the Complete Binary Tree with $n$ nodes,<br>and let $h = k + 1$ .</p>\n<p>So $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, </p>\n<p>so $k = log_2(n$<sub>left</sub> $+$ $1)$ ——— <em>by the inductive hypothesis</em></p>\n<p>Note that the theorem is <strong>true</strong> (by the inductive hypothesis) of the subtrees of the root, since they have height $k$</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + n$<sub>left</sub> $+$ $n$<sub>right</sub></td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2n$<sub>left</sub></td>\n<td style=\"text-align:right\"><em>since the tree is complete</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>BUT</strong></td>\n<td style=\"text-align:right\">$k$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(n$<sub>left</sub> $+$ $1)$</td>\n<td style=\"text-align:right\"><em>by the inductive hypothesis</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>SO</strong></td>\n<td style=\"text-align:right\">$n$<sub>left</sub></td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^k - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>THEN</strong></td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2(2^k - 1)$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^{k + 1} - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$log_2(n+1)$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(2^{k + 1})$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$k + 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p>Thus, the inductive hypothesis is <strong>true</strong> for height $k + 1$ and, hence (by induction), <strong>true</strong> for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .</p>\n<h5 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h5><ul>\n<li><a href=\"http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/\" target=\"_blank\" rel=\"external\">http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/</a></li>\n</ul>\n","excerpt":"","more":"<p>The height of a complete binary tree is $O(log n)$</p>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>The height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .</p>\n<h3 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Tree</th>\n<th style=\"text-align:center\">Nodes($n$)</th>\n<th style=\"text-align:center\">Height $log(n+1)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree1.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree2.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree3.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Proof\"><a href=\"#Proof\" class=\"headerlink\" title=\"Proof\"></a>Proof</h3><p>$n$ : Number of nodes in the tree.<br>$h$ : Height of the tree.</p>\n<h5 id=\"Precondition\"><a href=\"#Precondition\" class=\"headerlink\" title=\"Precondition\"></a>Precondition</h5><p>Since the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.<br>So $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub><br>And $n$<sub>left</sub> $=$ $n$<sub>right</sub><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub></p>\n<h5 id=\"Basis\"><a href=\"#Basis\" class=\"headerlink\" title=\"Basis\"></a>Basis</h5><p>$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1</p>\n<h5 id=\"Inductive-Hypothesis\"><a href=\"#Inductive-Hypothesis\" class=\"headerlink\" title=\"Inductive Hypothesis\"></a>Inductive Hypothesis</h5><p>Assume that the theorem is <strong>true</strong> for heights &lt;= $k$ .</p>\n<h5 id=\"Inductive-Step\"><a href=\"#Inductive-Step\" class=\"headerlink\" title=\"Inductive Step\"></a>Inductive Step</h5><p>Prove that the inductive hypothhesis is <strong>true</strong> for height $k + 1$</p>\n<p>Let $h$ as the height of the Complete Binary Tree with $n$ nodes,<br>and let $h = k + 1$ .</p>\n<p>So $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, </p>\n<p>so $k = log_2(n$<sub>left</sub> $+$ $1)$ ——— <em>by the inductive hypothesis</em></p>\n<p>Note that the theorem is <strong>true</strong> (by the inductive hypothesis) of the subtrees of the root, since they have height $k$</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + n$<sub>left</sub> $+$ $n$<sub>right</sub></td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2n$<sub>left</sub></td>\n<td style=\"text-align:right\"><em>since the tree is complete</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>BUT</strong></td>\n<td style=\"text-align:right\">$k$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(n$<sub>left</sub> $+$ $1)$</td>\n<td style=\"text-align:right\"><em>by the inductive hypothesis</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>SO</strong></td>\n<td style=\"text-align:right\">$n$<sub>left</sub></td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^k - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>THEN</strong></td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2(2^k - 1)$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^{k + 1} - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$log_2(n+1)$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(2^{k + 1})$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$k + 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p>Thus, the inductive hypothesis is <strong>true</strong> for height $k + 1$ and, hence (by induction), <strong>true</strong> for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .</p>\n<h5 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h5><ul>\n<li><a href=\"http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/\">http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/</a></li>\n</ul>\n"},{"title":"Red-Black Tree Deletion","date":"2016-11-29T20:29:09.000Z","_content":"\n<a name=\"Properties\"></a>\n# Red-Black Tree Properties #\n1. Every node is colored with either **RED** or **BLACK**;\n2. All leaf (NULL Pointer) nodes are colored with **BLACK**; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored **BLACK**._\n3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**). We call this number the **Black-Height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a **RED** node must be **BLACK** nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always **BLACK**;\n\n\n# Deletion #\n\nThe delete operation is similar in feel to the insert operation, but more complicated.\n\nTo delete a node from a **Red-Black Tree**, first do a **BST** **Deletion** to delete the node from the **Red-Black Tree**, then via **Rotation** and **Recolor** operations to restore the tree to meet all of the **Red-Black Tree** properties again.\n\n# Detail steps #\n\n| **Step 1** | **Delete the node via BST Deletion** |\n| :---       | :---                                 |\n| **Case 1** | The deleting node is a leaf node, then just delete it.  **Black-Height change is possible!!!**|\n| **Case 2** | The deleting node has 1 subtree, then just \"link past\" the node. **Black-Height change is possible!!!** |\n| &nbsp;     | i.e. connect the parent of the node directly to the node's only subtree. |\n| &nbsp;     | This always works, whether the one subtree is on the left or on the right. |\n| **Case 3** | The deleting node has 2 subtree, then follow the below 3 steps:  |\n| &nbsp;     | &nbsp;&nbsp; **3.1** First find the successor of this node. |\n| &nbsp;     | &nbsp;&nbsp; **3.2** Then copy the value of the successor to this node. |\n| &nbsp;     | &nbsp;&nbsp; The idea is move the value from the successor to the deleting node, then delete the successor.|\n| &nbsp;     | &nbsp;&nbsp; Now considering the successor, **it's impossible that the successor has two non-empty child nodes!** |\n| &nbsp;     | &nbsp;&nbsp; so either the successor is a leaf node so process as the **Case 1**; |\n| &nbsp;     | &nbsp;&nbsp; or the successor only has 1 child node so process as the **Case 2**. |\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **Deletion Cases** | &nbsp; |\n| :---               | :---                                 |\n| The deleting node is a **RED** leaf, then just delete it. | {% asset_img rbt_deletion_case_1.png \"Figure 1\" \"Red-Black Tree Delete RED leaf\" %} |\n| The deleting node is a **BLACK** leaf, **Black-Height** changed!!!<br/>We need the step 2. | {% asset_img rbt_deletion_case_2.png \"Figure 2\" \"Red-Black Tree Delete BLACK leaf\" %} |\n| The deleting node is a **BLACK** node with 1 **RED** child,<br/>link past the node, then recolor the **RED** child to **BLACK** to keep the **Black-Height**. | {% asset_img rbt_deletion_case_3.png \"Figure 3\" \"Red-Black Tree Delete RED non-empty node\" %} |\n\n\n**The deleting node is a node with 2 child nodes,it will be a little complexity.** \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n| **_Properties again_**            | &nbsp; | &nbsp;                                                         |\n| :---              | :---:  | :---                                                                           |\n| **_Question_**:   | &nbsp; | Which **Red-Black Tree** [properties](#Properties) does the above case break?  |\n| 1. Every node is colored with either **RED** or **BLACK**                                  | &nbsp; | We don't break this because the new inserted node is colored as **RED**;     | \n| 2. All leaf (NULL Pointer) nodes are colored with **BLACK**                                | &nbsp; | We don't break this because the new inserted node is a nonempty node, it won't impact the leaf nodes which are all nil(NULL Pointer) nodes; |\n| 3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes  | &nbsp; | We don't break this because the new inserted node is colored as **RED**, so the count of **BLACK** nodes should keep same as before; |\n| 4. Both children of a **RED** node must be **BLACK** nodes                                 | &nbsp; | **We might break property #4!!!** |\n| 5. The root is always **BLACK**                                                            | &nbsp; | We don't break this because BST insertion will only insert the new node to the leaf nodes, the root node won't be impacted; |\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n**After step 1, delete one node via BST deletion, the new tree might break Red-Black Tree [properties](#Properties) 3,4,5, it's what we want to resolve at step 2.**\n\n| **Step 2** | **Rotation or Recolor to restore the tree to meet all of the Red-Black Tree [properties](#Properties) again.** | \n| :---       | :---                                 |\n| &nbsp;     | Because after step 1, the new tree might not meet all of the **Red-Black Tree** [properties](#Properties). |\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n**Pseudo code --- RB-DELETE**\n```\nRB-DELETE(T, z)\nif left[z] = nil[T] or right[z] = nil[T]         \n   then y ← z                                  // if \"z\" has unique child, then assign \"z\" to \"y\"\n   else y ← TREE-SUCCESSOR(z)                  // otherwise assign \"z\"'s successor to \"y\" \n\nif left[y] ≠ nil[T]\n   then x ← left[y]                            // if \"y\"'s left child is not NIL, then assign it to \"x\"\n   else x ← right[y]                           // otherwise assign \"y\"'s right child to \"x\" (because \"y\" is from \"z\", it must have at least one child)\n\np[x] ← p[y]                                    // assign \"y\"'s parent to \"x\"'s parent\nif p[y] = nil[T]                               \n   then root[T] ← x                            // Case 1: if \"y\"'s parent is NIL, then set \"root\" as \"x\"\n   else if y = left[p[y]]                    \n           then left[p[y]] ← x                 // Case 2: if \"y\" is the left child of \"y\"'s parent, then set \"x\" as the left child of \"y\"'s parent\n           else right[p[y]] ← x                // Case 3: if \"y\" is the right child of \"y\"'s parent, then set \"x\" as the right child of \"y\"'s parent\nif y ≠ z                                    \n   then key[z] ← key[y]                        // if \"y\" not equal to \"z\", then only copy \"y\"'s satellite data to \"z\", don't copy \"y\"'s color!\n        copy y's satellite data into z         \n\t\t\nif color[y] = BLACK                            \n   then RB-DELETE-FIXUP(T, x)                  // if \"y\" is BLACK, then call RE-DELETE-FIXUP function\nreturn y\n\n```\n\n{% asset_img rbt_deletion_case_4.png \"Figure 4\" \"Red-Black Tree Deletion\" %} \n\nSo according to the above image _Figure 4_, let's say the deleting node is **z**, then \n\nIf **z**'s children is less than 2, then just need to point **y** to **z**;\nIf **y** is **RED**, then just delete it, because it won't break **Red-Black Tree**'s [properties](#Properties);\nIf **y** is **BLACK**, then we have to call the $fixup$ function, also just delete it, because it won't break **Red-Black Tree**'s [properties](#Properties); \n\nIf **z** has two child nodes, then find **z**'s successor **y**, use **y** to replace **z**, recolor **y** as **z**'s color, so it won't break **Red-Black Tree**'s [properties](#Properties);\n\nIn order to facilitate analysis, we assume that \n\n\n\n\n\n\n\n删除操作同二叉树的删除操作也是类似，也是同样分为：少于两个子结点、有两个子结点的情况，红色标注不同；\n1.z的子节点数少于两个：（令y指向z的位置）如果结点y颜色为红色直接删除，因为不会破坏红黑的性质；若为y黑色，调用颜色修复函数,并令其子树x代替z的位置，并把颜色也改变成z的颜色。\n2.z的子节点数有两个：找到z的后继y,用y代替z的位置，并把y的颜色换成z的颜色，这样不会破坏红黑的性质。但是如果y在之前的位置是黑色，现在由于转移走了，y的右子树x代替了y的位置，此时破坏了这个支树的红黑性质，少了一个黑色结点，需要调用颜色修复函数；\n\n当删除一个黑色节点D时，把D的黑色“下推”至其子节点C，也就是说C除了本身的颜色外多了一重额外的黑色，然后不断把这重额外的黑色沿树上移，直到碰到一个红色节点，把其变为黑色以保证路径上黑色节点数目不变，或者移到树的根部，这样所有路径上的黑色节点数目都减一，保持相等。上移过程中可能需要旋转和修改一些节点的颜色，以保证路径上黑色节点数目不变。\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nThe C++ code for **Red-Black Tree RB_Transplant** is below:\n\n```C++\nvoid RB_Transplant(Node **T,Node * u,Node * v) {  //It's like copy u to v\n  if (u->p == T_NIL)  \n    *T = v;  \n  else if (u == u->p->left)  \n    u->p->left = v;  \n  else  \n    u->p->right = v;  \n  v->p = u->p;            //Mandatory step even v's value is T_NIL, it's for the color fix up needed\n}  \n```\n\nThe C++ code for **Red-Black Tree RB_Delete** is below:\n\n```C++\nNode * RB_Delete(Node *T ,Node *z) {  //Same as BST Deletion, the only difference is check y's color\n  Node * x = NULL;  \n  Node * y = z;                             //assign z to y\n  enum colors y_original_color = y->color;  //save z's original color before deleting\n  if (z->left == T_NIL) {                   //if z doesn't have left child\n    x = z->right;  \n    RB_Transplant(&T,z,z->right);  \n  } else if (z->right == T_NIL) {           //if z doesn't have right child\n    x = z->left;  \n    RB_Transplant(&T,z,z->left);  \n  } else {                                  //if z has two child nodes\n    y = Tree_Minimum(z->right);             //find z's successor   \n    y_original_color = y->color;            //save y's original color\n    x = y->right;  \n    if (y->p == z) {                        //if y's parent is z\n      x->p = y;  \n    } else {  \n        RB_Transplant(&T,y,y->right);       //if y's parent is not z, replace y with y's right child\n        y->right = z->right;  \n        y->right->p = y;  \n    }  \n      \n    RB_Transplant(&T,z,y);                  //replace z with y, no matter if y's value is T_NIL\n    y->left = z->left;  \n    y->left->p = y;  \n    y->color = z->color;                    //change y's color to z's color\n  }  \n  \n  if (y_original_color == black)            //if y's color is BLACK, then fix up the tree\n    RB_Delete_Fixup(T,x); \n\t\n  return T;  \n}  \n```\n\nHere let's take about the function **RB_Delete_Fixup(T,x)**. Please notice that the input parameter is **x**, it becauses that either **y** is deleted or transplanted, **x** replaces **y**'s position.\nIf **x** is **RED**, then recolor **x** as **BLACK** will fix up the tree.\nIf **x** is **BLACK**, then:","source":"_posts/2016-11-29-Red-Black-Tree-Deletion.md","raw":"---\ntitle: Red-Black Tree Deletion\ndate: 2016-11-29 15:29:09\ntags:\n- Algorithm\n- Tree\n---\n\n<a name=\"Properties\"></a>\n# Red-Black Tree Properties #\n1. Every node is colored with either **RED** or **BLACK**;\n2. All leaf (NULL Pointer) nodes are colored with **BLACK**; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored **BLACK**._\n3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**). We call this number the **Black-Height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a **RED** node must be **BLACK** nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always **BLACK**;\n\n\n# Deletion #\n\nThe delete operation is similar in feel to the insert operation, but more complicated.\n\nTo delete a node from a **Red-Black Tree**, first do a **BST** **Deletion** to delete the node from the **Red-Black Tree**, then via **Rotation** and **Recolor** operations to restore the tree to meet all of the **Red-Black Tree** properties again.\n\n# Detail steps #\n\n| **Step 1** | **Delete the node via BST Deletion** |\n| :---       | :---                                 |\n| **Case 1** | The deleting node is a leaf node, then just delete it.  **Black-Height change is possible!!!**|\n| **Case 2** | The deleting node has 1 subtree, then just \"link past\" the node. **Black-Height change is possible!!!** |\n| &nbsp;     | i.e. connect the parent of the node directly to the node's only subtree. |\n| &nbsp;     | This always works, whether the one subtree is on the left or on the right. |\n| **Case 3** | The deleting node has 2 subtree, then follow the below 3 steps:  |\n| &nbsp;     | &nbsp;&nbsp; **3.1** First find the successor of this node. |\n| &nbsp;     | &nbsp;&nbsp; **3.2** Then copy the value of the successor to this node. |\n| &nbsp;     | &nbsp;&nbsp; The idea is move the value from the successor to the deleting node, then delete the successor.|\n| &nbsp;     | &nbsp;&nbsp; Now considering the successor, **it's impossible that the successor has two non-empty child nodes!** |\n| &nbsp;     | &nbsp;&nbsp; so either the successor is a leaf node so process as the **Case 1**; |\n| &nbsp;     | &nbsp;&nbsp; or the successor only has 1 child node so process as the **Case 2**. |\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **Deletion Cases** | &nbsp; |\n| :---               | :---                                 |\n| The deleting node is a **RED** leaf, then just delete it. | {% asset_img rbt_deletion_case_1.png \"Figure 1\" \"Red-Black Tree Delete RED leaf\" %} |\n| The deleting node is a **BLACK** leaf, **Black-Height** changed!!!<br/>We need the step 2. | {% asset_img rbt_deletion_case_2.png \"Figure 2\" \"Red-Black Tree Delete BLACK leaf\" %} |\n| The deleting node is a **BLACK** node with 1 **RED** child,<br/>link past the node, then recolor the **RED** child to **BLACK** to keep the **Black-Height**. | {% asset_img rbt_deletion_case_3.png \"Figure 3\" \"Red-Black Tree Delete RED non-empty node\" %} |\n\n\n**The deleting node is a node with 2 child nodes,it will be a little complexity.** \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n| **_Properties again_**            | &nbsp; | &nbsp;                                                         |\n| :---              | :---:  | :---                                                                           |\n| **_Question_**:   | &nbsp; | Which **Red-Black Tree** [properties](#Properties) does the above case break?  |\n| 1. Every node is colored with either **RED** or **BLACK**                                  | &nbsp; | We don't break this because the new inserted node is colored as **RED**;     | \n| 2. All leaf (NULL Pointer) nodes are colored with **BLACK**                                | &nbsp; | We don't break this because the new inserted node is a nonempty node, it won't impact the leaf nodes which are all nil(NULL Pointer) nodes; |\n| 3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes  | &nbsp; | We don't break this because the new inserted node is colored as **RED**, so the count of **BLACK** nodes should keep same as before; |\n| 4. Both children of a **RED** node must be **BLACK** nodes                                 | &nbsp; | **We might break property #4!!!** |\n| 5. The root is always **BLACK**                                                            | &nbsp; | We don't break this because BST insertion will only insert the new node to the leaf nodes, the root node won't be impacted; |\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n**After step 1, delete one node via BST deletion, the new tree might break Red-Black Tree [properties](#Properties) 3,4,5, it's what we want to resolve at step 2.**\n\n| **Step 2** | **Rotation or Recolor to restore the tree to meet all of the Red-Black Tree [properties](#Properties) again.** | \n| :---       | :---                                 |\n| &nbsp;     | Because after step 1, the new tree might not meet all of the **Red-Black Tree** [properties](#Properties). |\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n**Pseudo code --- RB-DELETE**\n```\nRB-DELETE(T, z)\nif left[z] = nil[T] or right[z] = nil[T]         \n   then y ← z                                  // if \"z\" has unique child, then assign \"z\" to \"y\"\n   else y ← TREE-SUCCESSOR(z)                  // otherwise assign \"z\"'s successor to \"y\" \n\nif left[y] ≠ nil[T]\n   then x ← left[y]                            // if \"y\"'s left child is not NIL, then assign it to \"x\"\n   else x ← right[y]                           // otherwise assign \"y\"'s right child to \"x\" (because \"y\" is from \"z\", it must have at least one child)\n\np[x] ← p[y]                                    // assign \"y\"'s parent to \"x\"'s parent\nif p[y] = nil[T]                               \n   then root[T] ← x                            // Case 1: if \"y\"'s parent is NIL, then set \"root\" as \"x\"\n   else if y = left[p[y]]                    \n           then left[p[y]] ← x                 // Case 2: if \"y\" is the left child of \"y\"'s parent, then set \"x\" as the left child of \"y\"'s parent\n           else right[p[y]] ← x                // Case 3: if \"y\" is the right child of \"y\"'s parent, then set \"x\" as the right child of \"y\"'s parent\nif y ≠ z                                    \n   then key[z] ← key[y]                        // if \"y\" not equal to \"z\", then only copy \"y\"'s satellite data to \"z\", don't copy \"y\"'s color!\n        copy y's satellite data into z         \n\t\t\nif color[y] = BLACK                            \n   then RB-DELETE-FIXUP(T, x)                  // if \"y\" is BLACK, then call RE-DELETE-FIXUP function\nreturn y\n\n```\n\n{% asset_img rbt_deletion_case_4.png \"Figure 4\" \"Red-Black Tree Deletion\" %} \n\nSo according to the above image _Figure 4_, let's say the deleting node is **z**, then \n\nIf **z**'s children is less than 2, then just need to point **y** to **z**;\nIf **y** is **RED**, then just delete it, because it won't break **Red-Black Tree**'s [properties](#Properties);\nIf **y** is **BLACK**, then we have to call the $fixup$ function, also just delete it, because it won't break **Red-Black Tree**'s [properties](#Properties); \n\nIf **z** has two child nodes, then find **z**'s successor **y**, use **y** to replace **z**, recolor **y** as **z**'s color, so it won't break **Red-Black Tree**'s [properties](#Properties);\n\nIn order to facilitate analysis, we assume that \n\n\n\n\n\n\n\n删除操作同二叉树的删除操作也是类似，也是同样分为：少于两个子结点、有两个子结点的情况，红色标注不同；\n1.z的子节点数少于两个：（令y指向z的位置）如果结点y颜色为红色直接删除，因为不会破坏红黑的性质；若为y黑色，调用颜色修复函数,并令其子树x代替z的位置，并把颜色也改变成z的颜色。\n2.z的子节点数有两个：找到z的后继y,用y代替z的位置，并把y的颜色换成z的颜色，这样不会破坏红黑的性质。但是如果y在之前的位置是黑色，现在由于转移走了，y的右子树x代替了y的位置，此时破坏了这个支树的红黑性质，少了一个黑色结点，需要调用颜色修复函数；\n\n当删除一个黑色节点D时，把D的黑色“下推”至其子节点C，也就是说C除了本身的颜色外多了一重额外的黑色，然后不断把这重额外的黑色沿树上移，直到碰到一个红色节点，把其变为黑色以保证路径上黑色节点数目不变，或者移到树的根部，这样所有路径上的黑色节点数目都减一，保持相等。上移过程中可能需要旋转和修改一些节点的颜色，以保证路径上黑色节点数目不变。\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nThe C++ code for **Red-Black Tree RB_Transplant** is below:\n\n```C++\nvoid RB_Transplant(Node **T,Node * u,Node * v) {  //It's like copy u to v\n  if (u->p == T_NIL)  \n    *T = v;  \n  else if (u == u->p->left)  \n    u->p->left = v;  \n  else  \n    u->p->right = v;  \n  v->p = u->p;            //Mandatory step even v's value is T_NIL, it's for the color fix up needed\n}  \n```\n\nThe C++ code for **Red-Black Tree RB_Delete** is below:\n\n```C++\nNode * RB_Delete(Node *T ,Node *z) {  //Same as BST Deletion, the only difference is check y's color\n  Node * x = NULL;  \n  Node * y = z;                             //assign z to y\n  enum colors y_original_color = y->color;  //save z's original color before deleting\n  if (z->left == T_NIL) {                   //if z doesn't have left child\n    x = z->right;  \n    RB_Transplant(&T,z,z->right);  \n  } else if (z->right == T_NIL) {           //if z doesn't have right child\n    x = z->left;  \n    RB_Transplant(&T,z,z->left);  \n  } else {                                  //if z has two child nodes\n    y = Tree_Minimum(z->right);             //find z's successor   \n    y_original_color = y->color;            //save y's original color\n    x = y->right;  \n    if (y->p == z) {                        //if y's parent is z\n      x->p = y;  \n    } else {  \n        RB_Transplant(&T,y,y->right);       //if y's parent is not z, replace y with y's right child\n        y->right = z->right;  \n        y->right->p = y;  \n    }  \n      \n    RB_Transplant(&T,z,y);                  //replace z with y, no matter if y's value is T_NIL\n    y->left = z->left;  \n    y->left->p = y;  \n    y->color = z->color;                    //change y's color to z's color\n  }  \n  \n  if (y_original_color == black)            //if y's color is BLACK, then fix up the tree\n    RB_Delete_Fixup(T,x); \n\t\n  return T;  \n}  \n```\n\nHere let's take about the function **RB_Delete_Fixup(T,x)**. Please notice that the input parameter is **x**, it becauses that either **y** is deleted or transplanted, **x** replaces **y**'s position.\nIf **x** is **RED**, then recolor **x** as **BLACK** will fix up the tree.\nIf **x** is **BLACK**, then:","slug":"Red-Black-Tree-Deletion","published":1,"updated":"2016-12-02T20:10:07.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xdp0009mclshjf9f7qh","content":"<p><a name=\"Properties\"></a></p>\n<h1 id=\"Red-Black-Tree-Properties\"><a href=\"#Red-Black-Tree-Properties\" class=\"headerlink\" title=\"Red-Black Tree Properties\"></a>Red-Black Tree Properties</h1><ol>\n<li>Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong>;</li>\n<li>All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong>;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored <strong>BLACK</strong>.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>Black-Height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always <strong>BLACK</strong>;</li>\n</ol>\n<h1 id=\"Deletion\"><a href=\"#Deletion\" class=\"headerlink\" title=\"Deletion\"></a>Deletion</h1><p>The delete operation is similar in feel to the insert operation, but more complicated.</p>\n<p>To delete a node from a <strong>Red-Black Tree</strong>, first do a <strong>BST</strong> <strong>Deletion</strong> to delete the node from the <strong>Red-Black Tree</strong>, then via <strong>Rotation</strong> and <strong>Recolor</strong> operations to restore the tree to meet all of the <strong>Red-Black Tree</strong> properties again.</p>\n<h1 id=\"Detail-steps\"><a href=\"#Detail-steps\" class=\"headerlink\" title=\"Detail steps\"></a>Detail steps</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Step 1</strong></th>\n<th style=\"text-align:left\"><strong>Delete the node via BST Deletion</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>Case 1</strong></td>\n<td style=\"text-align:left\">The deleting node is a leaf node, then just delete it.  <strong>Black-Height change is possible!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2</strong></td>\n<td style=\"text-align:left\">The deleting node has 1 subtree, then just “link past” the node. <strong>Black-Height change is possible!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">i.e. connect the parent of the node directly to the node’s only subtree.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">This always works, whether the one subtree is on the left or on the right.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 3</strong></td>\n<td style=\"text-align:left\">The deleting node has 2 subtree, then follow the below 3 steps:</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; <strong>3.1</strong> First find the successor of this node.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; <strong>3.2</strong> Then copy the value of the successor to this node.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; The idea is move the value from the successor to the deleting node, then delete the successor.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; Now considering the successor, <strong>it’s impossible that the successor has two non-empty child nodes!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; so either the successor is a leaf node so process as the <strong>Case 1</strong>;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; or the successor only has 1 child node so process as the <strong>Case 2</strong>.</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Deletion Cases</strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">The deleting node is a <strong>RED</strong> leaf, then just delete it.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_1.png\" alt=\"Figure 1 Red-Black Tree Delete RED leaf\" title=\"Figure 1 Red-Black Tree Delete RED leaf\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">The deleting node is a <strong>BLACK</strong> leaf, <strong>Black-Height</strong> changed!!!<br>We need the step 2.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_2.png\" alt=\"Figure 2 Red-Black Tree Delete BLACK leaf\" title=\"Figure 2 Red-Black Tree Delete BLACK leaf\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">The deleting node is a <strong>BLACK</strong> node with 1 <strong>RED</strong> child,<br>link past the node, then recolor the <strong>RED</strong> child to <strong>BLACK</strong> to keep the <strong>Black-Height</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_3.png\" alt=\"Figure 3 Red-Black Tree Delete RED non-empty node\" title=\"Figure 3 Red-Black Tree Delete RED non-empty node\"></td>\n</tr>\n</tbody>\n</table>\n<p><strong>The deleting node is a node with 2 child nodes,it will be a little complexity.</strong> </p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong><em>Properties again</em></strong></th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><em>Question</em></strong>:</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">Which <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a> does the above case break?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1. Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong>;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2. All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is a nonempty node, it won’t impact the leaf nodes which are all nil(NULL Pointer) nodes;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3. Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong>, so the count of <strong>BLACK</strong> nodes should keep same as before;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4. Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\"><strong>We might break property #4!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5. The root is always <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because BST insertion will only insert the new node to the leaf nodes, the root node won’t be impacted;</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>After step 1, delete one node via BST deletion, the new tree might break Red-Black Tree <a href=\"#Properties\">properties</a> 3,4,5, it’s what we want to resolve at step 2.</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Step 2</strong></th>\n<th style=\"text-align:left\"><strong>Rotation or Recolor to restore the tree to meet all of the Red-Black Tree <a href=\"#Properties\">properties</a> again.</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">Because after step 1, the new tree might not meet all of the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a>.</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>Pseudo code — RB-DELETE</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RB-DELETE(T, z)</div><div class=\"line\">if left[z] = nil[T] or right[z] = nil[T]         </div><div class=\"line\">   then y ← z                                  // if &quot;z&quot; has unique child, then assign &quot;z&quot; to &quot;y&quot;</div><div class=\"line\">   else y ← TREE-SUCCESSOR(z)                  // otherwise assign &quot;z&quot;&apos;s successor to &quot;y&quot; </div><div class=\"line\"></div><div class=\"line\">if left[y] ≠ nil[T]</div><div class=\"line\">   then x ← left[y]                            // if &quot;y&quot;&apos;s left child is not NIL, then assign it to &quot;x&quot;</div><div class=\"line\">   else x ← right[y]                           // otherwise assign &quot;y&quot;&apos;s right child to &quot;x&quot; (because &quot;y&quot; is from &quot;z&quot;, it must have at least one child)</div><div class=\"line\"></div><div class=\"line\">p[x] ← p[y]                                    // assign &quot;y&quot;&apos;s parent to &quot;x&quot;&apos;s parent</div><div class=\"line\">if p[y] = nil[T]                               </div><div class=\"line\">   then root[T] ← x                            // Case 1: if &quot;y&quot;&apos;s parent is NIL, then set &quot;root&quot; as &quot;x&quot;</div><div class=\"line\">   else if y = left[p[y]]                    </div><div class=\"line\">           then left[p[y]] ← x                 // Case 2: if &quot;y&quot; is the left child of &quot;y&quot;&apos;s parent, then set &quot;x&quot; as the left child of &quot;y&quot;&apos;s parent</div><div class=\"line\">           else right[p[y]] ← x                // Case 3: if &quot;y&quot; is the right child of &quot;y&quot;&apos;s parent, then set &quot;x&quot; as the right child of &quot;y&quot;&apos;s parent</div><div class=\"line\">if y ≠ z                                    </div><div class=\"line\">   then key[z] ← key[y]                        // if &quot;y&quot; not equal to &quot;z&quot;, then only copy &quot;y&quot;&apos;s satellite data to &quot;z&quot;, don&apos;t copy &quot;y&quot;&apos;s color!</div><div class=\"line\">        copy y&apos;s satellite data into z         </div><div class=\"line\">\t\t</div><div class=\"line\">if color[y] = BLACK                            </div><div class=\"line\">   then RB-DELETE-FIXUP(T, x)                  // if &quot;y&quot; is BLACK, then call RE-DELETE-FIXUP function</div><div class=\"line\">return y</div></pre></td></tr></table></figure></p>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_4.png\" alt=\"Figure 4 Red-Black Tree Deletion\" title=\"Figure 4 Red-Black Tree Deletion\"> \n<p>So according to the above image <em>Figure 4</em>, let’s say the deleting node is <strong>z</strong>, then </p>\n<p>If <strong>z</strong>‘s children is less than 2, then just need to point <strong>y</strong> to <strong>z</strong>;<br>If <strong>y</strong> is <strong>RED</strong>, then just delete it, because it won’t break <strong>Red-Black Tree</strong>‘s <a href=\"#Properties\">properties</a>;<br>If <strong>y</strong> is <strong>BLACK</strong>, then we have to call the $fixup$ function, also just delete it, because it won’t break <strong>Red-Black Tree</strong>‘s <a href=\"#Properties\">properties</a>; </p>\n<p>If <strong>z</strong> has two child nodes, then find <strong>z</strong>‘s successor <strong>y</strong>, use <strong>y</strong> to replace <strong>z</strong>, recolor <strong>y</strong> as <strong>z</strong>‘s color, so it won’t break <strong>Red-Black Tree</strong>‘s <a href=\"#Properties\">properties</a>;</p>\n<p>In order to facilitate analysis, we assume that </p>\n<p>删除操作同二叉树的删除操作也是类似，也是同样分为：少于两个子结点、有两个子结点的情况，红色标注不同；<br>1.z的子节点数少于两个：（令y指向z的位置）如果结点y颜色为红色直接删除，因为不会破坏红黑的性质；若为y黑色，调用颜色修复函数,并令其子树x代替z的位置，并把颜色也改变成z的颜色。<br>2.z的子节点数有两个：找到z的后继y,用y代替z的位置，并把y的颜色换成z的颜色，这样不会破坏红黑的性质。但是如果y在之前的位置是黑色，现在由于转移走了，y的右子树x代替了y的位置，此时破坏了这个支树的红黑性质，少了一个黑色结点，需要调用颜色修复函数；</p>\n<p>当删除一个黑色节点D时，把D的黑色“下推”至其子节点C，也就是说C除了本身的颜色外多了一重额外的黑色，然后不断把这重额外的黑色沿树上移，直到碰到一个红色节点，把其变为黑色以保证路径上黑色节点数目不变，或者移到树的根部，这样所有路径上的黑色节点数目都减一，保持相等。上移过程中可能需要旋转和修改一些节点的颜色，以保证路径上黑色节点数目不变。</p>\n<hr>\n<p>The C++ code for <strong>Red-Black Tree RB_Transplant</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RB_Transplant</span><span class=\"params\">(Node **T,Node * u,Node * v)</span> </span>&#123;  <span class=\"comment\">//It's like copy u to v</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (u-&gt;p == T_NIL)  </div><div class=\"line\">    *T = v;  </div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (u == u-&gt;p-&gt;left)  </div><div class=\"line\">    u-&gt;p-&gt;left = v;  </div><div class=\"line\">  <span class=\"keyword\">else</span>  </div><div class=\"line\">    u-&gt;p-&gt;right = v;  </div><div class=\"line\">  v-&gt;p = u-&gt;p;            <span class=\"comment\">//Mandatory step even v's value is T_NIL, it's for the color fix up needed</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The C++ code for <strong>Red-Black Tree RB_Delete</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Node * <span class=\"title\">RB_Delete</span><span class=\"params\">(Node *T ,Node *z)</span> </span>&#123;  <span class=\"comment\">//Same as BST Deletion, the only difference is check y's color</span></div><div class=\"line\">  Node * x = <span class=\"literal\">NULL</span>;  </div><div class=\"line\">  Node * y = z;                             <span class=\"comment\">//assign z to y</span></div><div class=\"line\">  <span class=\"keyword\">enum</span> colors y_original_color = y-&gt;color;  <span class=\"comment\">//save z's original color before deleting</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (z-&gt;left == T_NIL) &#123;                   <span class=\"comment\">//if z doesn't have left child</span></div><div class=\"line\">    x = z-&gt;right;  </div><div class=\"line\">    RB_Transplant(&amp;T,z,z-&gt;right);  </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z-&gt;right == T_NIL) &#123;           <span class=\"comment\">//if z doesn't have right child</span></div><div class=\"line\">    x = z-&gt;left;  </div><div class=\"line\">    RB_Transplant(&amp;T,z,z-&gt;left);  </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                                  <span class=\"comment\">//if z has two child nodes</span></div><div class=\"line\">    y = Tree_Minimum(z-&gt;right);             <span class=\"comment\">//find z's successor   </span></div><div class=\"line\">    y_original_color = y-&gt;color;            <span class=\"comment\">//save y's original color</span></div><div class=\"line\">    x = y-&gt;right;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (y-&gt;p == z) &#123;                        <span class=\"comment\">//if y's parent is z</span></div><div class=\"line\">      x-&gt;p = y;  </div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  </div><div class=\"line\">        RB_Transplant(&amp;T,y,y-&gt;right);       <span class=\"comment\">//if y's parent is not z, replace y with y's right child</span></div><div class=\"line\">        y-&gt;right = z-&gt;right;  </div><div class=\"line\">        y-&gt;right-&gt;p = y;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    RB_Transplant(&amp;T,z,y);                  <span class=\"comment\">//replace z with y, no matter if y's value is T_NIL</span></div><div class=\"line\">    y-&gt;left = z-&gt;left;  </div><div class=\"line\">    y-&gt;left-&gt;p = y;  </div><div class=\"line\">    y-&gt;color = z-&gt;color;                    <span class=\"comment\">//change y's color to z's color</span></div><div class=\"line\">  &#125;  </div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">if</span> (y_original_color == black)            <span class=\"comment\">//if y's color is BLACK, then fix up the tree</span></div><div class=\"line\">    RB_Delete_Fixup(T,x); </div><div class=\"line\">\t</div><div class=\"line\">  <span class=\"keyword\">return</span> T;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Here let’s take about the function <strong>RB_Delete_Fixup(T,x)</strong>. Please notice that the input parameter is <strong>x</strong>, it becauses that either <strong>y</strong> is deleted or transplanted, <strong>x</strong> replaces <strong>y</strong>‘s position.<br>If <strong>x</strong> is <strong>RED</strong>, then recolor <strong>x</strong> as <strong>BLACK</strong> will fix up the tree.<br>If <strong>x</strong> is <strong>BLACK</strong>, then:</p>\n","excerpt":"","more":"<p><a name=\"Properties\"></a></p>\n<h1 id=\"Red-Black-Tree-Properties\"><a href=\"#Red-Black-Tree-Properties\" class=\"headerlink\" title=\"Red-Black Tree Properties\"></a>Red-Black Tree Properties</h1><ol>\n<li>Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong>;</li>\n<li>All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong>;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored <strong>BLACK</strong>.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>Black-Height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always <strong>BLACK</strong>;</li>\n</ol>\n<h1 id=\"Deletion\"><a href=\"#Deletion\" class=\"headerlink\" title=\"Deletion\"></a>Deletion</h1><p>The delete operation is similar in feel to the insert operation, but more complicated.</p>\n<p>To delete a node from a <strong>Red-Black Tree</strong>, first do a <strong>BST</strong> <strong>Deletion</strong> to delete the node from the <strong>Red-Black Tree</strong>, then via <strong>Rotation</strong> and <strong>Recolor</strong> operations to restore the tree to meet all of the <strong>Red-Black Tree</strong> properties again.</p>\n<h1 id=\"Detail-steps\"><a href=\"#Detail-steps\" class=\"headerlink\" title=\"Detail steps\"></a>Detail steps</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Step 1</strong></th>\n<th style=\"text-align:left\"><strong>Delete the node via BST Deletion</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>Case 1</strong></td>\n<td style=\"text-align:left\">The deleting node is a leaf node, then just delete it.  <strong>Black-Height change is possible!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2</strong></td>\n<td style=\"text-align:left\">The deleting node has 1 subtree, then just “link past” the node. <strong>Black-Height change is possible!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">i.e. connect the parent of the node directly to the node’s only subtree.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">This always works, whether the one subtree is on the left or on the right.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 3</strong></td>\n<td style=\"text-align:left\">The deleting node has 2 subtree, then follow the below 3 steps:</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; <strong>3.1</strong> First find the successor of this node.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; <strong>3.2</strong> Then copy the value of the successor to this node.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; The idea is move the value from the successor to the deleting node, then delete the successor.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; Now considering the successor, <strong>it’s impossible that the successor has two non-empty child nodes!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; so either the successor is a leaf node so process as the <strong>Case 1</strong>;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp; or the successor only has 1 child node so process as the <strong>Case 2</strong>.</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Deletion Cases</strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">The deleting node is a <strong>RED</strong> leaf, then just delete it.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_1.png\" alt=\"Figure 1 Red-Black Tree Delete RED leaf\" title=\"Figure 1 Red-Black Tree Delete RED leaf\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">The deleting node is a <strong>BLACK</strong> leaf, <strong>Black-Height</strong> changed!!!<br/>We need the step 2.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_2.png\" alt=\"Figure 2 Red-Black Tree Delete BLACK leaf\" title=\"Figure 2 Red-Black Tree Delete BLACK leaf\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">The deleting node is a <strong>BLACK</strong> node with 1 <strong>RED</strong> child,<br/>link past the node, then recolor the <strong>RED</strong> child to <strong>BLACK</strong> to keep the <strong>Black-Height</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_3.png\" alt=\"Figure 3 Red-Black Tree Delete RED non-empty node\" title=\"Figure 3 Red-Black Tree Delete RED non-empty node\"></td>\n</tr>\n</tbody>\n</table>\n<p><strong>The deleting node is a node with 2 child nodes,it will be a little complexity.</strong> </p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong><em>Properties again</em></strong></th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><em>Question</em></strong>:</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">Which <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a> does the above case break?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1. Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong>;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2. All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is a nonempty node, it won’t impact the leaf nodes which are all nil(NULL Pointer) nodes;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3. Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong>, so the count of <strong>BLACK</strong> nodes should keep same as before;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4. Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\"><strong>We might break property #4!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5. The root is always <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because BST insertion will only insert the new node to the leaf nodes, the root node won’t be impacted;</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>After step 1, delete one node via BST deletion, the new tree might break Red-Black Tree <a href=\"#Properties\">properties</a> 3,4,5, it’s what we want to resolve at step 2.</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Step 2</strong></th>\n<th style=\"text-align:left\"><strong>Rotation or Recolor to restore the tree to meet all of the Red-Black Tree <a href=\"#Properties\">properties</a> again.</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">Because after step 1, the new tree might not meet all of the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a>.</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>Pseudo code — RB-DELETE</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">RB-DELETE(T, z)</div><div class=\"line\">if left[z] = nil[T] or right[z] = nil[T]         </div><div class=\"line\">   then y ← z                                  // if &quot;z&quot; has unique child, then assign &quot;z&quot; to &quot;y&quot;</div><div class=\"line\">   else y ← TREE-SUCCESSOR(z)                  // otherwise assign &quot;z&quot;&apos;s successor to &quot;y&quot; </div><div class=\"line\"></div><div class=\"line\">if left[y] ≠ nil[T]</div><div class=\"line\">   then x ← left[y]                            // if &quot;y&quot;&apos;s left child is not NIL, then assign it to &quot;x&quot;</div><div class=\"line\">   else x ← right[y]                           // otherwise assign &quot;y&quot;&apos;s right child to &quot;x&quot; (because &quot;y&quot; is from &quot;z&quot;, it must have at least one child)</div><div class=\"line\"></div><div class=\"line\">p[x] ← p[y]                                    // assign &quot;y&quot;&apos;s parent to &quot;x&quot;&apos;s parent</div><div class=\"line\">if p[y] = nil[T]                               </div><div class=\"line\">   then root[T] ← x                            // Case 1: if &quot;y&quot;&apos;s parent is NIL, then set &quot;root&quot; as &quot;x&quot;</div><div class=\"line\">   else if y = left[p[y]]                    </div><div class=\"line\">           then left[p[y]] ← x                 // Case 2: if &quot;y&quot; is the left child of &quot;y&quot;&apos;s parent, then set &quot;x&quot; as the left child of &quot;y&quot;&apos;s parent</div><div class=\"line\">           else right[p[y]] ← x                // Case 3: if &quot;y&quot; is the right child of &quot;y&quot;&apos;s parent, then set &quot;x&quot; as the right child of &quot;y&quot;&apos;s parent</div><div class=\"line\">if y ≠ z                                    </div><div class=\"line\">   then key[z] ← key[y]                        // if &quot;y&quot; not equal to &quot;z&quot;, then only copy &quot;y&quot;&apos;s satellite data to &quot;z&quot;, don&apos;t copy &quot;y&quot;&apos;s color!</div><div class=\"line\">        copy y&apos;s satellite data into z         </div><div class=\"line\">\t\t</div><div class=\"line\">if color[y] = BLACK                            </div><div class=\"line\">   then RB-DELETE-FIXUP(T, x)                  // if &quot;y&quot; is BLACK, then call RE-DELETE-FIXUP function</div><div class=\"line\">return y</div></pre></td></tr></table></figure></p>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Deletion/rbt_deletion_case_4.png\" alt=\"Figure 4 Red-Black Tree Deletion\" title=\"Figure 4 Red-Black Tree Deletion\"> \n<p>So according to the above image <em>Figure 4</em>, let’s say the deleting node is <strong>z</strong>, then </p>\n<p>If <strong>z</strong>‘s children is less than 2, then just need to point <strong>y</strong> to <strong>z</strong>;<br>If <strong>y</strong> is <strong>RED</strong>, then just delete it, because it won’t break <strong>Red-Black Tree</strong>‘s <a href=\"#Properties\">properties</a>;<br>If <strong>y</strong> is <strong>BLACK</strong>, then we have to call the $fixup$ function, also just delete it, because it won’t break <strong>Red-Black Tree</strong>‘s <a href=\"#Properties\">properties</a>; </p>\n<p>If <strong>z</strong> has two child nodes, then find <strong>z</strong>‘s successor <strong>y</strong>, use <strong>y</strong> to replace <strong>z</strong>, recolor <strong>y</strong> as <strong>z</strong>‘s color, so it won’t break <strong>Red-Black Tree</strong>‘s <a href=\"#Properties\">properties</a>;</p>\n<p>In order to facilitate analysis, we assume that </p>\n<p>删除操作同二叉树的删除操作也是类似，也是同样分为：少于两个子结点、有两个子结点的情况，红色标注不同；<br>1.z的子节点数少于两个：（令y指向z的位置）如果结点y颜色为红色直接删除，因为不会破坏红黑的性质；若为y黑色，调用颜色修复函数,并令其子树x代替z的位置，并把颜色也改变成z的颜色。<br>2.z的子节点数有两个：找到z的后继y,用y代替z的位置，并把y的颜色换成z的颜色，这样不会破坏红黑的性质。但是如果y在之前的位置是黑色，现在由于转移走了，y的右子树x代替了y的位置，此时破坏了这个支树的红黑性质，少了一个黑色结点，需要调用颜色修复函数；</p>\n<p>当删除一个黑色节点D时，把D的黑色“下推”至其子节点C，也就是说C除了本身的颜色外多了一重额外的黑色，然后不断把这重额外的黑色沿树上移，直到碰到一个红色节点，把其变为黑色以保证路径上黑色节点数目不变，或者移到树的根部，这样所有路径上的黑色节点数目都减一，保持相等。上移过程中可能需要旋转和修改一些节点的颜色，以保证路径上黑色节点数目不变。</p>\n<hr>\n<p>The C++ code for <strong>Red-Black Tree RB_Transplant</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">RB_Transplant</span><span class=\"params\">(Node **T,Node * u,Node * v)</span> </span>&#123;  <span class=\"comment\">//It's like copy u to v</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (u-&gt;p == T_NIL)  </div><div class=\"line\">    *T = v;  </div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (u == u-&gt;p-&gt;left)  </div><div class=\"line\">    u-&gt;p-&gt;left = v;  </div><div class=\"line\">  <span class=\"keyword\">else</span>  </div><div class=\"line\">    u-&gt;p-&gt;right = v;  </div><div class=\"line\">  v-&gt;p = u-&gt;p;            <span class=\"comment\">//Mandatory step even v's value is T_NIL, it's for the color fix up needed</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The C++ code for <strong>Red-Black Tree RB_Delete</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Node * <span class=\"title\">RB_Delete</span><span class=\"params\">(Node *T ,Node *z)</span> </span>&#123;  <span class=\"comment\">//Same as BST Deletion, the only difference is check y's color</span></div><div class=\"line\">  Node * x = <span class=\"literal\">NULL</span>;  </div><div class=\"line\">  Node * y = z;                             <span class=\"comment\">//assign z to y</span></div><div class=\"line\">  <span class=\"keyword\">enum</span> colors y_original_color = y-&gt;color;  <span class=\"comment\">//save z's original color before deleting</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (z-&gt;left == T_NIL) &#123;                   <span class=\"comment\">//if z doesn't have left child</span></div><div class=\"line\">    x = z-&gt;right;  </div><div class=\"line\">    RB_Transplant(&amp;T,z,z-&gt;right);  </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z-&gt;right == T_NIL) &#123;           <span class=\"comment\">//if z doesn't have right child</span></div><div class=\"line\">    x = z-&gt;left;  </div><div class=\"line\">    RB_Transplant(&amp;T,z,z-&gt;left);  </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                                  <span class=\"comment\">//if z has two child nodes</span></div><div class=\"line\">    y = Tree_Minimum(z-&gt;right);             <span class=\"comment\">//find z's successor   </span></div><div class=\"line\">    y_original_color = y-&gt;color;            <span class=\"comment\">//save y's original color</span></div><div class=\"line\">    x = y-&gt;right;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (y-&gt;p == z) &#123;                        <span class=\"comment\">//if y's parent is z</span></div><div class=\"line\">      x-&gt;p = y;  </div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  </div><div class=\"line\">        RB_Transplant(&amp;T,y,y-&gt;right);       <span class=\"comment\">//if y's parent is not z, replace y with y's right child</span></div><div class=\"line\">        y-&gt;right = z-&gt;right;  </div><div class=\"line\">        y-&gt;right-&gt;p = y;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    RB_Transplant(&amp;T,z,y);                  <span class=\"comment\">//replace z with y, no matter if y's value is T_NIL</span></div><div class=\"line\">    y-&gt;left = z-&gt;left;  </div><div class=\"line\">    y-&gt;left-&gt;p = y;  </div><div class=\"line\">    y-&gt;color = z-&gt;color;                    <span class=\"comment\">//change y's color to z's color</span></div><div class=\"line\">  &#125;  </div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">if</span> (y_original_color == black)            <span class=\"comment\">//if y's color is BLACK, then fix up the tree</span></div><div class=\"line\">    RB_Delete_Fixup(T,x); </div><div class=\"line\">\t</div><div class=\"line\">  <span class=\"keyword\">return</span> T;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Here let’s take about the function <strong>RB_Delete_Fixup(T,x)</strong>. Please notice that the input parameter is <strong>x</strong>, it becauses that either <strong>y</strong> is deleted or transplanted, <strong>x</strong> replaces <strong>y</strong>‘s position.<br>If <strong>x</strong> is <strong>RED</strong>, then recolor <strong>x</strong> as <strong>BLACK</strong> will fix up the tree.<br>If <strong>x</strong> is <strong>BLACK</strong>, then:</p>\n"},{"title":"Red-Black Tree Insertion","date":"2016-11-29T19:54:43.000Z","_content":"\n<a name=\"Properties\"></a>\n# Red-Black Tree Properties #\n1. Every node is colored with either **RED** or **BLACK**;\n2. All leaf (NULL Pointer) nodes are colored with **BLACK**; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored **BLACK**._\n3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**). We call this number the **Black-Height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a **RED** node must be **BLACK** nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always **BLACK**;\n\n# Insertion #\n\n| **An Example for Insertion**                                                                                                                                                             | &nbsp;                                           |\n| :---                                                                                                                                                                                     | ---:                                             |\n| **Color this tree**                                                                                                                                                                      | {% asset_img rbt_insertion_1.jpg \"Step 1\" \" \" %} | \n| **Insert 8**<br/>Where does it go?<br/>What color shoult it be?                                                                                                                          | {% asset_img rbt_insertion_2.jpg \"Step 2\" \" \" %} | \n| **Insert 8**<br/>Color the inserted node as **RED**                                                                                                                                      | {% asset_img rbt_insertion_3.jpg \"Step 3\" \" \" %} | \n| **Insert 11**<br/>Where does it go?<br/>What color shoult it be?<br/>Can't be **RED**!(break [property](#Properties) #4)<br/>Can't be **BLACK**!(break [property](#Properties) #3)       | {% asset_img rbt_insertion_4.jpg \"Step 4\" \" \" %} | \n| **Insert 11**<br/>Where does it go?<br/>Solution: recolor the tree                                                                                                                       | {% asset_img rbt_insertion_5.jpg \"Step 5\" \" \" %} | \n| **Insert 10**<br/>Where does it go?<br/>What color shoult it be?<br/><br/>**Answer**: no color! Tree is too imbalanced!<br/>Must change tree structure to allow recoloring<br/>**Goal**: Restructure tree in $O(log_2(n))$ time                                                                                      | {% asset_img rbt_insertion_6.jpg \"Step 6\" \" \" %}      | \n\n\nBased on the above example, the **Red-Black Tree Insertion operation** is to do a regular BST insertion, then do the operations (recolor or rotate) to make the new tree satisfy with all of the **Red-Black Tree** [properties](#Properties).\nA special case is required for an empty tree. If the tree is empty, replace it with a single **BLACK** node containing the inserted value. This ensures that the root property is satisfied.\n\nSo assume we are trying to insert one new node **x** to **T** (a nonempty **Red-Black Tree**)\n\n| **Steps**:  | &nbsp;                                                                                                       |\n| :---                  | :---                                                                                                         |\n| **1**:           | Use the BST insert algorithm to insert **x** to **T** (**_Note: every insertion take places at a leaf)_**    |\n| **2**:           | Color the node **x** **RED**                                                                                 |\n| **3**:           | Restore **Red-Black Tree** [properties](#Properties) by **recolor** or **rotate** operations (if necessary)  |\n\n\n| &nbsp;            | &nbsp;                                                            |\n| :---              | :---                                                              |\n| **_Question_**:   | At **Step 2**, why color the new inserted node **x** as **RED**?  |\n| **_Answer_**:     | Recall the **Red-Black Tree** [properties](#Properties), color the new inserted node **x** as **RED** won't violate the [property](#Properties) #3, so the **Black-Height** will be same as before the insertion |\n| &nbsp;            | which means the less cases we have to handle to keep maintaining the **Red-Black Tree** [properties](#Properties)                                                                                                |\n  \n\n\nBack to the step #6 in the example above, after insert **10** into the **Red-Black Tree**, first based on the regular BST insert algorithm to find the proper location, where is the left child of node **11**, then we should color the node **10** as **RED**, so now we get a tree like below:\n\n{% asset_img rbt_insertion_7.jpg \"Insert 10 and then color the new inserted node as RED\" \" \" %} \n\n\n\n\n| **_Properties again_**            | &nbsp; | &nbsp;                                                         |\n| :---              | :---:  | :---                                                                           |\n| **_Question_**:   | &nbsp; | Which **Red-Black Tree** [properties](#Properties) does the above case break?  |\n| 1. Every node is colored with either **RED** or **BLACK**                                  | &nbsp; | We don't break this because the new inserted node is colored as **RED**     | \n| 2. All leaf (NULL Pointer) nodes are colored with **BLACK**                                | &nbsp; | We don't break this because the new inserted node is a nonempty node, it won't impact the leaf nodes which are all nil(NULL Pointer) nodes |\n| 3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes  | &nbsp; | We don't break this because the new inserted node is colored as **RED**, so the count of **BLACK** nodes should keep same as before |\n| 4. Both children of a **RED** node must be **BLACK** nodes                                 | &nbsp; | **We might break property #4!!!** |\n| 5. The root is always **BLACK**                                                            | &nbsp; | We don't break this because BST insertion will only insert the new node to the leaf nodes, the root node won't be impacted |\n\nSo now we need to figure out a way to meet the property #4 in order to reconstruct the new BST to a **Red-Black Tree**\n\nThe C++ code for **Red-Black Tree Insertion** is below:\n\n```C++\n// Red-Black Tree Insertion\n// param : z, the node is going to be inserted \n// return : root node\nNode *RB_Insert(Node *Root,Node * z) { \n  Node * y=T_NIL;  \n  Node * x=Root;  \n  while(x != T_NIL) {               // Find the proper place in T to insert the new node z, y will be the parent node\n    y=x;  \n    if (z->key < x->key)  \n      x = x->left;  \n    else  \n      x = x->right;  \n  }  \n  z->p = y;  \n  if (y == T_NIL)                   // Case 1: if y is nil, then set z as root\n    Root = z;  \n  else if (z->key < y->key)         // Case 2: if z < y, then set z as y's left child\n    y->left = z;  \n  else                              // Case 3: if z >= y, then set z as y's right child\n    y->right = z;  \n  \n  z->left = T_NIL;                  // Set z's left child as nil\n  z->right = T_NIL;                 // Set z's right child as nil. So far done with BST insertion for the new node z\n  z->color = RED;                   // Color z as RED\n  Root = RB_Insert_Fixup(Root,z);   // Reconstruct(recolor or rotate) T via function RB_Insert_Fixup to meet all of the **Red-Black Tree** properties\n  return Root;   \n}  \n```\n\n\nThe C++ code for **Red-Black Tree RB_Insert_Fixup** is below:\n\n```C++\nNode* RB_Insert_Fixup(Node *T,Node *z)  {  \n  Node * y=NULL;  \n  while(z->p->color == RED) {    // z's parent is RED breaks the property #4, so fix it!\n    if (z->p == z->p->p->left) { // if z's parent is the left child of z's grampa\n      y = z->p->p->right;        // set y as z's uncle (the right child of z's grampa)  \n      if (y->color == RED) {     // Case 1: y (z's uncle) is RED\n        z->p->color = BLACK;     // Case 1: set the color of z's parent as BLACK\n        y->color = BLACK;        // Case 1: set the color of z's uncle as BLACK\n        z->p->p->color = RED;    // Case 1: set z's grampa as RED\n        z = z->p->p;             // Case 1: Iterate up, point z to z's grampa (the color of z is RED)  \n      } else if (z == z->p->right) { // Case 2: z's uncle is BLACK, and z is the right child of z's parent\n        z = z->p;                 // Case 2: point z to z's parent\n        Left_Rotate(&T,z);        // Case 2: LEFT-ROTATE on z (z is the pivot)\n        z->p->color = BLACK;      // Case 2 turns to Case 3: NOW z's uncle node is BLACK, and z is the left child of z's parent! Set z's parent as BLACK\n        z->p->p->color = RED;     // Case 3: set z's grampa as RED\n        Right_Rotate(&T,z->p->p); // Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]\n      } else {                   // case 3: z's uncle is BLACK and z is the left child of z's parent\n        z->p->color = BLACK;     // Case 3: set z's parent as BLACK\n        z->p->p->color = RED;    // Case 3: set z's grampa as RED\n        Right_Rotate(&T,z->p->p);// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]\n      } \n    } else {                     //Symmetric processing\n      y = z->p->p->left;  \n      if (y->color == RED) {     // Case 1: z's uncle is RED\n        z->p->color = BLACK;  \n        y->color = BLACK;  \n        z->p->p->color = RED;  \n        z = z->p->p;  \n  \t  } else if (z == z->p->left) { // Case 2: z's uncle is BLACK and z is the left child of z's parent\n        z = z->p;  \n        Right_Rotate(&T,z);  \n        z->p->color = BLACK;  \n        z->p->p->color = RED;  \n        Left_Rotate(&T,z->p->p);   \n      } else {                      // Case 3: z's uncle is BLACK and z is the right child of z's parent\n        z->p->color = BLACK;  \n        z->p->p->color = RED;  \n        Left_Rotate(&T,z->p->p);   \n      }\n    }  \n  }    \n  T->color = BLACK;          // make sure don't break the property #5, color the root as BLACK\n  return T;  \n}  \n```\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\nAccording to **z**'s **parent**'s state, when we insert **z** into a **Red-Black Tree** and then color **z** as **RED**, there will be 3 cases to deal with:\n\n| **Case**                                   | &nbsp;          | &nbsp; |\n| :---                                       | :---:           | :---   |\n| **1**: **z** is the root node              | &nbsp;---&nbsp; | Color node **z** as **BLACK** |\n| **2**: **z**'s **parent** is the root node | &nbsp;---&nbsp; | Do nothing, since **T** is still a **Red-Black Tree** after inserted **z** |\n| **3**: **z**'s **parent** is **RED**       | &nbsp;---&nbsp; | This case breaks the [property](#Properties) #4, in this situation, **z** must have **grampa** node, further more|\n| &nbsp;                                     | &nbsp;---&nbsp; | **z** must have an **uncle** node (even it's NIL, we will still say it exists and NIL node is **BLACK**). |\n| &nbsp;                                     | &nbsp;---&nbsp; | According to **z**'s uncle's state, we will have another **3 sub-cases** as below: |\n\n\n| **Case** | &nbsp;                                                          | &nbsp; |\n| :---     | :---                                                            | :---   |\n| **3.1**: | **z**'s **parent** is **RED**, **z**'s uncle is **RED**         | (01) color **z**'s **parent** as **BLACK**                               |\n| &nbsp;   | &nbsp;                                                          | (02) color **z**'s uncle as **BLACK**                                    |\n| &nbsp;   | &nbsp;                                                          | (03) color **z**'s grampa as **RED**                                     |\n| &nbsp;   | &nbsp;                                                          | (04) point **z** to **z**'s grampa, then keep the processing iteratively |\n| **3.2**: | **z**'s **parent** is **RED**, **z**'s uncle is **BLACK**,      | (01) point **z** to **z**'s **parent**                                   |\n| &nbsp;   | and **z** is the **right child** of **z**'s **parent**  \t\t | (02) **LEFT-ROTATE** on **z**                                            |\n| **3.3**: | **z**'s **parent** is **RED**, **z**'s uncle is **BLACK**,      | (01) color **z**'s **parent** as **BLACK**                               |\n| &nbsp;   | and **z** is the **left child** of **z**'s **parent**           | (02) color **z**'s grampa as **RED**                                     |\n| &nbsp;   | &nbsp;                                                          | (03) **RIGHT-ROTATE** on **z**'s grampa                                  |\n\n**_The core idea about the 3 Sub-Cases above is : \"Move the RED node to root, then color the root as BLACK\"_**\n\n\n| **3.1** | &nbsp;&nbsp;**z**'s **parent** is **RED**, **z**'s uncle is **RED** |\n| :---    | :---                                                    |\n| &nbsp;  | &nbsp;&nbsp;**z** and **z**'s **parent** are **RED**, it breaks [property](#Properties) #4, so color **z**'s **parent** as **BLACK** to resolve this problem. |\n| **Q**:  | In this situation, **z** must have a **BLACK grampa**! **Why?** |\n| **A**:  | _Check **[property](#Properties) #4 and #5!**_ |\n| &nbsp;  | But when recolor **z**'s **parent** from **RED** to **BLACK**, [property](#Properties) #3 is broken, because the **Black-Height** of the subtree where **z**'s **parent** exists increased by 1. |\n| **Q**:  | How to resolve this problem? |\n| **A**:  | _Recolor **grampa** from **BLACK** to **RED**, and recolor uncle from **RED** to **BLACK**._ |\n| **Q**:  | Why this problem got resolved by this way? |\n| **A**:  | _Because the **Black-Height** of **z**'s **parent** subtree increased by 1, means the **Black-Height** of **z**'s **grampa** substree increased_ |\n| &nbsp;  | _by 1 as well, so recolor **grampa** from **BLACK** to **RED** to resolve the problem that the **Black-Height** of **grampa** subtree increased_ |\n| &nbsp;  | _by 1, but it will introduce another problem that the **Black-Height** of **uncle** subtree decreased by 1, because in this case **uncle** is **RED**, so recolor **uncle** from **RED** to **BLACK** can resolve this problem._ |\n| &nbsp;  | _According to the above steps: node **z**, **z**'s **parent** and **uncle** will not violate the **Red-Black Tree** [property](#Properties), but **z**'s **grampa** might violate!_ |\n| &nbsp;  | _If **z**'s **grampa** is root, then color **z**'s grampa as **BLACK** will resolve the problem completely._ |\n| &nbsp;  | _If **z**'s **grampa** is not root, then point the current node (pointer) to **z**'s **grampa** as the **\"new\" current node**, then analyzes the **\"new\" current node**_ |\n\n{% asset_img rbt_insertion_case_1.jpg \"Red-Black Tree Intertion Case 1\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n{% asset_img rbt_insertion_case_1_full.jpg \"Red-Black Tree Intertion Case 1 another example\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **3.2** | &nbsp;&nbsp;**z**'s **parent** is **RED**, **z**'s uncle is **BLACK**, and **z** is the **right child** of **z**'s **parent**        |\n| :---    | :---                                                                                                                                 |\n| &nbsp;  | &nbsp;&nbsp;point **z** to **z**'s **parent**, then **LEFT-ROTATE** on **z**                                                         |\n| **Q**:  | **Why point z to z's parent?**                                                                                                       |\n| **A**:  | _Becase the new node will be always inserted as the leaf, so we should keep processing on the subtree ascend to the root to ensure satisfy with all of the **Red-Black Tree** [property](#Properties)_ |\n| **Q**:  | **Why LEFT-ROTATE on z?**                                                                                                |\n| **A**:  | _The core idea of **Red-Black Tree** is \"**Move the RED node to root, then color the RED node to BLACK**\"\". Further more, because **z** is the **right child**, so we need **LEFT-ROTATE** to move **z** up!_ |\n\n\n{% asset_img rbt_insertion_case_2.jpg \"Red-Black Tree Intertion Case 2\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n{% asset_img rbt_insertion_case_2_full.jpg \"Red-Black Tree Intertion Case 2 another example\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **3.3** | &nbsp;&nbsp;**z**'s **parent** is **RED**, **z**'s uncle is **BLACK**, and **z** is the **left child** of **z**'s **parent**            |\n| :---    | :---                                                                                                                                    |\n| &nbsp;  | &nbsp;&nbsp;recolor **z**'s **parent** as **BLACK**, recolor **z**'s **grampa** as **RED**, then **RIGHT-ROTATE** on **z**'s **grampa** |\n| **Q**:  | **Why recolor z and z's parent?** |\n| **A**:  | _Both of the current node **z** and **z**'s parent are **RED**, it breaks [property](#Properties) #4, so recolor **z**'s parent as **BLACK** to resolve this issue._ |\n| &nbsp;  | _After above step, [property](#Properties) #3 is broken, because the **Black-Height** of the subtree where **z**'s **parent** exists increased by 1__  |\n| &nbsp;  | _To resolve this problem, we need to recolor **z**'s **grampa** from **BLACK** to **RED**, and then do **RIGHT-ROTATE** on **z**'s **grampa**._  |\n\n{% asset_img rbt_insertion_case_3_full.jpg \"Red-Black Tree Intertion Case 3 another example\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **Steps** | **A Complete Red-Black Tree Insertion Process*               |\n| :---      | :---                                                         |\n| The original **Red-Black Tree**                                                       | {% asset_img rbt_insertion_complete_1.png \"Step 1\" \" \" %}        |\n| Insert node **32** into the tree.<br/>This is no longer a **Red-Black Tree**<br/>because there are two successive **RED** nodes<br/>on the path 57-29-43-37-32.<br/>Mark the new node **32** as **x**, and it's **uncle** as **y**<br/>**y** is **RED**, so we have **case 1**                                       | {% asset_img rbt_insertion_complete_2.png \"Step 2\" \" \" %} |\n| Recolor the nodes **37, 43, 51**                                                      | {% asset_img rbt_insertion_complete_3.png \"Step 3\" \" \" %}        |\n| Move **x** up to its **grampa (43)**.<br/>**x**'s **parent 29** is still **RED**,<br/>so this isn't a **Red-Black Tree** yet.<br/> Mark the uncle **y**.<br/>In this case, the **uncle** is **BLACK**,<br/>so we have the **case 2**.                                                                                    | {% asset_img rbt_insertion_complete_4.png \"Step 4\" \" \" %}        |\n| Move **x** up again and do **LEFT-ROTATE** on **x**.                                  | {% asset_img rbt_insertion_complete_5.png \"Step 5\" \" \" %}        |\n| Still not a **Red-Black Tree**.                                                       | {% asset_img rbt_insertion_complete_6.png \"Step 6\" \" \" %}        |\n| Recolor nodes **43** and **57**,<br/>**RIGHT-ROTATE** on **57**.                      | {% asset_img rbt_insertion_complete_7.png \"Step 7\" \" \" %}        |\n| This is now a **Red-Black Tree**!<br/>$O(log_n)$ time!                                | {% asset_img rbt_insertion_complete_8.png \"Step 8\" \" \" %}        |\n","source":"_posts/2016-11-29-Red-Black-Tree-Insertion.md","raw":"---\ntitle: Red-Black Tree Insertion\ndate: 2016-11-29 14:54:43\ntags:\n- Algorithm\n- Tree\n---\n\n<a name=\"Properties\"></a>\n# Red-Black Tree Properties #\n1. Every node is colored with either **RED** or **BLACK**;\n2. All leaf (NULL Pointer) nodes are colored with **BLACK**; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored **BLACK**._\n3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes (**_not counting node $x$_**). We call this number the **Black-Height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a **RED** node must be **BLACK** nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always **BLACK**;\n\n# Insertion #\n\n| **An Example for Insertion**                                                                                                                                                             | &nbsp;                                           |\n| :---                                                                                                                                                                                     | ---:                                             |\n| **Color this tree**                                                                                                                                                                      | {% asset_img rbt_insertion_1.jpg \"Step 1\" \" \" %} | \n| **Insert 8**<br/>Where does it go?<br/>What color shoult it be?                                                                                                                          | {% asset_img rbt_insertion_2.jpg \"Step 2\" \" \" %} | \n| **Insert 8**<br/>Color the inserted node as **RED**                                                                                                                                      | {% asset_img rbt_insertion_3.jpg \"Step 3\" \" \" %} | \n| **Insert 11**<br/>Where does it go?<br/>What color shoult it be?<br/>Can't be **RED**!(break [property](#Properties) #4)<br/>Can't be **BLACK**!(break [property](#Properties) #3)       | {% asset_img rbt_insertion_4.jpg \"Step 4\" \" \" %} | \n| **Insert 11**<br/>Where does it go?<br/>Solution: recolor the tree                                                                                                                       | {% asset_img rbt_insertion_5.jpg \"Step 5\" \" \" %} | \n| **Insert 10**<br/>Where does it go?<br/>What color shoult it be?<br/><br/>**Answer**: no color! Tree is too imbalanced!<br/>Must change tree structure to allow recoloring<br/>**Goal**: Restructure tree in $O(log_2(n))$ time                                                                                      | {% asset_img rbt_insertion_6.jpg \"Step 6\" \" \" %}      | \n\n\nBased on the above example, the **Red-Black Tree Insertion operation** is to do a regular BST insertion, then do the operations (recolor or rotate) to make the new tree satisfy with all of the **Red-Black Tree** [properties](#Properties).\nA special case is required for an empty tree. If the tree is empty, replace it with a single **BLACK** node containing the inserted value. This ensures that the root property is satisfied.\n\nSo assume we are trying to insert one new node **x** to **T** (a nonempty **Red-Black Tree**)\n\n| **Steps**:  | &nbsp;                                                                                                       |\n| :---                  | :---                                                                                                         |\n| **1**:           | Use the BST insert algorithm to insert **x** to **T** (**_Note: every insertion take places at a leaf)_**    |\n| **2**:           | Color the node **x** **RED**                                                                                 |\n| **3**:           | Restore **Red-Black Tree** [properties](#Properties) by **recolor** or **rotate** operations (if necessary)  |\n\n\n| &nbsp;            | &nbsp;                                                            |\n| :---              | :---                                                              |\n| **_Question_**:   | At **Step 2**, why color the new inserted node **x** as **RED**?  |\n| **_Answer_**:     | Recall the **Red-Black Tree** [properties](#Properties), color the new inserted node **x** as **RED** won't violate the [property](#Properties) #3, so the **Black-Height** will be same as before the insertion |\n| &nbsp;            | which means the less cases we have to handle to keep maintaining the **Red-Black Tree** [properties](#Properties)                                                                                                |\n  \n\n\nBack to the step #6 in the example above, after insert **10** into the **Red-Black Tree**, first based on the regular BST insert algorithm to find the proper location, where is the left child of node **11**, then we should color the node **10** as **RED**, so now we get a tree like below:\n\n{% asset_img rbt_insertion_7.jpg \"Insert 10 and then color the new inserted node as RED\" \" \" %} \n\n\n\n\n| **_Properties again_**            | &nbsp; | &nbsp;                                                         |\n| :---              | :---:  | :---                                                                           |\n| **_Question_**:   | &nbsp; | Which **Red-Black Tree** [properties](#Properties) does the above case break?  |\n| 1. Every node is colored with either **RED** or **BLACK**                                  | &nbsp; | We don't break this because the new inserted node is colored as **RED**     | \n| 2. All leaf (NULL Pointer) nodes are colored with **BLACK**                                | &nbsp; | We don't break this because the new inserted node is a nonempty node, it won't impact the leaf nodes which are all nil(NULL Pointer) nodes |\n| 3. Every path from a node $x$ to a descendent leaf has the same number of **BLACK** nodes  | &nbsp; | We don't break this because the new inserted node is colored as **RED**, so the count of **BLACK** nodes should keep same as before |\n| 4. Both children of a **RED** node must be **BLACK** nodes                                 | &nbsp; | **We might break property #4!!!** |\n| 5. The root is always **BLACK**                                                            | &nbsp; | We don't break this because BST insertion will only insert the new node to the leaf nodes, the root node won't be impacted |\n\nSo now we need to figure out a way to meet the property #4 in order to reconstruct the new BST to a **Red-Black Tree**\n\nThe C++ code for **Red-Black Tree Insertion** is below:\n\n```C++\n// Red-Black Tree Insertion\n// param : z, the node is going to be inserted \n// return : root node\nNode *RB_Insert(Node *Root,Node * z) { \n  Node * y=T_NIL;  \n  Node * x=Root;  \n  while(x != T_NIL) {               // Find the proper place in T to insert the new node z, y will be the parent node\n    y=x;  \n    if (z->key < x->key)  \n      x = x->left;  \n    else  \n      x = x->right;  \n  }  \n  z->p = y;  \n  if (y == T_NIL)                   // Case 1: if y is nil, then set z as root\n    Root = z;  \n  else if (z->key < y->key)         // Case 2: if z < y, then set z as y's left child\n    y->left = z;  \n  else                              // Case 3: if z >= y, then set z as y's right child\n    y->right = z;  \n  \n  z->left = T_NIL;                  // Set z's left child as nil\n  z->right = T_NIL;                 // Set z's right child as nil. So far done with BST insertion for the new node z\n  z->color = RED;                   // Color z as RED\n  Root = RB_Insert_Fixup(Root,z);   // Reconstruct(recolor or rotate) T via function RB_Insert_Fixup to meet all of the **Red-Black Tree** properties\n  return Root;   \n}  \n```\n\n\nThe C++ code for **Red-Black Tree RB_Insert_Fixup** is below:\n\n```C++\nNode* RB_Insert_Fixup(Node *T,Node *z)  {  \n  Node * y=NULL;  \n  while(z->p->color == RED) {    // z's parent is RED breaks the property #4, so fix it!\n    if (z->p == z->p->p->left) { // if z's parent is the left child of z's grampa\n      y = z->p->p->right;        // set y as z's uncle (the right child of z's grampa)  \n      if (y->color == RED) {     // Case 1: y (z's uncle) is RED\n        z->p->color = BLACK;     // Case 1: set the color of z's parent as BLACK\n        y->color = BLACK;        // Case 1: set the color of z's uncle as BLACK\n        z->p->p->color = RED;    // Case 1: set z's grampa as RED\n        z = z->p->p;             // Case 1: Iterate up, point z to z's grampa (the color of z is RED)  \n      } else if (z == z->p->right) { // Case 2: z's uncle is BLACK, and z is the right child of z's parent\n        z = z->p;                 // Case 2: point z to z's parent\n        Left_Rotate(&T,z);        // Case 2: LEFT-ROTATE on z (z is the pivot)\n        z->p->color = BLACK;      // Case 2 turns to Case 3: NOW z's uncle node is BLACK, and z is the left child of z's parent! Set z's parent as BLACK\n        z->p->p->color = RED;     // Case 3: set z's grampa as RED\n        Right_Rotate(&T,z->p->p); // Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]\n      } else {                   // case 3: z's uncle is BLACK and z is the left child of z's parent\n        z->p->color = BLACK;     // Case 3: set z's parent as BLACK\n        z->p->p->color = RED;    // Case 3: set z's grampa as RED\n        Right_Rotate(&T,z->p->p);// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]\n      } \n    } else {                     //Symmetric processing\n      y = z->p->p->left;  \n      if (y->color == RED) {     // Case 1: z's uncle is RED\n        z->p->color = BLACK;  \n        y->color = BLACK;  \n        z->p->p->color = RED;  \n        z = z->p->p;  \n  \t  } else if (z == z->p->left) { // Case 2: z's uncle is BLACK and z is the left child of z's parent\n        z = z->p;  \n        Right_Rotate(&T,z);  \n        z->p->color = BLACK;  \n        z->p->p->color = RED;  \n        Left_Rotate(&T,z->p->p);   \n      } else {                      // Case 3: z's uncle is BLACK and z is the right child of z's parent\n        z->p->color = BLACK;  \n        z->p->p->color = RED;  \n        Left_Rotate(&T,z->p->p);   \n      }\n    }  \n  }    \n  T->color = BLACK;          // make sure don't break the property #5, color the root as BLACK\n  return T;  \n}  \n```\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\nAccording to **z**'s **parent**'s state, when we insert **z** into a **Red-Black Tree** and then color **z** as **RED**, there will be 3 cases to deal with:\n\n| **Case**                                   | &nbsp;          | &nbsp; |\n| :---                                       | :---:           | :---   |\n| **1**: **z** is the root node              | &nbsp;---&nbsp; | Color node **z** as **BLACK** |\n| **2**: **z**'s **parent** is the root node | &nbsp;---&nbsp; | Do nothing, since **T** is still a **Red-Black Tree** after inserted **z** |\n| **3**: **z**'s **parent** is **RED**       | &nbsp;---&nbsp; | This case breaks the [property](#Properties) #4, in this situation, **z** must have **grampa** node, further more|\n| &nbsp;                                     | &nbsp;---&nbsp; | **z** must have an **uncle** node (even it's NIL, we will still say it exists and NIL node is **BLACK**). |\n| &nbsp;                                     | &nbsp;---&nbsp; | According to **z**'s uncle's state, we will have another **3 sub-cases** as below: |\n\n\n| **Case** | &nbsp;                                                          | &nbsp; |\n| :---     | :---                                                            | :---   |\n| **3.1**: | **z**'s **parent** is **RED**, **z**'s uncle is **RED**         | (01) color **z**'s **parent** as **BLACK**                               |\n| &nbsp;   | &nbsp;                                                          | (02) color **z**'s uncle as **BLACK**                                    |\n| &nbsp;   | &nbsp;                                                          | (03) color **z**'s grampa as **RED**                                     |\n| &nbsp;   | &nbsp;                                                          | (04) point **z** to **z**'s grampa, then keep the processing iteratively |\n| **3.2**: | **z**'s **parent** is **RED**, **z**'s uncle is **BLACK**,      | (01) point **z** to **z**'s **parent**                                   |\n| &nbsp;   | and **z** is the **right child** of **z**'s **parent**  \t\t | (02) **LEFT-ROTATE** on **z**                                            |\n| **3.3**: | **z**'s **parent** is **RED**, **z**'s uncle is **BLACK**,      | (01) color **z**'s **parent** as **BLACK**                               |\n| &nbsp;   | and **z** is the **left child** of **z**'s **parent**           | (02) color **z**'s grampa as **RED**                                     |\n| &nbsp;   | &nbsp;                                                          | (03) **RIGHT-ROTATE** on **z**'s grampa                                  |\n\n**_The core idea about the 3 Sub-Cases above is : \"Move the RED node to root, then color the root as BLACK\"_**\n\n\n| **3.1** | &nbsp;&nbsp;**z**'s **parent** is **RED**, **z**'s uncle is **RED** |\n| :---    | :---                                                    |\n| &nbsp;  | &nbsp;&nbsp;**z** and **z**'s **parent** are **RED**, it breaks [property](#Properties) #4, so color **z**'s **parent** as **BLACK** to resolve this problem. |\n| **Q**:  | In this situation, **z** must have a **BLACK grampa**! **Why?** |\n| **A**:  | _Check **[property](#Properties) #4 and #5!**_ |\n| &nbsp;  | But when recolor **z**'s **parent** from **RED** to **BLACK**, [property](#Properties) #3 is broken, because the **Black-Height** of the subtree where **z**'s **parent** exists increased by 1. |\n| **Q**:  | How to resolve this problem? |\n| **A**:  | _Recolor **grampa** from **BLACK** to **RED**, and recolor uncle from **RED** to **BLACK**._ |\n| **Q**:  | Why this problem got resolved by this way? |\n| **A**:  | _Because the **Black-Height** of **z**'s **parent** subtree increased by 1, means the **Black-Height** of **z**'s **grampa** substree increased_ |\n| &nbsp;  | _by 1 as well, so recolor **grampa** from **BLACK** to **RED** to resolve the problem that the **Black-Height** of **grampa** subtree increased_ |\n| &nbsp;  | _by 1, but it will introduce another problem that the **Black-Height** of **uncle** subtree decreased by 1, because in this case **uncle** is **RED**, so recolor **uncle** from **RED** to **BLACK** can resolve this problem._ |\n| &nbsp;  | _According to the above steps: node **z**, **z**'s **parent** and **uncle** will not violate the **Red-Black Tree** [property](#Properties), but **z**'s **grampa** might violate!_ |\n| &nbsp;  | _If **z**'s **grampa** is root, then color **z**'s grampa as **BLACK** will resolve the problem completely._ |\n| &nbsp;  | _If **z**'s **grampa** is not root, then point the current node (pointer) to **z**'s **grampa** as the **\"new\" current node**, then analyzes the **\"new\" current node**_ |\n\n{% asset_img rbt_insertion_case_1.jpg \"Red-Black Tree Intertion Case 1\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n{% asset_img rbt_insertion_case_1_full.jpg \"Red-Black Tree Intertion Case 1 another example\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **3.2** | &nbsp;&nbsp;**z**'s **parent** is **RED**, **z**'s uncle is **BLACK**, and **z** is the **right child** of **z**'s **parent**        |\n| :---    | :---                                                                                                                                 |\n| &nbsp;  | &nbsp;&nbsp;point **z** to **z**'s **parent**, then **LEFT-ROTATE** on **z**                                                         |\n| **Q**:  | **Why point z to z's parent?**                                                                                                       |\n| **A**:  | _Becase the new node will be always inserted as the leaf, so we should keep processing on the subtree ascend to the root to ensure satisfy with all of the **Red-Black Tree** [property](#Properties)_ |\n| **Q**:  | **Why LEFT-ROTATE on z?**                                                                                                |\n| **A**:  | _The core idea of **Red-Black Tree** is \"**Move the RED node to root, then color the RED node to BLACK**\"\". Further more, because **z** is the **right child**, so we need **LEFT-ROTATE** to move **z** up!_ |\n\n\n{% asset_img rbt_insertion_case_2.jpg \"Red-Black Tree Intertion Case 2\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n{% asset_img rbt_insertion_case_2_full.jpg \"Red-Black Tree Intertion Case 2 another example\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **3.3** | &nbsp;&nbsp;**z**'s **parent** is **RED**, **z**'s uncle is **BLACK**, and **z** is the **left child** of **z**'s **parent**            |\n| :---    | :---                                                                                                                                    |\n| &nbsp;  | &nbsp;&nbsp;recolor **z**'s **parent** as **BLACK**, recolor **z**'s **grampa** as **RED**, then **RIGHT-ROTATE** on **z**'s **grampa** |\n| **Q**:  | **Why recolor z and z's parent?** |\n| **A**:  | _Both of the current node **z** and **z**'s parent are **RED**, it breaks [property](#Properties) #4, so recolor **z**'s parent as **BLACK** to resolve this issue._ |\n| &nbsp;  | _After above step, [property](#Properties) #3 is broken, because the **Black-Height** of the subtree where **z**'s **parent** exists increased by 1__  |\n| &nbsp;  | _To resolve this problem, we need to recolor **z**'s **grampa** from **BLACK** to **RED**, and then do **RIGHT-ROTATE** on **z**'s **grampa**._  |\n\n{% asset_img rbt_insertion_case_3_full.jpg \"Red-Black Tree Intertion Case 3 another example\" \" \" %} \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n| **Steps** | **A Complete Red-Black Tree Insertion Process*               |\n| :---      | :---                                                         |\n| The original **Red-Black Tree**                                                       | {% asset_img rbt_insertion_complete_1.png \"Step 1\" \" \" %}        |\n| Insert node **32** into the tree.<br/>This is no longer a **Red-Black Tree**<br/>because there are two successive **RED** nodes<br/>on the path 57-29-43-37-32.<br/>Mark the new node **32** as **x**, and it's **uncle** as **y**<br/>**y** is **RED**, so we have **case 1**                                       | {% asset_img rbt_insertion_complete_2.png \"Step 2\" \" \" %} |\n| Recolor the nodes **37, 43, 51**                                                      | {% asset_img rbt_insertion_complete_3.png \"Step 3\" \" \" %}        |\n| Move **x** up to its **grampa (43)**.<br/>**x**'s **parent 29** is still **RED**,<br/>so this isn't a **Red-Black Tree** yet.<br/> Mark the uncle **y**.<br/>In this case, the **uncle** is **BLACK**,<br/>so we have the **case 2**.                                                                                    | {% asset_img rbt_insertion_complete_4.png \"Step 4\" \" \" %}        |\n| Move **x** up again and do **LEFT-ROTATE** on **x**.                                  | {% asset_img rbt_insertion_complete_5.png \"Step 5\" \" \" %}        |\n| Still not a **Red-Black Tree**.                                                       | {% asset_img rbt_insertion_complete_6.png \"Step 6\" \" \" %}        |\n| Recolor nodes **43** and **57**,<br/>**RIGHT-ROTATE** on **57**.                      | {% asset_img rbt_insertion_complete_7.png \"Step 7\" \" \" %}        |\n| This is now a **Red-Black Tree**!<br/>$O(log_n)$ time!                                | {% asset_img rbt_insertion_complete_8.png \"Step 8\" \" \" %}        |\n","slug":"Red-Black-Tree-Insertion","published":1,"updated":"2016-12-01T15:35:55.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xe5000amcls0r694isn","content":"<p><a name=\"Properties\"></a></p>\n<h1 id=\"Red-Black-Tree-Properties\"><a href=\"#Red-Black-Tree-Properties\" class=\"headerlink\" title=\"Red-Black Tree Properties\"></a>Red-Black Tree Properties</h1><ol>\n<li>Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong>;</li>\n<li>All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong>;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored <strong>BLACK</strong>.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>Black-Height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always <strong>BLACK</strong>;</li>\n</ol>\n<h1 id=\"Insertion\"><a href=\"#Insertion\" class=\"headerlink\" title=\"Insertion\"></a>Insertion</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>An Example for Insertion</strong></th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>Color this tree</strong></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_1.jpg\" alt=\"Step 1 \" title=\"Step 1 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 8</strong><br>Where does it go?<br>What color shoult it be?</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_2.jpg\" alt=\"Step 2 \" title=\"Step 2 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 8</strong><br>Color the inserted node as <strong>RED</strong></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_3.jpg\" alt=\"Step 3 \" title=\"Step 3 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 11</strong><br>Where does it go?<br>What color shoult it be?<br>Can’t be <strong>RED</strong>!(break <a href=\"#Properties\">property</a> #4)<br>Can’t be <strong>BLACK</strong>!(break <a href=\"#Properties\">property</a> #3)</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_4.jpg\" alt=\"Step 4 \" title=\"Step 4 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 11</strong><br>Where does it go?<br>Solution: recolor the tree</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_5.jpg\" alt=\"Step 5 \" title=\"Step 5 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 10</strong><br>Where does it go?<br>What color shoult it be?<br><br><strong>Answer</strong>: no color! Tree is too imbalanced!<br>Must change tree structure to allow recoloring<br><strong>Goal</strong>: Restructure tree in $O(log_2(n))$ time</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_6.jpg\" alt=\"Step 6 \" title=\"Step 6 \"></td>\n</tr>\n</tbody>\n</table>\n<p>Based on the above example, the <strong>Red-Black Tree Insertion operation</strong> is to do a regular BST insertion, then do the operations (recolor or rotate) to make the new tree satisfy with all of the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a>.<br>A special case is required for an empty tree. If the tree is empty, replace it with a single <strong>BLACK</strong> node containing the inserted value. This ensures that the root property is satisfied.</p>\n<p>So assume we are trying to insert one new node <strong>x</strong> to <strong>T</strong> (a nonempty <strong>Red-Black Tree</strong>)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Steps</strong>:</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>1</strong>:</td>\n<td style=\"text-align:left\">Use the BST insert algorithm to insert <strong>x</strong> to <strong>T</strong> (<strong><em>Note: every insertion take places at a leaf)</em></strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>2</strong>:</td>\n<td style=\"text-align:left\">Color the node <strong>x</strong> <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3</strong>:</td>\n<td style=\"text-align:left\">Restore <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a> by <strong>recolor</strong> or <strong>rotate</strong> operations (if necessary)</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><em>Question</em></strong>:</td>\n<td style=\"text-align:left\">At <strong>Step 2</strong>, why color the new inserted node <strong>x</strong> as <strong>RED</strong>?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><em>Answer</em></strong>:</td>\n<td style=\"text-align:left\">Recall the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a>, color the new inserted node <strong>x</strong> as <strong>RED</strong> won’t violate the <a href=\"#Properties\">property</a> #3, so the <strong>Black-Height</strong> will be same as before the insertion</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">which means the less cases we have to handle to keep maintaining the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a></td>\n</tr>\n</tbody>\n</table>\n<p>Back to the step #6 in the example above, after insert <strong>10</strong> into the <strong>Red-Black Tree</strong>, first based on the regular BST insert algorithm to find the proper location, where is the left child of node <strong>11</strong>, then we should color the node <strong>10</strong> as <strong>RED</strong>, so now we get a tree like below:</p>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_7.jpg\" alt=\"Insert 10 and then color the new inserted node as RED \" title=\"Insert 10 and then color the new inserted node as RED \"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong><em>Properties again</em></strong></th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><em>Question</em></strong>:</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">Which <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a> does the above case break?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1. Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2. All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is a nonempty node, it won’t impact the leaf nodes which are all nil(NULL Pointer) nodes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3. Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong>, so the count of <strong>BLACK</strong> nodes should keep same as before</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4. Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\"><strong>We might break property #4!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5. The root is always <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because BST insertion will only insert the new node to the leaf nodes, the root node won’t be impacted</td>\n</tr>\n</tbody>\n</table>\n<p>So now we need to figure out a way to meet the property #4 in order to reconstruct the new BST to a <strong>Red-Black Tree</strong></p>\n<p>The C++ code for <strong>Red-Black Tree Insertion</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Red-Black Tree Insertion</span></div><div class=\"line\"><span class=\"comment\">// param : z, the node is going to be inserted </span></div><div class=\"line\"><span class=\"comment\">// return : root node</span></div><div class=\"line\"><span class=\"function\">Node *<span class=\"title\">RB_Insert</span><span class=\"params\">(Node *Root,Node * z)</span> </span>&#123; </div><div class=\"line\">  Node * y=T_NIL;  </div><div class=\"line\">  Node * x=Root;  </div><div class=\"line\">  <span class=\"keyword\">while</span>(x != T_NIL) &#123;               <span class=\"comment\">// Find the proper place in T to insert the new node z, y will be the parent node</span></div><div class=\"line\">    y=x;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (z-&gt;key &lt; x-&gt;key)  </div><div class=\"line\">      x = x-&gt;left;  </div><div class=\"line\">    <span class=\"keyword\">else</span>  </div><div class=\"line\">      x = x-&gt;right;  </div><div class=\"line\">  &#125;  </div><div class=\"line\">  z-&gt;p = y;  </div><div class=\"line\">  <span class=\"keyword\">if</span> (y == T_NIL)                   <span class=\"comment\">// Case 1: if y is nil, then set z as root</span></div><div class=\"line\">    Root = z;  </div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z-&gt;key &lt; y-&gt;key)         <span class=\"comment\">// Case 2: if z &lt; y, then set z as y's left child</span></div><div class=\"line\">    y-&gt;left = z;  </div><div class=\"line\">  <span class=\"keyword\">else</span>                              <span class=\"comment\">// Case 3: if z &gt;= y, then set z as y's right child</span></div><div class=\"line\">    y-&gt;right = z;  </div><div class=\"line\">  </div><div class=\"line\">  z-&gt;left = T_NIL;                  <span class=\"comment\">// Set z's left child as nil</span></div><div class=\"line\">  z-&gt;right = T_NIL;                 <span class=\"comment\">// Set z's right child as nil. So far done with BST insertion for the new node z</span></div><div class=\"line\">  z-&gt;color = RED;                   <span class=\"comment\">// Color z as RED</span></div><div class=\"line\">  Root = RB_Insert_Fixup(Root,z);   <span class=\"comment\">// Reconstruct(recolor or rotate) T via function RB_Insert_Fixup to meet all of the **Red-Black Tree** properties</span></div><div class=\"line\">  <span class=\"keyword\">return</span> Root;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The C++ code for <strong>Red-Black Tree RB_Insert_Fixup</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Node* <span class=\"title\">RB_Insert_Fixup</span><span class=\"params\">(Node *T,Node *z)</span>  </span>&#123;  </div><div class=\"line\">  Node * y=<span class=\"literal\">NULL</span>;  </div><div class=\"line\">  <span class=\"keyword\">while</span>(z-&gt;p-&gt;color == RED) &#123;    <span class=\"comment\">// z's parent is RED breaks the property #4, so fix it!</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (z-&gt;p == z-&gt;p-&gt;p-&gt;left) &#123; <span class=\"comment\">// if z's parent is the left child of z's grampa</span></div><div class=\"line\">      y = z-&gt;p-&gt;p-&gt;right;        <span class=\"comment\">// set y as z's uncle (the right child of z's grampa)  </span></div><div class=\"line\">      <span class=\"keyword\">if</span> (y-&gt;color == RED) &#123;     <span class=\"comment\">// Case 1: y (z's uncle) is RED</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;     <span class=\"comment\">// Case 1: set the color of z's parent as BLACK</span></div><div class=\"line\">        y-&gt;color = BLACK;        <span class=\"comment\">// Case 1: set the color of z's uncle as BLACK</span></div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;    <span class=\"comment\">// Case 1: set z's grampa as RED</span></div><div class=\"line\">        z = z-&gt;p-&gt;p;             <span class=\"comment\">// Case 1: Iterate up, point z to z's grampa (the color of z is RED)  </span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z == z-&gt;p-&gt;right) &#123; <span class=\"comment\">// Case 2: z's uncle is BLACK, and z is the right child of z's parent</span></div><div class=\"line\">        z = z-&gt;p;                 <span class=\"comment\">// Case 2: point z to z's parent</span></div><div class=\"line\">        Left_Rotate(&amp;T,z);        <span class=\"comment\">// Case 2: LEFT-ROTATE on z (z is the pivot)</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;      <span class=\"comment\">// Case 2 turns to Case 3: NOW z's uncle node is BLACK, and z is the left child of z's parent! Set z's parent as BLACK</span></div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;     <span class=\"comment\">// Case 3: set z's grampa as RED</span></div><div class=\"line\">        Right_Rotate(&amp;T,z-&gt;p-&gt;p); <span class=\"comment\">// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;                   <span class=\"comment\">// case 3: z's uncle is BLACK and z is the left child of z's parent</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;     <span class=\"comment\">// Case 3: set z's parent as BLACK</span></div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;    <span class=\"comment\">// Case 3: set z's grampa as RED</span></div><div class=\"line\">        Right_Rotate(&amp;T,z-&gt;p-&gt;p);<span class=\"comment\">// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]</span></div><div class=\"line\">      &#125; </div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                     <span class=\"comment\">//Symmetric processing</span></div><div class=\"line\">      y = z-&gt;p-&gt;p-&gt;left;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (y-&gt;color == RED) &#123;     <span class=\"comment\">// Case 1: z's uncle is RED</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;  </div><div class=\"line\">        y-&gt;color = BLACK;  </div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class=\"line\">        z = z-&gt;p-&gt;p;  </div><div class=\"line\">  \t  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z == z-&gt;p-&gt;left) &#123; <span class=\"comment\">// Case 2: z's uncle is BLACK and z is the left child of z's parent</span></div><div class=\"line\">        z = z-&gt;p;  </div><div class=\"line\">        Right_Rotate(&amp;T,z);  </div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;  </div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class=\"line\">        Left_Rotate(&amp;T,z-&gt;p-&gt;p);   </div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;                      <span class=\"comment\">// Case 3: z's uncle is BLACK and z is the right child of z's parent</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;  </div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class=\"line\">        Left_Rotate(&amp;T,z-&gt;p-&gt;p);   </div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;  </div><div class=\"line\">  &#125;    </div><div class=\"line\">  T-&gt;color = BLACK;          <span class=\"comment\">// make sure don't break the property #5, color the root as BLACK</span></div><div class=\"line\">  <span class=\"keyword\">return</span> T;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>According to <strong>z</strong>‘s <strong>parent</strong>‘s state, when we insert <strong>z</strong> into a <strong>Red-Black Tree</strong> and then color <strong>z</strong> as <strong>RED</strong>, there will be 3 cases to deal with:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Case</strong></th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>1</strong>: <strong>z</strong> is the root node</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">Color node <strong>z</strong> as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>2</strong>: <strong>z</strong>‘s <strong>parent</strong> is the root node</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">Do nothing, since <strong>T</strong> is still a <strong>Red-Black Tree</strong> after inserted <strong>z</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3</strong>: <strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong></td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">This case breaks the <a href=\"#Properties\">property</a> #4, in this situation, <strong>z</strong> must have <strong>grampa</strong> node, further more</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\"><strong>z</strong> must have an <strong>uncle</strong> node (even it’s NIL, we will still say it exists and NIL node is <strong>BLACK</strong>).</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">According to <strong>z</strong>‘s uncle’s state, we will have another <strong>3 sub-cases</strong> as below:</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Case</strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>3.1</strong>:</td>\n<td style=\"text-align:left\"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>RED</strong></td>\n<td style=\"text-align:left\">(01) color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(02) color <strong>z</strong>‘s uncle as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(03) color <strong>z</strong>‘s grampa as <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(04) point <strong>z</strong> to <strong>z</strong>‘s grampa, then keep the processing iteratively</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3.2</strong>:</td>\n<td style=\"text-align:left\"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>,</td>\n<td style=\"text-align:left\">(01) point <strong>z</strong> to <strong>z</strong>‘s <strong>parent</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">and <strong>z</strong> is the <strong>right child</strong> of <strong>z</strong>‘s <strong>parent</strong></td>\n<td style=\"text-align:left\">(02) <strong>LEFT-ROTATE</strong> on <strong>z</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3.3</strong>:</td>\n<td style=\"text-align:left\"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>,</td>\n<td style=\"text-align:left\">(01) color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">and <strong>z</strong> is the <strong>left child</strong> of <strong>z</strong>‘s <strong>parent</strong></td>\n<td style=\"text-align:left\">(02) color <strong>z</strong>‘s grampa as <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(03) <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s grampa</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>The core idea about the 3 Sub-Cases above is : “Move the RED node to root, then color the root as BLACK”</em></strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>3.1</strong></th>\n<th style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>RED</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong> and <strong>z</strong>‘s <strong>parent</strong> are <strong>RED</strong>, it breaks <a href=\"#Properties\">property</a> #4, so color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong> to resolve this problem.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\">In this situation, <strong>z</strong> must have a <strong>BLACK grampa</strong>! <strong>Why?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Check <strong><a href=\"#Properties\">property</a> #4 and #5!</strong></em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">But when recolor <strong>z</strong>‘s <strong>parent</strong> from <strong>RED</strong> to <strong>BLACK</strong>, <a href=\"#Properties\">property</a> #3 is broken, because the <strong>Black-Height</strong> of the subtree where <strong>z</strong>‘s <strong>parent</strong> exists increased by 1.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\">How to resolve this problem?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Recolor <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong>, and recolor uncle from <strong>RED</strong> to <strong>BLACK</strong>.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\">Why this problem got resolved by this way?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Because the <strong>Black-Height</strong> of <strong>z</strong>‘s <strong>parent</strong> subtree increased by 1, means the <strong>Black-Height</strong> of <strong>z</strong>‘s <strong>grampa</strong> substree increased</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>by 1 as well, so recolor <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong> to resolve the problem that the <strong>Black-Height</strong> of <strong>grampa</strong> subtree increased</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>by 1, but it will introduce another problem that the <strong>Black-Height</strong> of <strong>uncle</strong> subtree decreased by 1, because in this case <strong>uncle</strong> is <strong>RED</strong>, so recolor <strong>uncle</strong> from <strong>RED</strong> to <strong>BLACK</strong> can resolve this problem.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>According to the above steps: node <strong>z</strong>, <strong>z</strong>‘s <strong>parent</strong> and <strong>uncle</strong> will not violate the <strong>Red-Black Tree</strong> <a href=\"#Properties\">property</a>, but <strong>z</strong>‘s <strong>grampa</strong> might violate!</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>If <strong>z</strong>‘s <strong>grampa</strong> is root, then color <strong>z</strong>‘s grampa as <strong>BLACK</strong> will resolve the problem completely.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>If <strong>z</strong>‘s <strong>grampa</strong> is not root, then point the current node (pointer) to <strong>z</strong>‘s <strong>grampa</strong> as the <strong>“new” current node</strong>, then analyzes the <strong>“new” current node</strong></em></td>\n</tr>\n</tbody>\n</table>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_1.jpg\" alt=\"Red-Black Tree Intertion Case 1 \" title=\"Red-Black Tree Intertion Case 1 \"> \n<hr>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_1_full.jpg\" alt=\"Red-Black Tree Intertion Case 1 another example \" title=\"Red-Black Tree Intertion Case 1 another example \"> \n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>3.2</strong></th>\n<th style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>, and <strong>z</strong> is the <strong>right child</strong> of <strong>z</strong>‘s <strong>parent</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp;point <strong>z</strong> to <strong>z</strong>‘s <strong>parent</strong>, then <strong>LEFT-ROTATE</strong> on <strong>z</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\"><strong>Why point z to z’s parent?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Becase the new node will be always inserted as the leaf, so we should keep processing on the subtree ascend to the root to ensure satisfy with all of the <strong>Red-Black Tree</strong> <a href=\"#Properties\">property</a></em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\"><strong>Why LEFT-ROTATE on z?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>The core idea of <strong>Red-Black Tree</strong> is “<strong>Move the RED node to root, then color the RED node to BLACK</strong>“”. Further more, because <strong>z</strong> is the <strong>right child</strong>, so we need <strong>LEFT-ROTATE</strong> to move <strong>z</strong> up!</em></td>\n</tr>\n</tbody>\n</table>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_2.jpg\" alt=\"Red-Black Tree Intertion Case 2 \" title=\"Red-Black Tree Intertion Case 2 \"> \n<hr>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_2_full.jpg\" alt=\"Red-Black Tree Intertion Case 2 another example \" title=\"Red-Black Tree Intertion Case 2 another example \"> \n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>3.3</strong></th>\n<th style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>, and <strong>z</strong> is the <strong>left child</strong> of <strong>z</strong>‘s <strong>parent</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp;recolor <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong>, recolor <strong>z</strong>‘s <strong>grampa</strong> as <strong>RED</strong>, then <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s <strong>grampa</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\"><strong>Why recolor z and z’s parent?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Both of the current node <strong>z</strong> and <strong>z</strong>‘s parent are <strong>RED</strong>, it breaks <a href=\"#Properties\">property</a> #4, so recolor <strong>z</strong>‘s parent as <strong>BLACK</strong> to resolve this issue.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">_After above step, <a href=\"#Properties\">property</a> #3 is broken, because the <strong>Black-Height</strong> of the subtree where <strong>z</strong>‘s <strong>parent</strong> exists increased by 1__</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>To resolve this problem, we need to recolor <strong>z</strong>‘s <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong>, and then do <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s <strong>grampa</strong>.</em></td>\n</tr>\n</tbody>\n</table>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_3_full.jpg\" alt=\"Red-Black Tree Intertion Case 3 another example \" title=\"Red-Black Tree Intertion Case 3 another example \"> \n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Steps</strong></th>\n<th style=\"text-align:left\"><em>*A Complete Red-Black Tree Insertion Process</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">The original <strong>Red-Black Tree</strong></td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_1.png\" alt=\"Step 1 \" title=\"Step 1 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Insert node <strong>32</strong> into the tree.<br>This is no longer a <strong>Red-Black Tree</strong><br>because there are two successive <strong>RED</strong> nodes<br>on the path 57-29-43-37-32.<br>Mark the new node <strong>32</strong> as <strong>x</strong>, and it’s <strong>uncle</strong> as <strong>y</strong><br><strong>y</strong> is <strong>RED</strong>, so we have <strong>case 1</strong></td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_2.png\" alt=\"Step 2 \" title=\"Step 2 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Recolor the nodes <strong>37, 43, 51</strong></td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_3.png\" alt=\"Step 3 \" title=\"Step 3 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Move <strong>x</strong> up to its <strong>grampa (43)</strong>.<br><strong>x</strong>‘s <strong>parent 29</strong> is still <strong>RED</strong>,<br>so this isn’t a <strong>Red-Black Tree</strong> yet.<br> Mark the uncle <strong>y</strong>.<br>In this case, the <strong>uncle</strong> is <strong>BLACK</strong>,<br>so we have the <strong>case 2</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_4.png\" alt=\"Step 4 \" title=\"Step 4 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Move <strong>x</strong> up again and do <strong>LEFT-ROTATE</strong> on <strong>x</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_5.png\" alt=\"Step 5 \" title=\"Step 5 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Still not a <strong>Red-Black Tree</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_6.png\" alt=\"Step 6 \" title=\"Step 6 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Recolor nodes <strong>43</strong> and <strong>57</strong>,<br><strong>RIGHT-ROTATE</strong> on <strong>57</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_7.png\" alt=\"Step 7 \" title=\"Step 7 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">This is now a <strong>Red-Black Tree</strong>!<br>$O(log_n)$ time!</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_8.png\" alt=\"Step 8 \" title=\"Step 8 \"></td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<p><a name=\"Properties\"></a></p>\n<h1 id=\"Red-Black-Tree-Properties\"><a href=\"#Red-Black-Tree-Properties\" class=\"headerlink\" title=\"Red-Black Tree Properties\"></a>Red-Black Tree Properties</h1><ol>\n<li>Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong>;</li>\n<li>All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong>;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored <strong>BLACK</strong>.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>Black-Height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always <strong>BLACK</strong>;</li>\n</ol>\n<h1 id=\"Insertion\"><a href=\"#Insertion\" class=\"headerlink\" title=\"Insertion\"></a>Insertion</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>An Example for Insertion</strong></th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>Color this tree</strong></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_1.jpg\" alt=\"Step 1 \" title=\"Step 1 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 8</strong><br/>Where does it go?<br/>What color shoult it be?</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_2.jpg\" alt=\"Step 2 \" title=\"Step 2 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 8</strong><br/>Color the inserted node as <strong>RED</strong></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_3.jpg\" alt=\"Step 3 \" title=\"Step 3 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 11</strong><br/>Where does it go?<br/>What color shoult it be?<br/>Can’t be <strong>RED</strong>!(break <a href=\"#Properties\">property</a> #4)<br/>Can’t be <strong>BLACK</strong>!(break <a href=\"#Properties\">property</a> #3)</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_4.jpg\" alt=\"Step 4 \" title=\"Step 4 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 11</strong><br/>Where does it go?<br/>Solution: recolor the tree</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_5.jpg\" alt=\"Step 5 \" title=\"Step 5 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Insert 10</strong><br/>Where does it go?<br/>What color shoult it be?<br/><br/><strong>Answer</strong>: no color! Tree is too imbalanced!<br/>Must change tree structure to allow recoloring<br/><strong>Goal</strong>: Restructure tree in $O(log_2(n))$ time</td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_6.jpg\" alt=\"Step 6 \" title=\"Step 6 \"></td>\n</tr>\n</tbody>\n</table>\n<p>Based on the above example, the <strong>Red-Black Tree Insertion operation</strong> is to do a regular BST insertion, then do the operations (recolor or rotate) to make the new tree satisfy with all of the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a>.<br>A special case is required for an empty tree. If the tree is empty, replace it with a single <strong>BLACK</strong> node containing the inserted value. This ensures that the root property is satisfied.</p>\n<p>So assume we are trying to insert one new node <strong>x</strong> to <strong>T</strong> (a nonempty <strong>Red-Black Tree</strong>)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Steps</strong>:</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>1</strong>:</td>\n<td style=\"text-align:left\">Use the BST insert algorithm to insert <strong>x</strong> to <strong>T</strong> (<strong><em>Note: every insertion take places at a leaf)</em></strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>2</strong>:</td>\n<td style=\"text-align:left\">Color the node <strong>x</strong> <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3</strong>:</td>\n<td style=\"text-align:left\">Restore <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a> by <strong>recolor</strong> or <strong>rotate</strong> operations (if necessary)</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><em>Question</em></strong>:</td>\n<td style=\"text-align:left\">At <strong>Step 2</strong>, why color the new inserted node <strong>x</strong> as <strong>RED</strong>?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong><em>Answer</em></strong>:</td>\n<td style=\"text-align:left\">Recall the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a>, color the new inserted node <strong>x</strong> as <strong>RED</strong> won’t violate the <a href=\"#Properties\">property</a> #3, so the <strong>Black-Height</strong> will be same as before the insertion</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">which means the less cases we have to handle to keep maintaining the <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a></td>\n</tr>\n</tbody>\n</table>\n<p>Back to the step #6 in the example above, after insert <strong>10</strong> into the <strong>Red-Black Tree</strong>, first based on the regular BST insert algorithm to find the proper location, where is the left child of node <strong>11</strong>, then we should color the node <strong>10</strong> as <strong>RED</strong>, so now we get a tree like below:</p>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_7.jpg\" alt=\"Insert 10 and then color the new inserted node as RED \" title=\"Insert 10 and then color the new inserted node as RED \"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong><em>Properties again</em></strong></th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong><em>Question</em></strong>:</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">Which <strong>Red-Black Tree</strong> <a href=\"#Properties\">properties</a> does the above case break?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1. Every node is colored with either <strong>RED</strong> or <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2. All leaf (NULL Pointer) nodes are colored with <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is a nonempty node, it won’t impact the leaf nodes which are all nil(NULL Pointer) nodes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3. Every path from a node $x$ to a descendent leaf has the same number of <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because the new inserted node is colored as <strong>RED</strong>, so the count of <strong>BLACK</strong> nodes should keep same as before</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4. Both children of a <strong>RED</strong> node must be <strong>BLACK</strong> nodes</td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\"><strong>We might break property #4!!!</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5. The root is always <strong>BLACK</strong></td>\n<td style=\"text-align:center\">&nbsp;</td>\n<td style=\"text-align:left\">We don’t break this because BST insertion will only insert the new node to the leaf nodes, the root node won’t be impacted</td>\n</tr>\n</tbody>\n</table>\n<p>So now we need to figure out a way to meet the property #4 in order to reconstruct the new BST to a <strong>Red-Black Tree</strong></p>\n<p>The C++ code for <strong>Red-Black Tree Insertion</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Red-Black Tree Insertion</span></div><div class=\"line\"><span class=\"comment\">// param : z, the node is going to be inserted </span></div><div class=\"line\"><span class=\"comment\">// return : root node</span></div><div class=\"line\"><span class=\"function\">Node *<span class=\"title\">RB_Insert</span><span class=\"params\">(Node *Root,Node * z)</span> </span>&#123; </div><div class=\"line\">  Node * y=T_NIL;  </div><div class=\"line\">  Node * x=Root;  </div><div class=\"line\">  <span class=\"keyword\">while</span>(x != T_NIL) &#123;               <span class=\"comment\">// Find the proper place in T to insert the new node z, y will be the parent node</span></div><div class=\"line\">    y=x;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (z-&gt;key &lt; x-&gt;key)  </div><div class=\"line\">      x = x-&gt;left;  </div><div class=\"line\">    <span class=\"keyword\">else</span>  </div><div class=\"line\">      x = x-&gt;right;  </div><div class=\"line\">  &#125;  </div><div class=\"line\">  z-&gt;p = y;  </div><div class=\"line\">  <span class=\"keyword\">if</span> (y == T_NIL)                   <span class=\"comment\">// Case 1: if y is nil, then set z as root</span></div><div class=\"line\">    Root = z;  </div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z-&gt;key &lt; y-&gt;key)         <span class=\"comment\">// Case 2: if z &lt; y, then set z as y's left child</span></div><div class=\"line\">    y-&gt;left = z;  </div><div class=\"line\">  <span class=\"keyword\">else</span>                              <span class=\"comment\">// Case 3: if z &gt;= y, then set z as y's right child</span></div><div class=\"line\">    y-&gt;right = z;  </div><div class=\"line\">  </div><div class=\"line\">  z-&gt;left = T_NIL;                  <span class=\"comment\">// Set z's left child as nil</span></div><div class=\"line\">  z-&gt;right = T_NIL;                 <span class=\"comment\">// Set z's right child as nil. So far done with BST insertion for the new node z</span></div><div class=\"line\">  z-&gt;color = RED;                   <span class=\"comment\">// Color z as RED</span></div><div class=\"line\">  Root = RB_Insert_Fixup(Root,z);   <span class=\"comment\">// Reconstruct(recolor or rotate) T via function RB_Insert_Fixup to meet all of the **Red-Black Tree** properties</span></div><div class=\"line\">  <span class=\"keyword\">return</span> Root;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The C++ code for <strong>Red-Black Tree RB_Insert_Fixup</strong> is below:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Node* <span class=\"title\">RB_Insert_Fixup</span><span class=\"params\">(Node *T,Node *z)</span>  </span>&#123;  </div><div class=\"line\">  Node * y=<span class=\"literal\">NULL</span>;  </div><div class=\"line\">  <span class=\"keyword\">while</span>(z-&gt;p-&gt;color == RED) &#123;    <span class=\"comment\">// z's parent is RED breaks the property #4, so fix it!</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (z-&gt;p == z-&gt;p-&gt;p-&gt;left) &#123; <span class=\"comment\">// if z's parent is the left child of z's grampa</span></div><div class=\"line\">      y = z-&gt;p-&gt;p-&gt;right;        <span class=\"comment\">// set y as z's uncle (the right child of z's grampa)  </span></div><div class=\"line\">      <span class=\"keyword\">if</span> (y-&gt;color == RED) &#123;     <span class=\"comment\">// Case 1: y (z's uncle) is RED</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;     <span class=\"comment\">// Case 1: set the color of z's parent as BLACK</span></div><div class=\"line\">        y-&gt;color = BLACK;        <span class=\"comment\">// Case 1: set the color of z's uncle as BLACK</span></div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;    <span class=\"comment\">// Case 1: set z's grampa as RED</span></div><div class=\"line\">        z = z-&gt;p-&gt;p;             <span class=\"comment\">// Case 1: Iterate up, point z to z's grampa (the color of z is RED)  </span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z == z-&gt;p-&gt;right) &#123; <span class=\"comment\">// Case 2: z's uncle is BLACK, and z is the right child of z's parent</span></div><div class=\"line\">        z = z-&gt;p;                 <span class=\"comment\">// Case 2: point z to z's parent</span></div><div class=\"line\">        Left_Rotate(&amp;T,z);        <span class=\"comment\">// Case 2: LEFT-ROTATE on z (z is the pivot)</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;      <span class=\"comment\">// Case 2 turns to Case 3: NOW z's uncle node is BLACK, and z is the left child of z's parent! Set z's parent as BLACK</span></div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;     <span class=\"comment\">// Case 3: set z's grampa as RED</span></div><div class=\"line\">        Right_Rotate(&amp;T,z-&gt;p-&gt;p); <span class=\"comment\">// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;                   <span class=\"comment\">// case 3: z's uncle is BLACK and z is the left child of z's parent</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;     <span class=\"comment\">// Case 3: set z's parent as BLACK</span></div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;    <span class=\"comment\">// Case 3: set z's grampa as RED</span></div><div class=\"line\">        Right_Rotate(&amp;T,z-&gt;p-&gt;p);<span class=\"comment\">// Case 3: RIGHT-ROTATE on z's grampa (z's grampa is the pivot). [while loop is end]</span></div><div class=\"line\">      &#125; </div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                     <span class=\"comment\">//Symmetric processing</span></div><div class=\"line\">      y = z-&gt;p-&gt;p-&gt;left;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (y-&gt;color == RED) &#123;     <span class=\"comment\">// Case 1: z's uncle is RED</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;  </div><div class=\"line\">        y-&gt;color = BLACK;  </div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class=\"line\">        z = z-&gt;p-&gt;p;  </div><div class=\"line\">  \t  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (z == z-&gt;p-&gt;left) &#123; <span class=\"comment\">// Case 2: z's uncle is BLACK and z is the left child of z's parent</span></div><div class=\"line\">        z = z-&gt;p;  </div><div class=\"line\">        Right_Rotate(&amp;T,z);  </div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;  </div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class=\"line\">        Left_Rotate(&amp;T,z-&gt;p-&gt;p);   </div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;                      <span class=\"comment\">// Case 3: z's uncle is BLACK and z is the right child of z's parent</span></div><div class=\"line\">        z-&gt;p-&gt;color = BLACK;  </div><div class=\"line\">        z-&gt;p-&gt;p-&gt;color = RED;  </div><div class=\"line\">        Left_Rotate(&amp;T,z-&gt;p-&gt;p);   </div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;  </div><div class=\"line\">  &#125;    </div><div class=\"line\">  T-&gt;color = BLACK;          <span class=\"comment\">// make sure don't break the property #5, color the root as BLACK</span></div><div class=\"line\">  <span class=\"keyword\">return</span> T;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>According to <strong>z</strong>‘s <strong>parent</strong>‘s state, when we insert <strong>z</strong> into a <strong>Red-Black Tree</strong> and then color <strong>z</strong> as <strong>RED</strong>, there will be 3 cases to deal with:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Case</strong></th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>1</strong>: <strong>z</strong> is the root node</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">Color node <strong>z</strong> as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>2</strong>: <strong>z</strong>‘s <strong>parent</strong> is the root node</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">Do nothing, since <strong>T</strong> is still a <strong>Red-Black Tree</strong> after inserted <strong>z</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3</strong>: <strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong></td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">This case breaks the <a href=\"#Properties\">property</a> #4, in this situation, <strong>z</strong> must have <strong>grampa</strong> node, further more</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\"><strong>z</strong> must have an <strong>uncle</strong> node (even it’s NIL, we will still say it exists and NIL node is <strong>BLACK</strong>).</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:center\">&nbsp;—&nbsp;</td>\n<td style=\"text-align:left\">According to <strong>z</strong>‘s uncle’s state, we will have another <strong>3 sub-cases</strong> as below:</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Case</strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>3.1</strong>:</td>\n<td style=\"text-align:left\"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>RED</strong></td>\n<td style=\"text-align:left\">(01) color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(02) color <strong>z</strong>‘s uncle as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(03) color <strong>z</strong>‘s grampa as <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(04) point <strong>z</strong> to <strong>z</strong>‘s grampa, then keep the processing iteratively</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3.2</strong>:</td>\n<td style=\"text-align:left\"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>,</td>\n<td style=\"text-align:left\">(01) point <strong>z</strong> to <strong>z</strong>‘s <strong>parent</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">and <strong>z</strong> is the <strong>right child</strong> of <strong>z</strong>‘s <strong>parent</strong></td>\n<td style=\"text-align:left\">(02) <strong>LEFT-ROTATE</strong> on <strong>z</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>3.3</strong>:</td>\n<td style=\"text-align:left\"><strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>,</td>\n<td style=\"text-align:left\">(01) color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">and <strong>z</strong> is the <strong>left child</strong> of <strong>z</strong>‘s <strong>parent</strong></td>\n<td style=\"text-align:left\">(02) color <strong>z</strong>‘s grampa as <strong>RED</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">(03) <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s grampa</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>The core idea about the 3 Sub-Cases above is : “Move the RED node to root, then color the root as BLACK”</em></strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>3.1</strong></th>\n<th style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>RED</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong> and <strong>z</strong>‘s <strong>parent</strong> are <strong>RED</strong>, it breaks <a href=\"#Properties\">property</a> #4, so color <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong> to resolve this problem.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\">In this situation, <strong>z</strong> must have a <strong>BLACK grampa</strong>! <strong>Why?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Check <strong><a href=\"#Properties\">property</a> #4 and #5!</strong></em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">But when recolor <strong>z</strong>‘s <strong>parent</strong> from <strong>RED</strong> to <strong>BLACK</strong>, <a href=\"#Properties\">property</a> #3 is broken, because the <strong>Black-Height</strong> of the subtree where <strong>z</strong>‘s <strong>parent</strong> exists increased by 1.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\">How to resolve this problem?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Recolor <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong>, and recolor uncle from <strong>RED</strong> to <strong>BLACK</strong>.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\">Why this problem got resolved by this way?</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Because the <strong>Black-Height</strong> of <strong>z</strong>‘s <strong>parent</strong> subtree increased by 1, means the <strong>Black-Height</strong> of <strong>z</strong>‘s <strong>grampa</strong> substree increased</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>by 1 as well, so recolor <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong> to resolve the problem that the <strong>Black-Height</strong> of <strong>grampa</strong> subtree increased</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>by 1, but it will introduce another problem that the <strong>Black-Height</strong> of <strong>uncle</strong> subtree decreased by 1, because in this case <strong>uncle</strong> is <strong>RED</strong>, so recolor <strong>uncle</strong> from <strong>RED</strong> to <strong>BLACK</strong> can resolve this problem.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>According to the above steps: node <strong>z</strong>, <strong>z</strong>‘s <strong>parent</strong> and <strong>uncle</strong> will not violate the <strong>Red-Black Tree</strong> <a href=\"#Properties\">property</a>, but <strong>z</strong>‘s <strong>grampa</strong> might violate!</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>If <strong>z</strong>‘s <strong>grampa</strong> is root, then color <strong>z</strong>‘s grampa as <strong>BLACK</strong> will resolve the problem completely.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>If <strong>z</strong>‘s <strong>grampa</strong> is not root, then point the current node (pointer) to <strong>z</strong>‘s <strong>grampa</strong> as the <strong>“new” current node</strong>, then analyzes the <strong>“new” current node</strong></em></td>\n</tr>\n</tbody>\n</table>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_1.jpg\" alt=\"Red-Black Tree Intertion Case 1 \" title=\"Red-Black Tree Intertion Case 1 \"> \n<hr>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_1_full.jpg\" alt=\"Red-Black Tree Intertion Case 1 another example \" title=\"Red-Black Tree Intertion Case 1 another example \"> \n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>3.2</strong></th>\n<th style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>, and <strong>z</strong> is the <strong>right child</strong> of <strong>z</strong>‘s <strong>parent</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp;point <strong>z</strong> to <strong>z</strong>‘s <strong>parent</strong>, then <strong>LEFT-ROTATE</strong> on <strong>z</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\"><strong>Why point z to z’s parent?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Becase the new node will be always inserted as the leaf, so we should keep processing on the subtree ascend to the root to ensure satisfy with all of the <strong>Red-Black Tree</strong> <a href=\"#Properties\">property</a></em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\"><strong>Why LEFT-ROTATE on z?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>The core idea of <strong>Red-Black Tree</strong> is “<strong>Move the RED node to root, then color the RED node to BLACK</strong>“”. Further more, because <strong>z</strong> is the <strong>right child</strong>, so we need <strong>LEFT-ROTATE</strong> to move <strong>z</strong> up!</em></td>\n</tr>\n</tbody>\n</table>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_2.jpg\" alt=\"Red-Black Tree Intertion Case 2 \" title=\"Red-Black Tree Intertion Case 2 \"> \n<hr>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_2_full.jpg\" alt=\"Red-Black Tree Intertion Case 2 another example \" title=\"Red-Black Tree Intertion Case 2 another example \"> \n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>3.3</strong></th>\n<th style=\"text-align:left\">&nbsp;&nbsp;<strong>z</strong>‘s <strong>parent</strong> is <strong>RED</strong>, <strong>z</strong>‘s uncle is <strong>BLACK</strong>, and <strong>z</strong> is the <strong>left child</strong> of <strong>z</strong>‘s <strong>parent</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">&nbsp;&nbsp;recolor <strong>z</strong>‘s <strong>parent</strong> as <strong>BLACK</strong>, recolor <strong>z</strong>‘s <strong>grampa</strong> as <strong>RED</strong>, then <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s <strong>grampa</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Q</strong>:</td>\n<td style=\"text-align:left\"><strong>Why recolor z and z’s parent?</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>A</strong>:</td>\n<td style=\"text-align:left\"><em>Both of the current node <strong>z</strong> and <strong>z</strong>‘s parent are <strong>RED</strong>, it breaks <a href=\"#Properties\">property</a> #4, so recolor <strong>z</strong>‘s parent as <strong>BLACK</strong> to resolve this issue.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\">_After above step, <a href=\"#Properties\">property</a> #3 is broken, because the <strong>Black-Height</strong> of the subtree where <strong>z</strong>‘s <strong>parent</strong> exists increased by 1__</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>To resolve this problem, we need to recolor <strong>z</strong>‘s <strong>grampa</strong> from <strong>BLACK</strong> to <strong>RED</strong>, and then do <strong>RIGHT-ROTATE</strong> on <strong>z</strong>‘s <strong>grampa</strong>.</em></td>\n</tr>\n</tbody>\n</table>\n<img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_case_3_full.jpg\" alt=\"Red-Black Tree Intertion Case 3 another example \" title=\"Red-Black Tree Intertion Case 3 another example \"> \n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Steps</strong></th>\n<th style=\"text-align:left\"><em>*A Complete Red-Black Tree Insertion Process</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">The original <strong>Red-Black Tree</strong></td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_1.png\" alt=\"Step 1 \" title=\"Step 1 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Insert node <strong>32</strong> into the tree.<br/>This is no longer a <strong>Red-Black Tree</strong><br/>because there are two successive <strong>RED</strong> nodes<br/>on the path 57-29-43-37-32.<br/>Mark the new node <strong>32</strong> as <strong>x</strong>, and it’s <strong>uncle</strong> as <strong>y</strong><br/><strong>y</strong> is <strong>RED</strong>, so we have <strong>case 1</strong></td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_2.png\" alt=\"Step 2 \" title=\"Step 2 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Recolor the nodes <strong>37, 43, 51</strong></td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_3.png\" alt=\"Step 3 \" title=\"Step 3 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Move <strong>x</strong> up to its <strong>grampa (43)</strong>.<br/><strong>x</strong>‘s <strong>parent 29</strong> is still <strong>RED</strong>,<br/>so this isn’t a <strong>Red-Black Tree</strong> yet.<br/> Mark the uncle <strong>y</strong>.<br/>In this case, the <strong>uncle</strong> is <strong>BLACK</strong>,<br/>so we have the <strong>case 2</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_4.png\" alt=\"Step 4 \" title=\"Step 4 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Move <strong>x</strong> up again and do <strong>LEFT-ROTATE</strong> on <strong>x</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_5.png\" alt=\"Step 5 \" title=\"Step 5 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Still not a <strong>Red-Black Tree</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_6.png\" alt=\"Step 6 \" title=\"Step 6 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Recolor nodes <strong>43</strong> and <strong>57</strong>,<br/><strong>RIGHT-ROTATE</strong> on <strong>57</strong>.</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_7.png\" alt=\"Step 7 \" title=\"Step 7 \"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">This is now a <strong>Red-Black Tree</strong>!<br/>$O(log_n)$ time!</td>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/29/Red-Black-Tree-Insertion/rbt_insertion_complete_8.png\" alt=\"Step 8 \" title=\"Step 8 \"></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Multiple SSH Keys settings for different github account","date":"2016-10-24T15:57:10.000Z","_content":"\n## (GitHub-Flavored) Markdown Editor##\n\n1. [Generating a new ssh key and adding it to the ssh agent](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)\n\n\tspecify the key store name\n\n\t```\n \tssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C \"foursquarebehind@gmail.com\"\n\t```\n\n\tNote: have to make sure the ssh daemon is started\n\n\t```\n\teval \"$(ssh-agent -s)\"\n\t```\n\n\n2. [Adding a new ssh key to your github account](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)\n\t\n3. Create a SSH config file (if there is not)\n\n\tlocation ~/.ssh/config\n\tE.g.\n\n\t```\n\t#lowerthan60 account\n\tHost github.com-lowerthan60\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/lowerthan60\n\t\n\t\n\t#foursquarebehind account\n\tHost github.com-foursquarebehind\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/foursquarebehind\n\t```\n\n\n4. Git configuration\nNavigate to the repository configuration file (REPO_INSTALLDIR/.git).\nOpen the config file with your favorite editor.\nLocate the url value in the [remote \"origin\"] section\nchange the HTTPS style URL to git\nE.g.\nFrom :\n```\n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git\n```\n\nTo :\n\t\n```  \n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = git@personalid:newuserme/bb101repo.git\n```\n\t\n5. Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]\n\n\tMay have to re-config the user email and name \n\te.g. :\n\n\t``` \n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"    \n\t```\n\n\tthen add the changes and check in\n\te.g.:\n\n\t```\n\tgit add .\n\tgit commit -m \"update\"\n\tgit push origin master\n\t```\n\n6. A sample script\n\t\n\t```\n\t# my github script\n\tcd ~/.ssh\n\trm id_rsa\n\trm id_rsa.pub\n\trm config\n\t\n\tln git_dhoerl id_rsa\n\tln git_dhoerl.pub id_rsa.pub\n\tln config_dhoerl config\n\t\n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"        \n\t# git config --global github.token \"whatever_it_is\" # now unused\n\t```\n\nNote:\n* generate ssh key for each account and add the key into the account's profile in github.\n* make sure ssh-agent is started.\n* may have to re-config user email and name when switch between github accounts.\n* may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.\n* make sure use the git style repository URL to replace the default HTTPS style URL.\n\nTODO:\n1. create a new post on foursquarebehind.github.io and summarize the steps properly.\n2. try works with multiple git like repositories like bit-bucket and github together. \n \nRefrences:\n* https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\n* https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\n* https://gist.github.com/jexchan/2351996\n* http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\n* http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config","source":"_posts/2016-10-24-Multiple-SSH-Keys-settings-for-different-github-account.md","raw":"---\ntitle: Multiple SSH Keys settings for different github account\ndate: 2016-10-24 11:57:10\ntags:\n- GitHub\n- Tools\n---\n\n## (GitHub-Flavored) Markdown Editor##\n\n1. [Generating a new ssh key and adding it to the ssh agent](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)\n\n\tspecify the key store name\n\n\t```\n \tssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C \"foursquarebehind@gmail.com\"\n\t```\n\n\tNote: have to make sure the ssh daemon is started\n\n\t```\n\teval \"$(ssh-agent -s)\"\n\t```\n\n\n2. [Adding a new ssh key to your github account](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)\n\t\n3. Create a SSH config file (if there is not)\n\n\tlocation ~/.ssh/config\n\tE.g.\n\n\t```\n\t#lowerthan60 account\n\tHost github.com-lowerthan60\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/lowerthan60\n\t\n\t\n\t#foursquarebehind account\n\tHost github.com-foursquarebehind\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/foursquarebehind\n\t```\n\n\n4. Git configuration\nNavigate to the repository configuration file (REPO_INSTALLDIR/.git).\nOpen the config file with your favorite editor.\nLocate the url value in the [remote \"origin\"] section\nchange the HTTPS style URL to git\nE.g.\nFrom :\n```\n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git\n```\n\nTo :\n\t\n```  \n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = git@personalid:newuserme/bb101repo.git\n```\n\t\n5. Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]\n\n\tMay have to re-config the user email and name \n\te.g. :\n\n\t``` \n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"    \n\t```\n\n\tthen add the changes and check in\n\te.g.:\n\n\t```\n\tgit add .\n\tgit commit -m \"update\"\n\tgit push origin master\n\t```\n\n6. A sample script\n\t\n\t```\n\t# my github script\n\tcd ~/.ssh\n\trm id_rsa\n\trm id_rsa.pub\n\trm config\n\t\n\tln git_dhoerl id_rsa\n\tln git_dhoerl.pub id_rsa.pub\n\tln config_dhoerl config\n\t\n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"        \n\t# git config --global github.token \"whatever_it_is\" # now unused\n\t```\n\nNote:\n* generate ssh key for each account and add the key into the account's profile in github.\n* make sure ssh-agent is started.\n* may have to re-config user email and name when switch between github accounts.\n* may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.\n* make sure use the git style repository URL to replace the default HTTPS style URL.\n\nTODO:\n1. create a new post on foursquarebehind.github.io and summarize the steps properly.\n2. try works with multiple git like repositories like bit-bucket and github together. \n \nRefrences:\n* https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\n* https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\n* https://gist.github.com/jexchan/2351996\n* http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\n* http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config","slug":"Multiple-SSH-Keys-settings-for-different-github-account","published":1,"updated":"2016-11-15T21:13:11.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xe5000dmclsvijktbvp","content":"<h2 id=\"GitHub-Flavored-Markdown-Editor\"><a href=\"#GitHub-Flavored-Markdown-Editor\" class=\"headerlink\" title=\"(GitHub-Flavored) Markdown Editor\"></a>(GitHub-Flavored) Markdown Editor</h2><ol>\n<li><p><a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\" target=\"_blank\" rel=\"external\">Generating a new ssh key and adding it to the ssh agent</a></p>\n<p> specify the key store name</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C &quot;foursquarebehind@gmail.com&quot;</div></pre></td></tr></table></figure>\n<p> Note: have to make sure the ssh daemon is started</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eval &quot;$(ssh-agent -s)&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\" target=\"_blank\" rel=\"external\">Adding a new ssh key to your github account</a></p>\n</li>\n<li><p>Create a SSH config file (if there is not)</p>\n<p> location ~/.ssh/config<br> E.g.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#lowerthan60 account</div><div class=\"line\">Host github.com-lowerthan60</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/lowerthan60</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#foursquarebehind account</div><div class=\"line\">Host github.com-foursquarebehind</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/foursquarebehind</div></pre></td></tr></table></figure>\n</li>\n<li><p>Git configuration<br>Navigate to the repository configuration file (REPO_INSTALLDIR/.git).<br>Open the config file with your favorite editor.<br>Locate the url value in the [remote “origin”] section<br>change the HTTPS style URL to git<br>E.g.<br>From :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>To :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = git@personalid:newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n<ol>\n<li><p>Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]</p>\n<p> May have to re-config the user email and name<br> e.g. :</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;</div></pre></td></tr></table></figure>\n<p> then add the changes and check in<br> e.g.:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;update&quot;</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n</li>\n<li><p>A sample script</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"># my github script</div><div class=\"line\">cd ~/.ssh</div><div class=\"line\">rm id_rsa</div><div class=\"line\">rm id_rsa.pub</div><div class=\"line\">rm config</div><div class=\"line\"></div><div class=\"line\">ln git_dhoerl id_rsa</div><div class=\"line\">ln git_dhoerl.pub id_rsa.pub</div><div class=\"line\">ln config_dhoerl config</div><div class=\"line\"></div><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;        </div><div class=\"line\"># git config --global github.token &quot;whatever_it_is&quot; # now unused</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Note:</p>\n<ul>\n<li>generate ssh key for each account and add the key into the account’s profile in github.</li>\n<li>make sure ssh-agent is started.</li>\n<li>may have to re-config user email and name when switch between github accounts.</li>\n<li>may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.</li>\n<li>make sure use the git style repository URL to replace the default HTTPS style URL.</li>\n</ul>\n<p>TODO:</p>\n<ol>\n<li>create a new post on foursquarebehind.github.io and summarize the steps properly.</li>\n<li>try works with multiple git like repositories like bit-bucket and github together. </li>\n</ol>\n<p>Refrences:</p>\n<ul>\n<li><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\" target=\"_blank\" rel=\"external\">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a></li>\n<li><a href=\"https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\" target=\"_blank\" rel=\"external\">https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html</a></li>\n<li><a href=\"https://gist.github.com/jexchan/2351996\" target=\"_blank\" rel=\"external\">https://gist.github.com/jexchan/2351996</a></li>\n<li><a href=\"http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"GitHub-Flavored-Markdown-Editor\"><a href=\"#GitHub-Flavored-Markdown-Editor\" class=\"headerlink\" title=\"(GitHub-Flavored) Markdown Editor\"></a>(GitHub-Flavored) Markdown Editor</h2><ol>\n<li><p><a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\">Generating a new ssh key and adding it to the ssh agent</a></p>\n<p> specify the key store name</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C &quot;foursquarebehind@gmail.com&quot;</div></pre></td></tr></table></figure>\n<p> Note: have to make sure the ssh daemon is started</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eval &quot;$(ssh-agent -s)&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\">Adding a new ssh key to your github account</a></p>\n</li>\n<li><p>Create a SSH config file (if there is not)</p>\n<p> location ~/.ssh/config<br> E.g.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#lowerthan60 account</div><div class=\"line\">Host github.com-lowerthan60</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/lowerthan60</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#foursquarebehind account</div><div class=\"line\">Host github.com-foursquarebehind</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/foursquarebehind</div></pre></td></tr></table></figure>\n</li>\n<li><p>Git configuration<br>Navigate to the repository configuration file (REPO_INSTALLDIR/.git).<br>Open the config file with your favorite editor.<br>Locate the url value in the [remote “origin”] section<br>change the HTTPS style URL to git<br>E.g.<br>From :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>To :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = git@personalid:newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n<ol>\n<li><p>Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]</p>\n<p> May have to re-config the user email and name<br> e.g. :</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;</div></pre></td></tr></table></figure>\n<p> then add the changes and check in<br> e.g.:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;update&quot;</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n</li>\n<li><p>A sample script</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"># my github script</div><div class=\"line\">cd ~/.ssh</div><div class=\"line\">rm id_rsa</div><div class=\"line\">rm id_rsa.pub</div><div class=\"line\">rm config</div><div class=\"line\"></div><div class=\"line\">ln git_dhoerl id_rsa</div><div class=\"line\">ln git_dhoerl.pub id_rsa.pub</div><div class=\"line\">ln config_dhoerl config</div><div class=\"line\"></div><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;        </div><div class=\"line\"># git config --global github.token &quot;whatever_it_is&quot; # now unused</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Note:</p>\n<ul>\n<li>generate ssh key for each account and add the key into the account’s profile in github.</li>\n<li>make sure ssh-agent is started.</li>\n<li>may have to re-config user email and name when switch between github accounts.</li>\n<li>may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.</li>\n<li>make sure use the git style repository URL to replace the default HTTPS style URL.</li>\n</ul>\n<p>TODO:</p>\n<ol>\n<li>create a new post on foursquarebehind.github.io and summarize the steps properly.</li>\n<li>try works with multiple git like repositories like bit-bucket and github together. </li>\n</ol>\n<p>Refrences:</p>\n<ul>\n<li><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a></li>\n<li><a href=\"https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\">https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html</a></li>\n<li><a href=\"https://gist.github.com/jexchan/2351996\">https://gist.github.com/jexchan/2351996</a></li>\n<li><a href=\"http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\">http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config\">http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config</a></li>\n</ul>\n"},{"title":"Most Beautiful Mathematical Equations","date":"2016-11-08T21:23:17.000Z","_content":"Mass–energy equivalence\n$$\nE=mc^2\n$$\n\nEuler's equation\n$$\ne^{i\\pi} + 1 = 0\n$$\n\nPythagorean theorem\n$$\na^2 + b^2 = c^2\n$$\n\n","source":"_posts/2016-11-08-Most-Beautiful-Mathematical-Equations.md","raw":"---\ntitle: Most Beautiful Mathematical Equations\ndate: 2016-11-08 16:23:17\ntags:\n\tMath\n---\nMass–energy equivalence\n$$\nE=mc^2\n$$\n\nEuler's equation\n$$\ne^{i\\pi} + 1 = 0\n$$\n\nPythagorean theorem\n$$\na^2 + b^2 = c^2\n$$\n\n","slug":"Most-Beautiful-Mathematical-Equations","published":1,"updated":"2016-11-15T21:13:11.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xe5000fmcls3l64sqe2","content":"<p>Mass–energy equivalence<br>$$<br>E=mc^2<br>$$</p>\n<p>Euler’s equation<br>$$<br>e^{i\\pi} + 1 = 0<br>$$</p>\n<p>Pythagorean theorem<br>$$<br>a^2 + b^2 = c^2<br>$$</p>\n","excerpt":"","more":"<p>Mass–energy equivalence<br>$$<br>E=mc^2<br>$$</p>\n<p>Euler’s equation<br>$$<br>e^{i\\pi} + 1 = 0<br>$$</p>\n<p>Pythagorean theorem<br>$$<br>a^2 + b^2 = c^2<br>$$</p>\n"},{"title":"Tree Properties","_content":"\n\n* **Depth**: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree's root node. A root node will have a depth of 0.\n* **Height**: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.\n* **Degree**: The number of children emanating from a given node is referred to as its degree.\n* **Diameter (or width)** of a tree is the number of nodes on the longest path between any two leaf nodes. \n\nE.g. In Figure 1, the tree has a height of 3, node **G** has a depth of 2, node **A** has a degree of 3 and node **H** has a degree of 1. In Figure 2, the tree has a **diameter** of 6 nodes.\n\n| &nbsp; | &nbsp; |\n| :---   | ---:   | \n| {% asset_img tree_properties_1.jpg \"Figure 1\" \"A tree \"%} | {% asset_img tree_height_depth.png \"Figure 2\" \"Tree height and depth \"%} |\n\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn Binary Tree, **Inorder Successor** of a node is the next node in Inorder traversal of the Binary Tree. **Inorder Successor** is NULL for the last node in Inoorder traversal. \nIn Binary Search Tree, **Inorder Successor** of an input node can also be defined as the node with the smallest key greater than the key of input node.\n\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n| **Q**        | **How can you find successors and predecessors in a binary search tree in order?** |\n| :---         | :--- \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  |\n| **Case 1**   | **The node has a right subtree**                                                   |\n| &nbsp;       | _If the given node has a right subtree then by the BST property the next larger key must be in the right subtree._ |\n| &nbsp;       | _Since all keys in a right subtree are larger than the key of the given node, the successor must be the smallest of all those keys in the right subtree._ |\n| **Case 2**   | **The node does not have a right subtree**                                         |\n| &nbsp;       | _In this case we will have to look up the tree since that's the only place we might find the next larger key._ | \n| &nbsp;       | _There is no point looking at the left subtree as all keys in the left subtree are guaranteed to be smaller than the key in the given tree._ |\n| &nbsp;       | _When we look up from the given node, there can be two cases:_                     |\n| **Case 2.1** | _The current node is the left child of its parent. In this case the parent is the successor node. This is because the parent always comes next in inorder traversal if you are done with left subtree (rooted at the current node)._ |\n| **Case 2.2** | _The current node is the right child of the parent. This is an interesting case. In this case, as you keep going up the ancestor chain you encounter smaller values if you are going up but larger values if you are going right. The successor node will be the first node up the ancestor chain that you encounter on the right chain._ |\n\n##### References ######\n* http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\n* https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/","source":"_posts/2016-11-15-Tree-Properties.md","raw":"---\ntitle: Tree Properties\ntags:\n- Algorithm\n- Tree\n---\n\n\n* **Depth**: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree's root node. A root node will have a depth of 0.\n* **Height**: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.\n* **Degree**: The number of children emanating from a given node is referred to as its degree.\n* **Diameter (or width)** of a tree is the number of nodes on the longest path between any two leaf nodes. \n\nE.g. In Figure 1, the tree has a height of 3, node **G** has a depth of 2, node **A** has a degree of 3 and node **H** has a degree of 1. In Figure 2, the tree has a **diameter** of 6 nodes.\n\n| &nbsp; | &nbsp; |\n| :---   | ---:   | \n| {% asset_img tree_properties_1.jpg \"Figure 1\" \"A tree \"%} | {% asset_img tree_height_depth.png \"Figure 2\" \"Tree height and depth \"%} |\n\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nIn Binary Tree, **Inorder Successor** of a node is the next node in Inorder traversal of the Binary Tree. **Inorder Successor** is NULL for the last node in Inoorder traversal. \nIn Binary Search Tree, **Inorder Successor** of an input node can also be defined as the node with the smallest key greater than the key of input node.\n\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n| **Q**        | **How can you find successors and predecessors in a binary search tree in order?** |\n| :---         | :--- \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  |\n| **Case 1**   | **The node has a right subtree**                                                   |\n| &nbsp;       | _If the given node has a right subtree then by the BST property the next larger key must be in the right subtree._ |\n| &nbsp;       | _Since all keys in a right subtree are larger than the key of the given node, the successor must be the smallest of all those keys in the right subtree._ |\n| **Case 2**   | **The node does not have a right subtree**                                         |\n| &nbsp;       | _In this case we will have to look up the tree since that's the only place we might find the next larger key._ | \n| &nbsp;       | _There is no point looking at the left subtree as all keys in the left subtree are guaranteed to be smaller than the key in the given tree._ |\n| &nbsp;       | _When we look up from the given node, there can be two cases:_                     |\n| **Case 2.1** | _The current node is the left child of its parent. In this case the parent is the successor node. This is because the parent always comes next in inorder traversal if you are done with left subtree (rooted at the current node)._ |\n| **Case 2.2** | _The current node is the right child of the parent. This is an interesting case. In this case, as you keep going up the ancestor chain you encounter smaller values if you are going up but larger values if you are going right. The successor node will be the first node up the ancestor chain that you encounter on the right chain._ |\n\n##### References ######\n* http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\n* https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/","slug":"Tree-Properties","published":1,"date":"2016-11-15T05:00:00.000Z","updated":"2016-11-30T21:21:29.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciy3d4xf00011mclsre4s1lmf","content":"<ul>\n<li><strong>Depth</strong>: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree’s root node. A root node will have a depth of 0.</li>\n<li><strong>Height</strong>: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.</li>\n<li><strong>Degree</strong>: The number of children emanating from a given node is referred to as its degree.</li>\n<li><strong>Diameter (or width)</strong> of a tree is the number of nodes on the longest path between any two leaf nodes. </li>\n</ul>\n<p>E.g. In Figure 1, the tree has a height of 3, node <strong>G</strong> has a depth of 2, node <strong>A</strong> has a degree of 3 and node <strong>H</strong> has a degree of 1. In Figure 2, the tree has a <strong>diameter</strong> of 6 nodes.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_properties_1.jpg\" alt=\"Figure 1 A tree\" title=\"Figure 1 A tree\"></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_height_depth.png\" alt=\"Figure 2 Tree height and depth\" title=\"Figure 2 Tree height and depth\"></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>In Binary Tree, <strong>Inorder Successor</strong> of a node is the next node in Inorder traversal of the Binary Tree. <strong>Inorder Successor</strong> is NULL for the last node in Inoorder traversal.<br>In Binary Search Tree, <strong>Inorder Successor</strong> of an input node can also be defined as the node with the smallest key greater than the key of input node.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Q</strong></th>\n<th style=\"text-align:left\"><strong>How can you find successors and predecessors in a binary search tree in order?</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>Case 1</strong></td>\n<td style=\"text-align:left\"><strong>The node has a right subtree</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>If the given node has a right subtree then by the BST property the next larger key must be in the right subtree.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>Since all keys in a right subtree are larger than the key of the given node, the successor must be the smallest of all those keys in the right subtree.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2</strong></td>\n<td style=\"text-align:left\"><strong>The node does not have a right subtree</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>In this case we will have to look up the tree since that’s the only place we might find the next larger key.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>There is no point looking at the left subtree as all keys in the left subtree are guaranteed to be smaller than the key in the given tree.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>When we look up from the given node, there can be two cases:</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2.1</strong></td>\n<td style=\"text-align:left\"><em>The current node is the left child of its parent. In this case the parent is the successor node. This is because the parent always comes next in inorder traversal if you are done with left subtree (rooted at the current node).</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2.2</strong></td>\n<td style=\"text-align:left\"><em>The current node is the right child of the parent. This is an interesting case. In this case, as you keep going up the ancestor chain you encounter smaller values if you are going up but larger values if you are going right. The successor node will be the first node up the ancestor chain that you encounter on the right chain.</em></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h5><ul>\n<li><a href=\"http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height</a></li>\n<li><a href=\"https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/\" target=\"_blank\" rel=\"external\">https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/</a></li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><strong>Depth</strong>: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree’s root node. A root node will have a depth of 0.</li>\n<li><strong>Height</strong>: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.</li>\n<li><strong>Degree</strong>: The number of children emanating from a given node is referred to as its degree.</li>\n<li><strong>Diameter (or width)</strong> of a tree is the number of nodes on the longest path between any two leaf nodes. </li>\n</ul>\n<p>E.g. In Figure 1, the tree has a height of 3, node <strong>G</strong> has a depth of 2, node <strong>A</strong> has a degree of 3 and node <strong>H</strong> has a degree of 1. In Figure 2, the tree has a <strong>diameter</strong> of 6 nodes.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_properties_1.jpg\" alt=\"Figure 1 A tree\" title=\"Figure 1 A tree\"></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_height_depth.png\" alt=\"Figure 2 Tree height and depth\" title=\"Figure 2 Tree height and depth\"></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>In Binary Tree, <strong>Inorder Successor</strong> of a node is the next node in Inorder traversal of the Binary Tree. <strong>Inorder Successor</strong> is NULL for the last node in Inoorder traversal.<br>In Binary Search Tree, <strong>Inorder Successor</strong> of an input node can also be defined as the node with the smallest key greater than the key of input node.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>Q</strong></th>\n<th style=\"text-align:left\"><strong>How can you find successors and predecessors in a binary search tree in order?</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>Case 1</strong></td>\n<td style=\"text-align:left\"><strong>The node has a right subtree</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>If the given node has a right subtree then by the BST property the next larger key must be in the right subtree.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>Since all keys in a right subtree are larger than the key of the given node, the successor must be the smallest of all those keys in the right subtree.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2</strong></td>\n<td style=\"text-align:left\"><strong>The node does not have a right subtree</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>In this case we will have to look up the tree since that’s the only place we might find the next larger key.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>There is no point looking at the left subtree as all keys in the left subtree are guaranteed to be smaller than the key in the given tree.</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:left\"><em>When we look up from the given node, there can be two cases:</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2.1</strong></td>\n<td style=\"text-align:left\"><em>The current node is the left child of its parent. In this case the parent is the successor node. This is because the parent always comes next in inorder traversal if you are done with left subtree (rooted at the current node).</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Case 2.2</strong></td>\n<td style=\"text-align:left\"><em>The current node is the right child of the parent. This is an interesting case. In this case, as you keep going up the ancestor chain you encounter smaller values if you are going up but larger values if you are going right. The successor node will be the first node up the ancestor chain that you encounter on the right chain.</em></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h5><ul>\n<li><a href=\"http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\">http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height</a></li>\n<li><a href=\"https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/\">https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_drafts/2016-10-27-t/red_black_tree_1.png","slug":"red_black_tree_1.png","post":"ciy3d4xcu0001mclsij1u01r6","modified":0,"renderable":0},{"_id":"source/_drafts/red-black-tree/rbt_1.jpg","slug":"rbt_1.jpg","post":"ciy3d4xcu0002mclscnyi2o1f","modified":0,"renderable":0},{"_id":"source/_drafts/red-black-tree/rbt_left_rotation_1.jpg","slug":"rbt_left_rotation_1.jpg","post":"ciy3d4xcu0002mclscnyi2o1f","modified":0,"renderable":0},{"_id":"source/_drafts/red-black-tree/rbt_right_rotation_1.jpg","slug":"rbt_right_rotation_1.jpg","post":"ciy3d4xcu0002mclscnyi2o1f","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree1.gif","slug":"min_tree1.gif","post":"ciy3d4xdp0007mcls8qjnyt7d","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree2.gif","slug":"min_tree2.gif","post":"ciy3d4xdp0007mcls8qjnyt7d","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree3.gif","slug":"min_tree3.gif","post":"ciy3d4xdp0007mcls8qjnyt7d","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_1.png","slug":"rbt_deletion_case_1.png","post":"ciy3d4xdp0009mclshjf9f7qh","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_2.png","slug":"rbt_deletion_case_2.png","post":"ciy3d4xdp0009mclshjf9f7qh","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_3.png","slug":"rbt_deletion_case_3.png","post":"ciy3d4xdp0009mclshjf9f7qh","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Deletion/rbt_deletion_case_4.png","slug":"rbt_deletion_case_4.png","post":"ciy3d4xdp0009mclshjf9f7qh","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_1.jpg","slug":"rbt_1.jpg","post":"ciy3d4xdp0006mclsh19ywdzn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_invertible_rotation.png","slug":"rbt_invertible_rotation.png","post":"ciy3d4xdp0006mclsh19ywdzn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_left_rotation_1.jpg","slug":"rbt_left_rotation_1.jpg","post":"ciy3d4xdp0006mclsh19ywdzn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_left_rotation_example_1.png","slug":"rbt_left_rotation_example_1.png","post":"ciy3d4xdp0006mclsh19ywdzn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_right_rotation_1.jpg","slug":"rbt_right_rotation_1.jpg","post":"ciy3d4xdp0006mclsh19ywdzn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_right_rotation_example_1.png","slug":"rbt_right_rotation_example_1.png","post":"ciy3d4xdp0006mclsh19ywdzn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_1.jpg","slug":"rbt_insertion_1.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_2.jpg","slug":"rbt_insertion_2.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_3.jpg","slug":"rbt_insertion_3.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_4.jpg","slug":"rbt_insertion_4.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_5.jpg","slug":"rbt_insertion_5.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_6.jpg","slug":"rbt_insertion_6.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_7.jpg","slug":"rbt_insertion_7.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_1.jpg","slug":"rbt_insertion_case_1.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_1_full.jpg","slug":"rbt_insertion_case_1_full.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_2.jpg","slug":"rbt_insertion_case_2.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_2_full.jpg","slug":"rbt_insertion_case_2_full.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_case_3_full.jpg","slug":"rbt_insertion_case_3_full.jpg","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_1.png","slug":"rbt_insertion_complete_1.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_2.png","slug":"rbt_insertion_complete_2.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_3.png","slug":"rbt_insertion_complete_3.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_4.png","slug":"rbt_insertion_complete_4.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_5.png","slug":"rbt_insertion_complete_5.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_6.png","slug":"rbt_insertion_complete_6.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_7.png","slug":"rbt_insertion_complete_7.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-29-Red-Black-Tree-Insertion/rbt_insertion_complete_8.png","slug":"rbt_insertion_complete_8.png","post":"ciy3d4xe5000amcls0r694isn","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_height_depth.png","slug":"tree_height_depth.png","post":"ciy3d4xf00011mclsre4s1lmf","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_properties_1.jpg","slug":"tree_properties_1.jpg","post":"ciy3d4xf00011mclsre4s1lmf","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ciy3d4xdp0009mclshjf9f7qh","tag_id":"ciy3d4xda0004mcls7nd0tp6d","_id":"ciy3d4xe5000cmclsjwgzhvgx"},{"post_id":"ciy3d4xdp0009mclshjf9f7qh","tag_id":"ciy3d4xdp0008mclsfv4tw1sc","_id":"ciy3d4xe5000emclsi9ws226n"},{"post_id":"ciy3d4xcu0002mclscnyi2o1f","tag_id":"ciy3d4xda0004mcls7nd0tp6d","_id":"ciy3d4xek000hmcls9qz9vxca"},{"post_id":"ciy3d4xcu0002mclscnyi2o1f","tag_id":"ciy3d4xdp0008mclsfv4tw1sc","_id":"ciy3d4xek000imclsjf0t1jyb"},{"post_id":"ciy3d4xe5000amcls0r694isn","tag_id":"ciy3d4xda0004mcls7nd0tp6d","_id":"ciy3d4xek000jmclsg93iv8wn"},{"post_id":"ciy3d4xe5000amcls0r694isn","tag_id":"ciy3d4xdp0008mclsfv4tw1sc","_id":"ciy3d4xek000lmcls873kb3xl"},{"post_id":"ciy3d4xda0003mcls25nteffe","tag_id":"ciy3d4xe5000bmclsrdhx5w33","_id":"ciy3d4xek000mmclsqdri2uxw"},{"post_id":"ciy3d4xda0003mcls25nteffe","tag_id":"ciy3d4xek000gmcls8r5fgu20","_id":"ciy3d4xek000omcls5y5gcfnc"},{"post_id":"ciy3d4xda0005mclsh7w80fmq","tag_id":"ciy3d4xek000kmclstju33oht","_id":"ciy3d4xek000pmclskjceusy9"},{"post_id":"ciy3d4xdp0006mclsh19ywdzn","tag_id":"ciy3d4xda0004mcls7nd0tp6d","_id":"ciy3d4xek000rmclshrw21era"},{"post_id":"ciy3d4xdp0006mclsh19ywdzn","tag_id":"ciy3d4xdp0008mclsfv4tw1sc","_id":"ciy3d4xek000smcls303xslvh"},{"post_id":"ciy3d4xdp0007mcls8qjnyt7d","tag_id":"ciy3d4xda0004mcls7nd0tp6d","_id":"ciy3d4xek000umclsgdtpn9sr"},{"post_id":"ciy3d4xdp0007mcls8qjnyt7d","tag_id":"ciy3d4xdp0008mclsfv4tw1sc","_id":"ciy3d4xek000vmclsevf4xxog"},{"post_id":"ciy3d4xe5000dmclsvijktbvp","tag_id":"ciy3d4xek000gmcls8r5fgu20","_id":"ciy3d4xek000ymcls5aoyq9og"},{"post_id":"ciy3d4xe5000dmclsvijktbvp","tag_id":"ciy3d4xek000wmclsyaqny7ai","_id":"ciy3d4xek000zmclsd00o3fep"},{"post_id":"ciy3d4xe5000fmcls3l64sqe2","tag_id":"ciy3d4xek000xmclst2l181wd","_id":"ciy3d4xek0010mclstmlfelzs"},{"post_id":"ciy3d4xf00011mclsre4s1lmf","tag_id":"ciy3d4xda0004mcls7nd0tp6d","_id":"ciy3d4xfg0012mclsmebebcxr"},{"post_id":"ciy3d4xf00011mclsre4s1lmf","tag_id":"ciy3d4xdp0008mclsfv4tw1sc","_id":"ciy3d4xfg0013mclsalca5bsw"}],"Tag":[{"name":"Algorithm","_id":"ciy3d4xda0004mcls7nd0tp6d"},{"name":"Tree","_id":"ciy3d4xdp0008mclsfv4tw1sc"},{"name":"Hexo","_id":"ciy3d4xe5000bmclsrdhx5w33"},{"name":"GitHub","_id":"ciy3d4xek000gmcls8r5fgu20"},{"name":"随笔","_id":"ciy3d4xek000kmclstju33oht"},{"name":"Tools","_id":"ciy3d4xek000wmclsyaqny7ai"},{"name":"Math","_id":"ciy3d4xek000xmclst2l181wd"}]}}