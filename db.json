{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1479244391071},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1479244391074},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1479244391075},{"_id":"themes/landscape/README.md","hash":"e7cc82dc79596f36ba05a8139e7d6b2dfc4ae5f9","modified":1479244391080},{"_id":"themes/landscape/_config.yml","hash":"218c5fb76666696c42dc86e2de4711e6b80befbf","modified":1479244391083},{"_id":"themes/landscape/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1479244391258},{"_id":"source/_drafts/2016-10-27-t.md","hash":"f9cfdc5ff574c8f6d816983cef09f474f0f4b8fe","modified":1479244391031},{"_id":"source/_drafts/red-black-tree.md","hash":"69cfb540bb94dab1fdbcbf2d8725e39dd2e26082","modified":1479330232979},{"_id":"source/_posts/2016-10-21-How-to-work-with-hexo-and-git-pages.md","hash":"0b6ed6e6fb92e3685b2fde045a0284046274fb7a","modified":1479484508597},{"_id":"source/_posts/2016-10-21-zhi-xi.md","hash":"44bacecee935499091485bb4dc75e18f4df66312","modified":1479244391044},{"_id":"source/_posts/2016-10-24-Multiple-SSH-Keys-settings-for-different-github-account.md","hash":"fdafdcb6c7b74a0164ae7a7c4ad1dc2e08e98588","modified":1479244391048},{"_id":"source/_posts/2016-11-08-Most-Beautiful-Mathematical-Equations.md","hash":"1d3f989db8e9430a95bcd6db74ee1f9938464ab9","modified":1479244391051},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree.md","hash":"4d9cb391328b6e9b9f722975d0d8e21155e393df","modified":1479244391055},{"_id":"source/_posts/2016-11-15-Tree-Properties.md","hash":"6953ffceda1f1c14d42761e0c5e134624f5f9d24","modified":1479332658039},{"_id":"source/_posts/2016-11-16-Red-Black-Tree.md","hash":"8346413cfee88130ea52e7923398f02a7a478377","modified":1479746552994},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1479244391086},{"_id":"themes/landscape/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1479244391090},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1479244391093},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1479244391096},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1479244391099},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1479244391103},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1479244391106},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1479244391228},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1479244391231},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1479244391235},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1479244391248},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1479244391251},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1479244391252},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1479244391255},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1479244391263},{"_id":"source/_drafts/tt.md","hash":"75211b4260bf38b9d8eeb24ffcd4f64d71552146","modified":1479244391036},{"_id":"source/_drafts/2016-10-27-t/red_black_tree_1.png","hash":"fa0ee9e6903fe99520a3d6fe18a2ee6f0b91b8fa","modified":1479244391033},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree1.gif","hash":"b23678ef1fec541524159c36c0c5f75114871a7a","modified":1479244391057},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree2.gif","hash":"09bb25f2d9cb00ac87604a3a1777b14c3e224510","modified":1479244391057},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree3.gif","hash":"de92991eaee9177cc072556bc75781cd3eb2b92d","modified":1479244391059},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_height_depth.png","hash":"6dd8e498d9a9410c775f1d9f7bd350fc371fa3c8","modified":1479244391063},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_properties_1.jpg","hash":"09e50f776a3570494a497cc2330d9a205bfecf82","modified":1479332617753},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"a7faab4f3601b28107af5b1095b3966c2f88fec8","modified":1479244391108},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1479244391111},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"3beb0d164acacb6f21e1ca2038158a74ab4a73e4","modified":1479244391122},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1479244391133},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1479244391138},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1479244391146},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"89998e6b2929c4ff5093bbf6b86d611d7420be52","modified":1479244391154},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"148bdf714dd1a7bf55e571f13808ceae079200cc","modified":1479244391160},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1479244391163},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1479244391201},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1479244391206},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1479244391212},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1479244391217},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1479244391222},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1479244391225},{"_id":"source/_drafts/red-black-tree/rbt_1.jpg","hash":"2911a019c6a632243ffb6722a097fbbc145c5ac3","modified":1479313676445},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1479244391267},{"_id":"themes/landscape/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1479244391322},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1479244391374},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1479244391375},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1479244391376},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1479244391378},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1479244391379},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1479244391380},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1479244391381},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1479244391421},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1479244391434},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1479244391449},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1479244391461},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_1.jpg","hash":"2911a019c6a632243ffb6722a097fbbc145c5ac3","modified":1479313676445},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1479244391170},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1479244391174},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1479244391180},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1479244391184},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1479244391191},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1479244391194},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1479244391271},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1479244391277},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1479244391280},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1479244391283},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1479244391287},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1479244391293},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1479244391296},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1479244391300},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1479244391303},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1479244391306},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1479244391312},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1479244391317},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1479244391329},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1479244391343},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1479244391364},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1479244391382},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1479244391385},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1479244391395},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1479244391403},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1479244391406},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1479244391417},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1479244391359},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1479244391352},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1479244391370},{"_id":"source/_drafts/red-black-tree/rbt_left_rotation_1.jpg","hash":"a34869bbd41d638b27f84f2af6c6587ae9977bb9","modified":1479415983780},{"_id":"source/_drafts/red-black-tree/rbt_right_rotation_1.jpg","hash":"29559a30506e83bc8df5dffa941a317056d6cbbd","modified":1479415996959},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_left_rotation_1.jpg","hash":"49d85050b3bfce71707346bb7724840fb0b38c1b","modified":1479416356516},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_right_rotation_1.jpg","hash":"1ccac37948f03661a96695479bb5bb463f3692f0","modified":1479416346699}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"t","date":"2016-10-27T13:53:12.000Z","_content":"\n{% asset_img red_black_tree_1.png Red-Black Tree%}","source":"_drafts/2016-10-27-t.md","raw":"---\ntitle: t\ndate: 2016-10-27 09:53:12\ntags:\n---\n\n{% asset_img red_black_tree_1.png Red-Black Tree%}","slug":"t","published":0,"updated":"2016-11-15T21:13:11.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civlf2t150000golsnaf65omr","content":"<img src=\"/archive/2016/10/27/t/red_black_tree_1.png\" alt=\"Red-Black Tree\" title=\"Red-Black Tree\">","excerpt":"","more":"<img src=\"/archive/2016/10/27/t/red_black_tree_1.png\" alt=\"Red-Black Tree\" title=\"Red-Black Tree\">"},{"title":"Red-Black Tree","_content":"\n### Preface ###\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Introduction ###\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n### Properties ###\n1. Every node is colored with either red or black;\n2. All leaf (NULL Pointer) nodes are colored with black; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black._\n3. Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**). We call this number the **black height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a red node must be black nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always black.\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Application of Red-Black Tree ###\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | Black height of the tree;                         |\n| $bh(x)$       | Black height of the node $x$;                     |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 3<sub>rd</sub> property above as each red node strictly requires black children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Theorem ### \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n### Proof by induction ###\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is __black height__ of the node $x$, or $x$'s __black height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sub>rd</sub> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sub>th</sub> **Red-Black Tree** properties, \"Both children of a red node must be black nodes\", we can say starting from the node x to leaf node, the number of black nodes >= the number the red nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __black height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n","source":"_drafts/red-black-tree.md","raw":"---\ntitle: Red-Black Tree\ntags:\n- Algorithm\n- Tree\n---\n\n### Preface ###\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Introduction ###\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n### Properties ###\n1. Every node is colored with either red or black;\n2. All leaf (NULL Pointer) nodes are colored with black; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black._\n3. Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**). We call this number the **black height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a red node must be black nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always black.\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Application of Red-Black Tree ###\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | Black height of the tree;                         |\n| $bh(x)$       | Black height of the node $x$;                     |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 3<sub>rd</sub> property above as each red node strictly requires black children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Theorem ### \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n### Proof by induction ###\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is __black height__ of the node $x$, or $x$'s __black height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sub>rd</sub> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sub>th</sub> **Red-Black Tree** properties, \"Both children of a red node must be black nodes\", we can say starting from the node x to leaf node, the number of black nodes >= the number the red nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __black height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n","slug":"red-black-tree","published":0,"date":"2016-11-15T21:13:39.963Z","updated":"2016-11-16T21:03:52.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civlf2t1d0001golsswk63flv","content":"<h3 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h3><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either red or black;</li>\n<li>All leaf (NULL Pointer) nodes are colored with black;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>black height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a red node must be black nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always black.</li>\n</ol>\n<img src=\"/archive/2016/11/15/red-black-tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h3 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h3><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\">Black height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\">Black height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 3<sub>rd</sub> property above as each red node strictly requires black children</em>)</p>\n<hr>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h3 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h3><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is <strong>black height</strong> of the node $x$, or $x$’s <strong>black height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sub>rd</sub> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sub>th</sub> <strong>Red-Black Tree</strong> properties, “Both children of a red node must be black nodes”, we can say starting from the node x to leaf node, the number of black nodes &gt;= the number the red nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>black height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n","excerpt":"","more":"<h3 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h3><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either red or black;</li>\n<li>All leaf (NULL Pointer) nodes are colored with black;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>black height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a red node must be black nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always black.</li>\n</ol>\n<img src=\"/archive/2016/11/15/red-black-tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h3 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h3><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\">Black height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\">Black height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 3<sub>rd</sub> property above as each red node strictly requires black children</em>)</p>\n<hr>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h3 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h3><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is <strong>black height</strong> of the node $x$, or $x$’s <strong>black height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sub>rd</sub> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sub>th</sub> <strong>Red-Black Tree</strong> properties, “Both children of a red node must be black nodes”, we can say starting from the node x to leaf node, the number of black nodes &gt;= the number the red nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>black height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n"},{"title":"How to work with hexo and git pages","date":"2016-10-21T19:20:56.000Z","_content":"\n### 安装Hexo ###\n```\ncd d:/hexo\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo g # 或者hexo generate\nhexo s # 或者hexo server，可以在http://localhost:4000/ 查看\n```\n\n这里有必要提下Hexo常用的几个命令：\nhexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\nhexo server (hexo s) 启动本地web服务，用于博客的预览\nhexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）\n另外还有其他几个常用命令：\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\n```\n\n### 常用简写 ###\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n### 常用组合 ###\n```\nhexo d -g #生成部署\nhexo s -g #生成预览\n```\n\n\n\n### 使用git命令行部署 ###\n\nclone github repo\n```\ncd d:/hexo/blog\ngit clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io\n```\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。\n创建一个deploy脚本文件\n\n```\nhexo generate\ncp -R public/* .deploy/foursquarebehind.github.io\ncd .deploy/foursquarebehind.github.io\ngit add .\ngit commit -m “update”\ngit push origin master\n```\n\n简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。\n需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。\n\n\nto be continued...","source":"_posts/2016-10-21-How-to-work-with-hexo-and-git-pages.md","raw":"---\ntitle: How to work with hexo and git pages\ndate: 2016-10-21 15:20:56\ntags:\n- Hexo\n- GitHub\n---\n\n### 安装Hexo ###\n```\ncd d:/hexo\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo g # 或者hexo generate\nhexo s # 或者hexo server，可以在http://localhost:4000/ 查看\n```\n\n这里有必要提下Hexo常用的几个命令：\nhexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\nhexo server (hexo s) 启动本地web服务，用于博客的预览\nhexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）\n另外还有其他几个常用命令：\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\n```\n\n### 常用简写 ###\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n### 常用组合 ###\n```\nhexo d -g #生成部署\nhexo s -g #生成预览\n```\n\n\n\n### 使用git命令行部署 ###\n\nclone github repo\n```\ncd d:/hexo/blog\ngit clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io\n```\n\n将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。\n创建一个deploy脚本文件\n\n```\nhexo generate\ncp -R public/* .deploy/foursquarebehind.github.io\ncd .deploy/foursquarebehind.github.io\ngit add .\ngit commit -m “update”\ngit push origin master\n```\n\n简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。\n需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。\n\n\nto be continued...","slug":"How-to-work-with-hexo-and-git-pages","published":1,"updated":"2016-11-18T15:55:08.597Z","_id":"civlf2t1h0002golsp1lt42ya","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo</div><div class=\"line\">npm install hexo-cli -g</div><div class=\"line\">hexo init blog</div><div class=\"line\">cd blog</div><div class=\"line\">npm install</div><div class=\"line\">hexo g # 或者hexo generate</div><div class=\"line\">hexo s # 或者hexo server，可以在http://localhost:4000/ 查看</div></pre></td></tr></table></figure>\n<p>这里有必要提下Hexo常用的几个命令：<br>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹<br>hexo server (hexo s) 启动本地web服务，用于博客的预览<br>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）<br>另外还有其他几个常用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div></pre></td></tr></table></figure>\n<h3 id=\"常用简写\"><a href=\"#常用简写\" class=\"headerlink\" title=\"常用简写\"></a>常用简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<h3 id=\"常用组合\"><a href=\"#常用组合\" class=\"headerlink\" title=\"常用组合\"></a>常用组合</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -g #生成部署</div><div class=\"line\">hexo s -g #生成预览</div></pre></td></tr></table></figure>\n<h3 id=\"使用git命令行部署\"><a href=\"#使用git命令行部署\" class=\"headerlink\" title=\"使用git命令行部署\"></a>使用git命令行部署</h3><p>clone github repo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo/blog</div><div class=\"line\">git clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io</div></pre></td></tr></table></figure></p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。<br>创建一个deploy脚本文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">cp -R public/* .deploy/foursquarebehind.github.io</div><div class=\"line\">cd .deploy/foursquarebehind.github.io</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m “update”</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n<p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。<br>需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p>\n<p>to be continued…</p>\n","excerpt":"","more":"<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo</div><div class=\"line\">npm install hexo-cli -g</div><div class=\"line\">hexo init blog</div><div class=\"line\">cd blog</div><div class=\"line\">npm install</div><div class=\"line\">hexo g # 或者hexo generate</div><div class=\"line\">hexo s # 或者hexo server，可以在http://localhost:4000/ 查看</div></pre></td></tr></table></figure>\n<p>这里有必要提下Hexo常用的几个命令：<br>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹<br>hexo server (hexo s) 启动本地web服务，用于博客的预览<br>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）<br>另外还有其他几个常用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div></pre></td></tr></table></figure>\n<h3 id=\"常用简写\"><a href=\"#常用简写\" class=\"headerlink\" title=\"常用简写\"></a>常用简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<h3 id=\"常用组合\"><a href=\"#常用组合\" class=\"headerlink\" title=\"常用组合\"></a>常用组合</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -g #生成部署</div><div class=\"line\">hexo s -g #生成预览</div></pre></td></tr></table></figure>\n<h3 id=\"使用git命令行部署\"><a href=\"#使用git命令行部署\" class=\"headerlink\" title=\"使用git命令行部署\"></a>使用git命令行部署</h3><p>clone github repo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd d:/hexo/blog</div><div class=\"line\">git clone https://github.com/foursquarebehind/foursquarebehind.github.io.git .deploy/foursquarebehind.github.io</div></pre></td></tr></table></figure></p>\n<p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。<br>创建一个deploy脚本文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">cp -R public/* .deploy/foursquarebehind.github.io</div><div class=\"line\">cd .deploy/foursquarebehind.github.io</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m “update”</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n<p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至foursquarebehind.github.io的git目录下，然后使用git commit命令提交代码到foursquarebehind.github.io这个repo的master branch上。<br>需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p>\n<p>to be continued…</p>\n"},{"title":"Multiple SSH Keys settings for different github account","date":"2016-10-24T15:57:10.000Z","_content":"\n## (GitHub-Flavored) Markdown Editor##\n\n1. [Generating a new ssh key and adding it to the ssh agent](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)\n\n\tspecify the key store name\n\n\t```\n \tssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C \"foursquarebehind@gmail.com\"\n\t```\n\n\tNote: have to make sure the ssh daemon is started\n\n\t```\n\teval \"$(ssh-agent -s)\"\n\t```\n\n\n2. [Adding a new ssh key to your github account](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)\n\t\n3. Create a SSH config file (if there is not)\n\n\tlocation ~/.ssh/config\n\tE.g.\n\n\t```\n\t#lowerthan60 account\n\tHost github.com-lowerthan60\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/lowerthan60\n\t\n\t\n\t#foursquarebehind account\n\tHost github.com-foursquarebehind\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/foursquarebehind\n\t```\n\n\n4. Git configuration\nNavigate to the repository configuration file (REPO_INSTALLDIR/.git).\nOpen the config file with your favorite editor.\nLocate the url value in the [remote \"origin\"] section\nchange the HTTPS style URL to git\nE.g.\nFrom :\n```\n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git\n```\n\nTo :\n\t\n```  \n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = git@personalid:newuserme/bb101repo.git\n```\n\t\n5. Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]\n\n\tMay have to re-config the user email and name \n\te.g. :\n\n\t``` \n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"    \n\t```\n\n\tthen add the changes and check in\n\te.g.:\n\n\t```\n\tgit add .\n\tgit commit -m \"update\"\n\tgit push origin master\n\t```\n\n6. A sample script\n\t\n\t```\n\t# my github script\n\tcd ~/.ssh\n\trm id_rsa\n\trm id_rsa.pub\n\trm config\n\t\n\tln git_dhoerl id_rsa\n\tln git_dhoerl.pub id_rsa.pub\n\tln config_dhoerl config\n\t\n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"        \n\t# git config --global github.token \"whatever_it_is\" # now unused\n\t```\n\nNote:\n* generate ssh key for each account and add the key into the account's profile in github.\n* make sure ssh-agent is started.\n* may have to re-config user email and name when switch between github accounts.\n* may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.\n* make sure use the git style repository URL to replace the default HTTPS style URL.\n\nTODO:\n1. create a new post on foursquarebehind.github.io and summarize the steps properly.\n2. try works with multiple git like repositories like bit-bucket and github together. \n \nRefrences:\n* https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\n* https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\n* https://gist.github.com/jexchan/2351996\n* http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\n* http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config","source":"_posts/2016-10-24-Multiple-SSH-Keys-settings-for-different-github-account.md","raw":"---\ntitle: Multiple SSH Keys settings for different github account\ndate: 2016-10-24 11:57:10\ntags:\n- GitHub\n- Tools\n---\n\n## (GitHub-Flavored) Markdown Editor##\n\n1. [Generating a new ssh key and adding it to the ssh agent](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)\n\n\tspecify the key store name\n\n\t```\n \tssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C \"foursquarebehind@gmail.com\"\n\t```\n\n\tNote: have to make sure the ssh daemon is started\n\n\t```\n\teval \"$(ssh-agent -s)\"\n\t```\n\n\n2. [Adding a new ssh key to your github account](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)\n\t\n3. Create a SSH config file (if there is not)\n\n\tlocation ~/.ssh/config\n\tE.g.\n\n\t```\n\t#lowerthan60 account\n\tHost github.com-lowerthan60\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/lowerthan60\n\t\n\t\n\t#foursquarebehind account\n\tHost github.com-foursquarebehind\n\tHostName github.com\n\tUser git\n\tIdentityFile ~/.ssh/foursquarebehind\n\t```\n\n\n4. Git configuration\nNavigate to the repository configuration file (REPO_INSTALLDIR/.git).\nOpen the config file with your favorite editor.\nLocate the url value in the [remote \"origin\"] section\nchange the HTTPS style URL to git\nE.g.\nFrom :\n```\n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git\n```\n\nTo :\n\t\n```  \n[remote \"origin\"]\n  fetch = +refs/heads/*:refs/remotes/origin/*\n  url = git@personalid:newuserme/bb101repo.git\n```\n\t\n5. Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]\n\n\tMay have to re-config the user email and name \n\te.g. :\n\n\t``` \n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"    \n\t```\n\n\tthen add the changes and check in\n\te.g.:\n\n\t```\n\tgit add .\n\tgit commit -m \"update\"\n\tgit push origin master\n\t```\n\n6. A sample script\n\t\n\t```\n\t# my github script\n\tcd ~/.ssh\n\trm id_rsa\n\trm id_rsa.pub\n\trm config\n\t\n\tln git_dhoerl id_rsa\n\tln git_dhoerl.pub id_rsa.pub\n\tln config_dhoerl config\n\t\n\tgit config --global user.email \"dhoerl@xyz.com\"\n\tgit config --global github.user \"dhoerl\"        \n\t# git config --global github.token \"whatever_it_is\" # now unused\n\t```\n\nNote:\n* generate ssh key for each account and add the key into the account's profile in github.\n* make sure ssh-agent is started.\n* may have to re-config user email and name when switch between github accounts.\n* may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.\n* make sure use the git style repository URL to replace the default HTTPS style URL.\n\nTODO:\n1. create a new post on foursquarebehind.github.io and summarize the steps properly.\n2. try works with multiple git like repositories like bit-bucket and github together. \n \nRefrences:\n* https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\n* https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\n* https://gist.github.com/jexchan/2351996\n* http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\n* http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config","slug":"Multiple-SSH-Keys-settings-for-different-github-account","published":1,"updated":"2016-11-15T21:13:11.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civlf2t1o0004gols5dpr0b1t","content":"<h2 id=\"GitHub-Flavored-Markdown-Editor\"><a href=\"#GitHub-Flavored-Markdown-Editor\" class=\"headerlink\" title=\"(GitHub-Flavored) Markdown Editor\"></a>(GitHub-Flavored) Markdown Editor</h2><ol>\n<li><p><a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\" target=\"_blank\" rel=\"external\">Generating a new ssh key and adding it to the ssh agent</a></p>\n<p> specify the key store name</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C &quot;foursquarebehind@gmail.com&quot;</div></pre></td></tr></table></figure>\n<p> Note: have to make sure the ssh daemon is started</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eval &quot;$(ssh-agent -s)&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\" target=\"_blank\" rel=\"external\">Adding a new ssh key to your github account</a></p>\n</li>\n<li><p>Create a SSH config file (if there is not)</p>\n<p> location ~/.ssh/config<br> E.g.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#lowerthan60 account</div><div class=\"line\">Host github.com-lowerthan60</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/lowerthan60</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#foursquarebehind account</div><div class=\"line\">Host github.com-foursquarebehind</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/foursquarebehind</div></pre></td></tr></table></figure>\n</li>\n<li><p>Git configuration<br>Navigate to the repository configuration file (REPO_INSTALLDIR/.git).<br>Open the config file with your favorite editor.<br>Locate the url value in the [remote “origin”] section<br>change the HTTPS style URL to git<br>E.g.<br>From :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>To :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = git@personalid:newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n<ol>\n<li><p>Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]</p>\n<p> May have to re-config the user email and name<br> e.g. :</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;</div></pre></td></tr></table></figure>\n<p> then add the changes and check in<br> e.g.:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;update&quot;</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n</li>\n<li><p>A sample script</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"># my github script</div><div class=\"line\">cd ~/.ssh</div><div class=\"line\">rm id_rsa</div><div class=\"line\">rm id_rsa.pub</div><div class=\"line\">rm config</div><div class=\"line\"></div><div class=\"line\">ln git_dhoerl id_rsa</div><div class=\"line\">ln git_dhoerl.pub id_rsa.pub</div><div class=\"line\">ln config_dhoerl config</div><div class=\"line\"></div><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;        </div><div class=\"line\"># git config --global github.token &quot;whatever_it_is&quot; # now unused</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Note:</p>\n<ul>\n<li>generate ssh key for each account and add the key into the account’s profile in github.</li>\n<li>make sure ssh-agent is started.</li>\n<li>may have to re-config user email and name when switch between github accounts.</li>\n<li>may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.</li>\n<li>make sure use the git style repository URL to replace the default HTTPS style URL.</li>\n</ul>\n<p>TODO:</p>\n<ol>\n<li>create a new post on foursquarebehind.github.io and summarize the steps properly.</li>\n<li>try works with multiple git like repositories like bit-bucket and github together. </li>\n</ol>\n<p>Refrences:</p>\n<ul>\n<li><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\" target=\"_blank\" rel=\"external\">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a></li>\n<li><a href=\"https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\" target=\"_blank\" rel=\"external\">https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html</a></li>\n<li><a href=\"https://gist.github.com/jexchan/2351996\" target=\"_blank\" rel=\"external\">https://gist.github.com/jexchan/2351996</a></li>\n<li><a href=\"http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"GitHub-Flavored-Markdown-Editor\"><a href=\"#GitHub-Flavored-Markdown-Editor\" class=\"headerlink\" title=\"(GitHub-Flavored) Markdown Editor\"></a>(GitHub-Flavored) Markdown Editor</h2><ol>\n<li><p><a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\">Generating a new ssh key and adding it to the ssh agent</a></p>\n<p> specify the key store name</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen.exe -t rsa -b 4096 -f ~/.ssh/foursquarebehind -C &quot;foursquarebehind@gmail.com&quot;</div></pre></td></tr></table></figure>\n<p> Note: have to make sure the ssh daemon is started</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">eval &quot;$(ssh-agent -s)&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\">Adding a new ssh key to your github account</a></p>\n</li>\n<li><p>Create a SSH config file (if there is not)</p>\n<p> location ~/.ssh/config<br> E.g.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#lowerthan60 account</div><div class=\"line\">Host github.com-lowerthan60</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/lowerthan60</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#foursquarebehind account</div><div class=\"line\">Host github.com-foursquarebehind</div><div class=\"line\">HostName github.com</div><div class=\"line\">User git</div><div class=\"line\">IdentityFile ~/.ssh/foursquarebehind</div></pre></td></tr></table></figure>\n</li>\n<li><p>Git configuration<br>Navigate to the repository configuration file (REPO_INSTALLDIR/.git).<br>Open the config file with your favorite editor.<br>Locate the url value in the [remote “origin”] section<br>change the HTTPS style URL to git<br>E.g.<br>From :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = https://newuserme@bitbucket.org/newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>To :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">  fetch = +refs/heads/*:refs/remotes/origin/*</div><div class=\"line\">  url = git@personalid:newuserme/bb101repo.git</div></pre></td></tr></table></figure>\n<ol>\n<li><p>Commit [here it should be the 5th step but it shows starting from 1, it might be a bug of hexo]</p>\n<p> May have to re-config the user email and name<br> e.g. :</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;</div></pre></td></tr></table></figure>\n<p> then add the changes and check in<br> e.g.:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;update&quot;</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure>\n</li>\n<li><p>A sample script</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"># my github script</div><div class=\"line\">cd ~/.ssh</div><div class=\"line\">rm id_rsa</div><div class=\"line\">rm id_rsa.pub</div><div class=\"line\">rm config</div><div class=\"line\"></div><div class=\"line\">ln git_dhoerl id_rsa</div><div class=\"line\">ln git_dhoerl.pub id_rsa.pub</div><div class=\"line\">ln config_dhoerl config</div><div class=\"line\"></div><div class=\"line\">git config --global user.email &quot;dhoerl@xyz.com&quot;</div><div class=\"line\">git config --global github.user &quot;dhoerl&quot;        </div><div class=\"line\"># git config --global github.token &quot;whatever_it_is&quot; # now unused</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Note:</p>\n<ul>\n<li>generate ssh key for each account and add the key into the account’s profile in github.</li>\n<li>make sure ssh-agent is started.</li>\n<li>may have to re-config user email and name when switch between github accounts.</li>\n<li>may have to be in gitbash because of in the normal windows terminal the ssh and git env may not be configured properly.</li>\n<li>make sure use the git style repository URL to replace the default HTTPS style URL.</li>\n</ul>\n<p>TODO:</p>\n<ol>\n<li>create a new post on foursquarebehind.github.io and summarize the steps properly.</li>\n<li>try works with multiple git like repositories like bit-bucket and github together. </li>\n</ol>\n<p>Refrences:</p>\n<ul>\n<li><a href=\"https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/\">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a></li>\n<li><a href=\"https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html\">https://confluence.atlassian.com/bitbucket/configure-multiple-ssh-identities-for-gitbash-mac-osx-linux-271943168.html</a></li>\n<li><a href=\"https://gist.github.com/jexchan/2351996\">https://gist.github.com/jexchan/2351996</a></li>\n<li><a href=\"http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain\">http://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config\">http://stackoverflow.com/questions/3225862/multiple-github-accounts-ssh-config</a></li>\n</ul>\n"},{"title":"窒息","date":"2016-10-21T21:17:21.000Z","_content":"\n窒息\n\n追逐权利便抛弃良心 维护和平就发动战争\n欲望不断压缩和膨胀 失去了还不懂得珍惜\n闪烁的是人类的智慧 摧残的是古老的文明\n脚踏的是先辈的血肉 手撑的是自已的天空\n\n嘴里念的是道德和法律 背后做的是花天和酒地\n心中想的是金钱和权力 眼睛寻的是公主和王子\n\n为了虚荣可以出卖肉体 为了欢乐可心朝三暮四\n为了刺激可以吸食毒品 为了利益可以拔刀动枪\n\n心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋\n有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕\n\n心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息\n那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡\n我无法留住我的那份清白 我无法拉住要飞的灵魂\n我开始在这世界玩命疯狂 我要冲这世界撕心裂肺\n啊——————\n\n有没有想过 你失去了什么\n\n记忆中的阳光　　何时才能重现\n让我在生死的边缘　　看到一点希望的光芒\n","source":"_posts/2016-10-21-zhi-xi.md","raw":"---\ntitle: 窒息\ndate: 2016-10-21 17:17:21\ntags:\n- 随笔\n---\n\n窒息\n\n追逐权利便抛弃良心 维护和平就发动战争\n欲望不断压缩和膨胀 失去了还不懂得珍惜\n闪烁的是人类的智慧 摧残的是古老的文明\n脚踏的是先辈的血肉 手撑的是自已的天空\n\n嘴里念的是道德和法律 背后做的是花天和酒地\n心中想的是金钱和权力 眼睛寻的是公主和王子\n\n为了虚荣可以出卖肉体 为了欢乐可心朝三暮四\n为了刺激可以吸食毒品 为了利益可以拔刀动枪\n\n心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋\n有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕\n\n心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息\n那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡\n我无法留住我的那份清白 我无法拉住要飞的灵魂\n我开始在这世界玩命疯狂 我要冲这世界撕心裂肺\n啊——————\n\n有没有想过 你失去了什么\n\n记忆中的阳光　　何时才能重现\n让我在生死的边缘　　看到一点希望的光芒\n","slug":"zhi-xi","published":1,"updated":"2016-11-15T21:13:11.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civlf2t1r0005golsk0djngk7","content":"<p>窒息</p>\n<p>追逐权利便抛弃良心 维护和平就发动战争<br>欲望不断压缩和膨胀 失去了还不懂得珍惜<br>闪烁的是人类的智慧 摧残的是古老的文明<br>脚踏的是先辈的血肉 手撑的是自已的天空</p>\n<p>嘴里念的是道德和法律 背后做的是花天和酒地<br>心中想的是金钱和权力 眼睛寻的是公主和王子</p>\n<p>为了虚荣可以出卖肉体 为了欢乐可心朝三暮四<br>为了刺激可以吸食毒品 为了利益可以拔刀动枪</p>\n<p>心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋<br>有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕</p>\n<p>心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息<br>那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡<br>我无法留住我的那份清白 我无法拉住要飞的灵魂<br>我开始在这世界玩命疯狂 我要冲这世界撕心裂肺<br>啊——————</p>\n<p>有没有想过 你失去了什么</p>\n<p>记忆中的阳光　　何时才能重现<br>让我在生死的边缘　　看到一点希望的光芒</p>\n","excerpt":"","more":"<p>窒息</p>\n<p>追逐权利便抛弃良心 维护和平就发动战争<br>欲望不断压缩和膨胀 失去了还不懂得珍惜<br>闪烁的是人类的智慧 摧残的是古老的文明<br>脚踏的是先辈的血肉 手撑的是自已的天空</p>\n<p>嘴里念的是道德和法律 背后做的是花天和酒地<br>心中想的是金钱和权力 眼睛寻的是公主和王子</p>\n<p>为了虚荣可以出卖肉体 为了欢乐可心朝三暮四<br>为了刺激可以吸食毒品 为了利益可以拔刀动枪</p>\n<p>心碎的不再是断弦的恋曲 痛苦的是永远也装不满的口袋<br>有了新欢我就要背叛家庭 我帮你得到你所要的你要让我富裕</p>\n<p>心灵的鸟儿在围着我撒谎 空中的尘埃在围着我叹息<br>那满身的虚伪满身的铜臭 让纯洁和善良如何去阻挡<br>我无法留住我的那份清白 我无法拉住要飞的灵魂<br>我开始在这世界玩命疯狂 我要冲这世界撕心裂肺<br>啊——————</p>\n<p>有没有想过 你失去了什么</p>\n<p>记忆中的阳光　　何时才能重现<br>让我在生死的边缘　　看到一点希望的光芒</p>\n"},{"title":"Most Beautiful Mathematical Equations","date":"2016-11-08T21:23:17.000Z","_content":"Mass–energy equivalence\n$$\nE=mc^2\n$$\n\nEuler's equation\n$$\ne^{i\\pi} + 1 = 0\n$$\n\nPythagorean theorem\n$$\na^2 + b^2 = c^2\n$$\n\n","source":"_posts/2016-11-08-Most-Beautiful-Mathematical-Equations.md","raw":"---\ntitle: Most Beautiful Mathematical Equations\ndate: 2016-11-08 16:23:17\ntags:\n\tMath\n---\nMass–energy equivalence\n$$\nE=mc^2\n$$\n\nEuler's equation\n$$\ne^{i\\pi} + 1 = 0\n$$\n\nPythagorean theorem\n$$\na^2 + b^2 = c^2\n$$\n\n","slug":"Most-Beautiful-Mathematical-Equations","published":1,"updated":"2016-11-15T21:13:11.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civlf2t1u0006golsj3jg4wdq","content":"<p>Mass–energy equivalence<br>$$<br>E=mc^2<br>$$</p>\n<p>Euler’s equation<br>$$<br>e^{i\\pi} + 1 = 0<br>$$</p>\n<p>Pythagorean theorem<br>$$<br>a^2 + b^2 = c^2<br>$$</p>\n","excerpt":"","more":"<p>Mass–energy equivalence<br>$$<br>E=mc^2<br>$$</p>\n<p>Euler’s equation<br>$$<br>e^{i\\pi} + 1 = 0<br>$$</p>\n<p>Pythagorean theorem<br>$$<br>a^2 + b^2 = c^2<br>$$</p>\n"},{"title":"Tree Properties","_content":"\n\n* **Depth**: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree's root node. A root node will have a depth of 0.\n* **Height**: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.\n* **Degree**: The number of children emanating from a given node is referred to as its degree.\n* **Diameter (or width)** of a tree is the number of nodes on the longest path between any two leaf nodes. \n\nE.g. In Figure 1, the tree has a height of 3, node **G** has a depth of 2, node **A** has a degree of 3 and node **H** has a degree of 1. In Figure 2, the tree has a **diameter** of 6 nodes.\n\n| &nbsp; | &nbsp; |\n| :---   | ---:   | \n| {% asset_img tree_properties_1.jpg \"Figure 1\" \"A tree \"%} | {% asset_img tree_height_depth.png \"Figure 2\" \"Tree height and depth \"%} |\n\n\n##### References ######\n* http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\n* https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/","source":"_posts/2016-11-15-Tree-Properties.md","raw":"---\ntitle: Tree Properties\ntags:\n- Algorithm\n- Tree\n---\n\n\n* **Depth**: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree's root node. A root node will have a depth of 0.\n* **Height**: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.\n* **Degree**: The number of children emanating from a given node is referred to as its degree.\n* **Diameter (or width)** of a tree is the number of nodes on the longest path between any two leaf nodes. \n\nE.g. In Figure 1, the tree has a height of 3, node **G** has a depth of 2, node **A** has a degree of 3 and node **H** has a degree of 1. In Figure 2, the tree has a **diameter** of 6 nodes.\n\n| &nbsp; | &nbsp; |\n| :---   | ---:   | \n| {% asset_img tree_properties_1.jpg \"Figure 1\" \"A tree \"%} | {% asset_img tree_height_depth.png \"Figure 2\" \"Tree height and depth \"%} |\n\n\n##### References ######\n* http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\n* https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/","slug":"Tree-Properties","published":1,"date":"2016-11-15T05:00:00.000Z","updated":"2016-11-16T21:44:18.039Z","_id":"civlf2t1w0008golskqskfp2m","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><strong>Depth</strong>: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree’s root node. A root node will have a depth of 0.</li>\n<li><strong>Height</strong>: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.</li>\n<li><strong>Degree</strong>: The number of children emanating from a given node is referred to as its degree.</li>\n<li><strong>Diameter (or width)</strong> of a tree is the number of nodes on the longest path between any two leaf nodes. </li>\n</ul>\n<p>E.g. In Figure 1, the tree has a height of 3, node <strong>G</strong> has a depth of 2, node <strong>A</strong> has a degree of 3 and node <strong>H</strong> has a degree of 1. In Figure 2, the tree has a <strong>diameter</strong> of 6 nodes.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_properties_1.jpg\" alt=\"Figure 1 A tree\" title=\"Figure 1 A tree\"></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_height_depth.png\" alt=\"Figure 2 Tree height and depth\" title=\"Figure 2 Tree height and depth\"></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h5><ul>\n<li><a href=\"http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height</a></li>\n<li><a href=\"https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/\" target=\"_blank\" rel=\"external\">https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/</a></li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><strong>Depth</strong>: The number of lines you pass through when you travel from the root until you reach a particular node is the depth of that node in the tree, or is the number of edges from the node to the tree’s root node. A root node will have a depth of 0.</li>\n<li><strong>Height</strong>: The height of the tree is the maximum depth of any node in the tree, or is the number of edges on the longest path from the node to a leaf. A leaf node will have a height of 0.</li>\n<li><strong>Degree</strong>: The number of children emanating from a given node is referred to as its degree.</li>\n<li><strong>Diameter (or width)</strong> of a tree is the number of nodes on the longest path between any two leaf nodes. </li>\n</ul>\n<p>E.g. In Figure 1, the tree has a height of 3, node <strong>G</strong> has a depth of 2, node <strong>A</strong> has a degree of 3 and node <strong>H</strong> has a degree of 1. In Figure 2, the tree has a <strong>diameter</strong> of 6 nodes.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_properties_1.jpg\" alt=\"Figure 1 A tree\" title=\"Figure 1 A tree\"></td>\n<td style=\"text-align:right\"><img src=\"/archive/2016/11/15/Tree-Properties/tree_height_depth.png\" alt=\"Figure 2 Tree height and depth\" title=\"Figure 2 Tree height and depth\"></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h5><ul>\n<li><a href=\"http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height\">http://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height</a></li>\n<li><a href=\"https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/\">https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/</a></li>\n</ul>\n"},{"title":"Height of a Complete Binary Tree","date":"2016-11-09T05:28:17.000Z","_content":"\nThe height of a complete binary tree is $O(log n)$\n\n### Theorem ###\nThe height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .\n\n### Intuition ###\n| Tree | Nodes($n$) | Height $log(n+1)$ |\n| :--- | :---: | :---: | \n| {% asset_img min_tree1.gif \" \" \" \" %} | 1 | 1 |\n| {% asset_img min_tree2.gif \" \" \" \" %} | 3 | 2 |\n| {% asset_img min_tree3.gif \" \" \" \" %} | 7 | 3 |\n\n### Proof ###\n\n$n$ : Number of nodes in the tree.\n$h$ : Height of the tree.\n\n##### Precondition #####\nSince the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.\nSo $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub>\nAnd $n$<sub>left</sub> $=$ $n$<sub>right</sub>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub>\n\n##### Basis #####\n$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1\n\n##### Inductive Hypothesis #####\nAssume that the theorem is **true** for heights <= $k$ .\n\t\n##### Inductive Step #####\nProve that the inductive hypothhesis is **true** for height $k + 1$\n\t\nLet $h$ as the height of the Complete Binary Tree with $n$ nodes, \nand let $h = k + 1$ .\n\nSo $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, \n\nso $k = log_2(n$<sub>left</sub> $+$ $1)$ --------- *by the inductive hypothesis*\n \nNote that the theorem is **true** (by the inductive hypothesis) of the subtrees of the root, since they have height $k$\n\n| &nbsp;   | &nbsp;              | &nbsp; | &nbsp;                                         | &nbsp; |\n| :---     | ---:                | :---:  | :---                                           | ---: |\n| &nbsp;   | $n$                 | $=$    | $1 + n$<sub>left</sub> $+$ $n$<sub>right</sub> | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $1 + 2n$<sub>left</sub>                        | *since the tree is complete* |\n| **BUT**  | $k$                 | $=$    | $log_2(n$<sub>left</sub> $+$ $1)$              | *by the inductive hypothesis* |\n| **SO**   | $n$<sub>left</sub>  | $=$    | $2^k - 1$                                      | &nbsp; |\n| **THEN** | $n$                 | $=$    | $1 + 2(2^k - 1)$                               | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $2^{k + 1} - 1$                                | &nbsp; |\n| &nbsp;   | $log_2(n+1)$        | $=$    | $log_2(2^{k + 1})$                             | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $k + 1$                                        | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $h$                                            | &nbsp; |\n\n\n\nThus, the inductive hypothesis is **true** for height $k + 1$ and, hence (by induction), **true** for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .\n\n##### Reference ######\n* http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/","source":"_posts/2016-11-09-Height-of-a-Complete-Binary-Tree.md","raw":"---\ntitle: Height of a Complete Binary Tree\ndate: 2016-11-09 00:28:17\ntags:\n- Algorithm\n- Tree\n---\n\nThe height of a complete binary tree is $O(log n)$\n\n### Theorem ###\nThe height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .\n\n### Intuition ###\n| Tree | Nodes($n$) | Height $log(n+1)$ |\n| :--- | :---: | :---: | \n| {% asset_img min_tree1.gif \" \" \" \" %} | 1 | 1 |\n| {% asset_img min_tree2.gif \" \" \" \" %} | 3 | 2 |\n| {% asset_img min_tree3.gif \" \" \" \" %} | 7 | 3 |\n\n### Proof ###\n\n$n$ : Number of nodes in the tree.\n$h$ : Height of the tree.\n\n##### Precondition #####\nSince the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.\nSo $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub>\nAnd $n$<sub>left</sub> $=$ $n$<sub>right</sub>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub>\n\n##### Basis #####\n$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1\n\n##### Inductive Hypothesis #####\nAssume that the theorem is **true** for heights <= $k$ .\n\t\n##### Inductive Step #####\nProve that the inductive hypothhesis is **true** for height $k + 1$\n\t\nLet $h$ as the height of the Complete Binary Tree with $n$ nodes, \nand let $h = k + 1$ .\n\nSo $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, \n\nso $k = log_2(n$<sub>left</sub> $+$ $1)$ --------- *by the inductive hypothesis*\n \nNote that the theorem is **true** (by the inductive hypothesis) of the subtrees of the root, since they have height $k$\n\n| &nbsp;   | &nbsp;              | &nbsp; | &nbsp;                                         | &nbsp; |\n| :---     | ---:                | :---:  | :---                                           | ---: |\n| &nbsp;   | $n$                 | $=$    | $1 + n$<sub>left</sub> $+$ $n$<sub>right</sub> | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $1 + 2n$<sub>left</sub>                        | *since the tree is complete* |\n| **BUT**  | $k$                 | $=$    | $log_2(n$<sub>left</sub> $+$ $1)$              | *by the inductive hypothesis* |\n| **SO**   | $n$<sub>left</sub>  | $=$    | $2^k - 1$                                      | &nbsp; |\n| **THEN** | $n$                 | $=$    | $1 + 2(2^k - 1)$                               | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $2^{k + 1} - 1$                                | &nbsp; |\n| &nbsp;   | $log_2(n+1)$        | $=$    | $log_2(2^{k + 1})$                             | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $k + 1$                                        | &nbsp; |\n| &nbsp;   | &nbsp;              | $=$    | $h$                                            | &nbsp; |\n\n\n\nThus, the inductive hypothesis is **true** for height $k + 1$ and, hence (by induction), **true** for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .\n\n##### Reference ######\n* http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/","slug":"Height-of-a-Complete-Binary-Tree","published":1,"updated":"2016-11-15T21:13:11.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civlf2t1z0009golsblj1n5sy","content":"<p>The height of a complete binary tree is $O(log n)$</p>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>The height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .</p>\n<h3 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Tree</th>\n<th style=\"text-align:center\">Nodes($n$)</th>\n<th style=\"text-align:center\">Height $log(n+1)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree1.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree2.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree3.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Proof\"><a href=\"#Proof\" class=\"headerlink\" title=\"Proof\"></a>Proof</h3><p>$n$ : Number of nodes in the tree.<br>$h$ : Height of the tree.</p>\n<h5 id=\"Precondition\"><a href=\"#Precondition\" class=\"headerlink\" title=\"Precondition\"></a>Precondition</h5><p>Since the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.<br>So $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub><br>And $n$<sub>left</sub> $=$ $n$<sub>right</sub><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub></p>\n<h5 id=\"Basis\"><a href=\"#Basis\" class=\"headerlink\" title=\"Basis\"></a>Basis</h5><p>$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1</p>\n<h5 id=\"Inductive-Hypothesis\"><a href=\"#Inductive-Hypothesis\" class=\"headerlink\" title=\"Inductive Hypothesis\"></a>Inductive Hypothesis</h5><p>Assume that the theorem is <strong>true</strong> for heights &lt;= $k$ .</p>\n<h5 id=\"Inductive-Step\"><a href=\"#Inductive-Step\" class=\"headerlink\" title=\"Inductive Step\"></a>Inductive Step</h5><p>Prove that the inductive hypothhesis is <strong>true</strong> for height $k + 1$</p>\n<p>Let $h$ as the height of the Complete Binary Tree with $n$ nodes,<br>and let $h = k + 1$ .</p>\n<p>So $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, </p>\n<p>so $k = log_2(n$<sub>left</sub> $+$ $1)$ ——— <em>by the inductive hypothesis</em></p>\n<p>Note that the theorem is <strong>true</strong> (by the inductive hypothesis) of the subtrees of the root, since they have height $k$</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + n$<sub>left</sub> $+$ $n$<sub>right</sub></td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2n$<sub>left</sub></td>\n<td style=\"text-align:right\"><em>since the tree is complete</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>BUT</strong></td>\n<td style=\"text-align:right\">$k$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(n$<sub>left</sub> $+$ $1)$</td>\n<td style=\"text-align:right\"><em>by the inductive hypothesis</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>SO</strong></td>\n<td style=\"text-align:right\">$n$<sub>left</sub></td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^k - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>THEN</strong></td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2(2^k - 1)$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^{k + 1} - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$log_2(n+1)$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(2^{k + 1})$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$k + 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p>Thus, the inductive hypothesis is <strong>true</strong> for height $k + 1$ and, hence (by induction), <strong>true</strong> for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .</p>\n<h5 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h5><ul>\n<li><a href=\"http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/\" target=\"_blank\" rel=\"external\">http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/</a></li>\n</ul>\n","excerpt":"","more":"<p>The height of a complete binary tree is $O(log n)$</p>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>The height of a complete, balanced tree of  $n$ nodes is $log(n+1)$ .</p>\n<h3 id=\"Intuition\"><a href=\"#Intuition\" class=\"headerlink\" title=\"Intuition\"></a>Intuition</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Tree</th>\n<th style=\"text-align:center\">Nodes($n$)</th>\n<th style=\"text-align:center\">Height $log(n+1)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree1.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree2.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><img src=\"/archive/2016/11/09/Height-of-a-Complete-Binary-Tree/min_tree3.gif\" alt=\" \" title=\" \"></td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Proof\"><a href=\"#Proof\" class=\"headerlink\" title=\"Proof\"></a>Proof</h3><p>$n$ : Number of nodes in the tree.<br>$h$ : Height of the tree.</p>\n<h5 id=\"Precondition\"><a href=\"#Precondition\" class=\"headerlink\" title=\"Precondition\"></a>Precondition</h5><p>Since the tree is complete, so the subtrees of the same parent should have the same number of nodes and same height.<br>So $n = 1 + n$<sub>left</sub> $+$ $n$<sub>right</sub><br>And $n$<sub>left</sub> $=$ $n$<sub>right</sub><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h$<sub>left</sub> $=$ $h$<sub>right</sub></p>\n<h5 id=\"Basis\"><a href=\"#Basis\" class=\"headerlink\" title=\"Basis\"></a>Basis</h5><p>$n$ = 1, $log(n+1)$ = $log2$ = 1, $h$ = $log(n+1)$ = 1</p>\n<h5 id=\"Inductive-Hypothesis\"><a href=\"#Inductive-Hypothesis\" class=\"headerlink\" title=\"Inductive Hypothesis\"></a>Inductive Hypothesis</h5><p>Assume that the theorem is <strong>true</strong> for heights &lt;= $k$ .</p>\n<h5 id=\"Inductive-Step\"><a href=\"#Inductive-Step\" class=\"headerlink\" title=\"Inductive Step\"></a>Inductive Step</h5><p>Prove that the inductive hypothhesis is <strong>true</strong> for height $k + 1$</p>\n<p>Let $h$ as the height of the Complete Binary Tree with $n$ nodes,<br>and let $h = k + 1$ .</p>\n<p>So $k$ is the height of the direct subtree of the Complete Binary Tree with $n$ nodes, </p>\n<p>so $k = log_2(n$<sub>left</sub> $+$ $1)$ ——— <em>by the inductive hypothesis</em></p>\n<p>Note that the theorem is <strong>true</strong> (by the inductive hypothesis) of the subtrees of the root, since they have height $k$</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n<th style=\"text-align:center\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:right\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + n$<sub>left</sub> $+$ $n$<sub>right</sub></td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2n$<sub>left</sub></td>\n<td style=\"text-align:right\"><em>since the tree is complete</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>BUT</strong></td>\n<td style=\"text-align:right\">$k$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(n$<sub>left</sub> $+$ $1)$</td>\n<td style=\"text-align:right\"><em>by the inductive hypothesis</em></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>SO</strong></td>\n<td style=\"text-align:right\">$n$<sub>left</sub></td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^k - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>THEN</strong></td>\n<td style=\"text-align:right\">$n$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$1 + 2(2^k - 1)$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$2^{k + 1} - 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">$log_2(n+1)$</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$log_2(2^{k + 1})$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$k + 1$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&nbsp;</td>\n<td style=\"text-align:right\">&nbsp;</td>\n<td style=\"text-align:center\">$=$</td>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:right\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p>Thus, the inductive hypothesis is <strong>true</strong> for height $k + 1$ and, hence (by induction), <strong>true</strong> for all heights. A ccomplete binary tree of $n$ nodes has height $log_2(n+1)$ .</p>\n<h5 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h5><ul>\n<li><a href=\"http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/\">http://www.dgp.toronto.edu/people/JamesStewart/378notes/09treeHeight/</a></li>\n</ul>\n"},{"title":"tt","_content":"","source":"_drafts/tt.md","raw":"---\ntitle: tt\ntags:\n---\n","slug":"tt","published":0,"date":"2016-11-15T21:13:11.034Z","updated":"2016-11-15T21:13:11.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civlf2t3e000sgolsy5k6ms87","content":"","excerpt":"","more":""},{"title":"Red-Black Tree","date":"2016-11-16T21:04:28.000Z","_content":"\n### Preface ###\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Introduction ###\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n### Properties ###\n1. Every node is colored with either red or black;\n2. All leaf (NULL Pointer) nodes are colored with black; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black._\n3. Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**). We call this number the **black height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a red node must be black nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always black.\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Application of Red-Black Tree ###\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | Black height of the tree;                         |\n| $bh(x)$       | Black height of the node $x$;                     |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 4<sup>th</sup> property above as each red node strictly requires black children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Theorem ### \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n### Proof by induction ###\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is __black height__ of the node $x$, or $x$'s __black height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sup>rd</sup> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sup>th</sup> **Red-Black Tree** properties, \"Both children of a red node must be black nodes\", we can say starting from the node x to leaf node, the number of black nodes >= the number the red nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __black height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n**Corollary**:\nAll operations of a **Red-Black Tree** take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();\nInsert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Structure ###\nEvery node of **Red-Black Tree** has $5$ attributes:\n\n```c\nstruct t_red_black_node {\n    enum { \n        red, black \n    } color;\n    void *key;\n    struct t_red_black_node *left;\n    struct t_red_black_node *right;\n    struct t_red_black_node *parent;\n\tvoid *value;\n\tint numLeft;      //optional\n\tint numRight;     //optional\n}\n```\n\nA **Red-Black Tree** node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated. \nOf course we can add more variables like the count of its children nodes according to the requirements.\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Operations and Rotations ###\nHow does **inserting** or **deleting** nodes affect a **Red-Black Tree**? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like **inserting** or **deleting**, the **Red-Black Tree** is continue to keep the its properties and balance.\n\n**Rotation** is a binary operation, between a parent node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).\n\nThere are two types of rotations: **left rotation** and **right rotation**. \n**Left rotation** swaps the parent node with its right child, \n**Right rotation** swaps the parent node with its left child. \n\n| **Left rotation**                                           | &nbsp; |**Right rotation**                                            |\n| :---:                                                       | ---    | :---:                                                        |\n| {% asset_img rbt_left_rotation_1.jpg \" \" \"Left rotation\" %} | &nbsp; |{% asset_img rbt_right_rotation_1.jpg \" \" \"Right rotation\" %} |\n\n\nHere are the steps involved in for left rotation (for right rotations just change “left” to “right” below):\n\nWhen do the left rotation on a **pivot**, assume its right child is not **NIL[T]**. **pivot** is a left child of any nodes but not **NIL[T]**\n**Left rotation** is based on the axis between the **pivot** node and **Y** node, the steps are:\n1. Let node **Y** be the parent of the **pivot** node;\n2. Let the **pivot** node be the left child of node **Y**;\n3. Let the left child of node **Y** be the rigth child of the **pivot** node;\n\nThe pesudo code for **left rotation** is below(use **X** as the **pivot** node which is mentioned above):\n\n```\nLEFT-ROTATE(T, X)  \n Y ← right[X]            \n right[X] ← left[Y]      // Turn Y's left subtree into X's right subtree;\n p[left[Y]] ← X          // Set X as the parent of Y's left child;\n p[Y] ← p[X]             // Link X's parent to Y;\n if p[X] = nil[T]        // means X is root, so its parent is nil\n then root[T] ← Y        // case 1： first see whether we're at the root ;\n else if X = left[p[X]]  \n then left[p[X]] ← Y     // case 2： X was on the left of its parent;\n else right[p[X]] ← Y    // case 3: X must have been on the right, so set Y as the right child of X's parent;\n left[Y] ← X             // set X as Y's left child;\n p[X] ← Y                // set Y as X's parent;\n```\n\n","source":"_posts/2016-11-16-Red-Black-Tree.md","raw":"---\ntitle: Red-Black Tree\ndate: 2016-11-16 16:04:28\ntags:\n- Algorithm\n- Tree\n---\n\n### Preface ###\n\n##### BST(Binary Search Tree) Retrieval #####\n\nRetrieving an element from **BST** requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.\n\n**Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!**\n\nThe problem with **BST** is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a **linked list** in which each node has only a right child. This yields $O(n)$ for primitive operations on the **BST**, with $n$ the number of nodes in the tree, in the other words, the **BST** is turned to an **ordered linked list**.\n\nTo solve this problem many variations of **BST** exist. Of these variations, **Red-Black tree provides a well-balanced **BST** that guarantees a logarithmic bound on primitive operations**.  \n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Introduction ###\n**Red-Black Tree**, an evolution of **BST** that aim to **keep the tree balanced without affecting the complexity of the primitive operations**. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that **the deepest path in the tree is not longer than twice the shortest one**.\n\n### Properties ###\n1. Every node is colored with either red or black;\n2. All leaf (NULL Pointer) nodes are colored with black; \n\t**Note:** _If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black._\n3. Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**). We call this number the **black height** of node $x$, which is denoted by $bh(x)$;\n4. Both children of a red node must be black nodes;\n\t**Note:** _So it's impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the **Red-Black Tree** is a relatively balanced binary tree._\n5. The root is always black.\n\n\n{% asset_img rbt_1.jpg \"Figure 1 \" \"Red-Black Tree\" %}\n\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Application of Red-Black Tree ###\n**Red-Black Tree** is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency. \nFor example, the Java collection classes **TreeSet** and **TreeMap** , the C++ STL classes **set**, **map**, and Linux virtual memory management, all of these are based on **Red-Black Tree**.\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n| ** Basis **   | &nbsp;                                            |\n| :---          | :---                                              |\n| $h$           | Height of the tree;                               |\n| $h(x)$        | Height of the node $x$;                           |\n| $bh$          | Black height of the tree;                         |\n| $bh(x)$       | Black height of the node $x$;                     |\n| $n$           | Number of nodes in the tree;                      |\n| $n(x)$        | Number of the nodes of the node $x$;              |\nIf tree height is $h$, then its $bh >= h/2$; (**_Why?_** -- _According to the 4<sup>th</sup> property above as each red node strictly requires black children_)\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Theorem ### \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n\n### Proof by induction ###\n\n**Proof:** A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$. \nThe __contrapositive__ is \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\nSo to proof the original __theorem(or the proposition)__ is true, we only need to prove whether the __contrapositive__ is true, which means just to prove \"the height $h$ of the __Red-Black Tree__ has at least $2^{h/2} – 1$ internal nodes\". That is $n >= 2^{h/2} - 1$.\n\nStarting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is __black height__ of the node $x$, or $x$'s __black height__, that is $bh(x)$. There are two points as below regarding the $bh(x)$:\n\n**Point 1**: According to the 3<sup>rd</sup> **Red-Black Tree** properties \"Every path from a node $x$ to a descendent leaf has the same number of black nodes (**_not counting node $x$_**)\", so the $bh(x)$ is unique of the node $x$!\n**Point 2**: According to the 4<sup>th</sup> **Red-Black Tree** properties, \"Both children of a red node must be black nodes\", we can say starting from the node x to leaf node, the number of black nodes >= the number the red nodes, which means $bh(x) >= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh >= h/2$. \n\nThus, according to the above two points, we conclude that to proof $n >= 2^{h/2} - 1$, we just need to proof $n >= 2^{bh} - 1$, which means the **Red-Black Tree** with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.\n\nSo far, we turned the theorem needs to be proofed \n\"A __Red-Black Tree__ with $n$ internal nodes has height $h<=2 * log_2(n + 1)$\"\nto\n\"A __Red-Black Tree__ with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n >= 2^{bh} - 1$\".\n\t\n\t\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n**Base case**: $h(x) = 0$, which means that **x** is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node **x** has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.\n\n**Induction step**:\n1. $x$ has positive height and 2 children, that is $h(x) > 0, so each of its child has __black height__ of $bh(x)$ or ($bh(x) - 1$); \n2. The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   \n3. Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) >= 2^{bh(x)} - 1$.\n4. So consider $x$ as the root node, then $n >= 2^{bh} - 1$.\n\n| ** Thus **     | &nbsp; | &nbsp;               | &nbsp; |\n| :---           | :---   | :---                 | :---   |\n| $n$            | >=     | $2^{bh} - 1$         | &nbsp; |\n| $n$            | >=     | $2^{h/2} - 1$        | &nbsp; |\n| $log_2(n + 1)$ | >=     | $h/2$                | &nbsp; |\n| $h$            | <=     | $2 * log_2(n + 1)$   | &nbsp; |\n\n**Conclusion**: \nA **Red-Black Tree** with $n$ internal nodes has height $h<=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$\n\n**Corollary**:\nAll operations of a **Red-Black Tree** take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();\nInsert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Structure ###\nEvery node of **Red-Black Tree** has $5$ attributes:\n\n```c\nstruct t_red_black_node {\n    enum { \n        red, black \n    } color;\n    void *key;\n    struct t_red_black_node *left;\n    struct t_red_black_node *right;\n    struct t_red_black_node *parent;\n\tvoid *value;\n\tint numLeft;      //optional\n\tint numRight;     //optional\n}\n```\n\nA **Red-Black Tree** node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated. \nOf course we can add more variables like the count of its children nodes according to the requirements.\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n### Operations and Rotations ###\nHow does **inserting** or **deleting** nodes affect a **Red-Black Tree**? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like **inserting** or **deleting**, the **Red-Black Tree** is continue to keep the its properties and balance.\n\n**Rotation** is a binary operation, between a parent node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).\n\nThere are two types of rotations: **left rotation** and **right rotation**. \n**Left rotation** swaps the parent node with its right child, \n**Right rotation** swaps the parent node with its left child. \n\n| **Left rotation**                                           | &nbsp; |**Right rotation**                                            |\n| :---:                                                       | ---    | :---:                                                        |\n| {% asset_img rbt_left_rotation_1.jpg \" \" \"Left rotation\" %} | &nbsp; |{% asset_img rbt_right_rotation_1.jpg \" \" \"Right rotation\" %} |\n\n\nHere are the steps involved in for left rotation (for right rotations just change “left” to “right” below):\n\nWhen do the left rotation on a **pivot**, assume its right child is not **NIL[T]**. **pivot** is a left child of any nodes but not **NIL[T]**\n**Left rotation** is based on the axis between the **pivot** node and **Y** node, the steps are:\n1. Let node **Y** be the parent of the **pivot** node;\n2. Let the **pivot** node be the left child of node **Y**;\n3. Let the left child of node **Y** be the rigth child of the **pivot** node;\n\nThe pesudo code for **left rotation** is below(use **X** as the **pivot** node which is mentioned above):\n\n```\nLEFT-ROTATE(T, X)  \n Y ← right[X]            \n right[X] ← left[Y]      // Turn Y's left subtree into X's right subtree;\n p[left[Y]] ← X          // Set X as the parent of Y's left child;\n p[Y] ← p[X]             // Link X's parent to Y;\n if p[X] = nil[T]        // means X is root, so its parent is nil\n then root[T] ← Y        // case 1： first see whether we're at the root ;\n else if X = left[p[X]]  \n then left[p[X]] ← Y     // case 2： X was on the left of its parent;\n else right[p[X]] ← Y    // case 3: X must have been on the right, so set Y as the right child of X's parent;\n left[Y] ← X             // set X as Y's left child;\n p[X] ← Y                // set Y as X's parent;\n```\n\n","slug":"Red-Black-Tree","published":1,"updated":"2016-11-21T16:42:32.994Z","_id":"civlf3grr00007clskotv4zxv","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h3><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either red or black;</li>\n<li>All leaf (NULL Pointer) nodes are colored with black;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>black height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a red node must be black nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always black.</li>\n</ol>\n<img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h3 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h3><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\">Black height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\">Black height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 4<sup>th</sup> property above as each red node strictly requires black children</em>)</p>\n<hr>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h3 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h3><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is <strong>black height</strong> of the node $x$, or $x$’s <strong>black height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sup>rd</sup> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sup>th</sup> <strong>Red-Black Tree</strong> properties, “Both children of a red node must be black nodes”, we can say starting from the node x to leaf node, the number of black nodes &gt;= the number the red nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>black height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<p><strong>Corollary</strong>:<br>All operations of a <strong>Red-Black Tree</strong> take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();<br>Insert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;</p>\n<hr>\n<h3 id=\"Structure\"><a href=\"#Structure\" class=\"headerlink\" title=\"Structure\"></a>Structure</h3><p>Every node of <strong>Red-Black Tree</strong> has $5$ attributes:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> t_red_black_node &#123;</div><div class=\"line\">    <span class=\"keyword\">enum</span> &#123; </div><div class=\"line\">        red, black </div><div class=\"line\">    &#125; color;</div><div class=\"line\">    <span class=\"keyword\">void</span> *key;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *left;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *right;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *parent;</div><div class=\"line\">\t<span class=\"keyword\">void</span> *value;</div><div class=\"line\">\t<span class=\"keyword\">int</span> numLeft;      <span class=\"comment\">//optional</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> numRight;     <span class=\"comment\">//optional</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>A <strong>Red-Black Tree</strong> node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated.<br>Of course we can add more variables like the count of its children nodes according to the requirements.</p>\n<hr>\n<h3 id=\"Operations-and-Rotations\"><a href=\"#Operations-and-Rotations\" class=\"headerlink\" title=\"Operations and Rotations\"></a>Operations and Rotations</h3><p>How does <strong>inserting</strong> or <strong>deleting</strong> nodes affect a <strong>Red-Black Tree</strong>? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like <strong>inserting</strong> or <strong>deleting</strong>, the <strong>Red-Black Tree</strong> is continue to keep the its properties and balance.</p>\n<p><strong>Rotation</strong> is a binary operation, between a parent node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).</p>\n<p>There are two types of rotations: <strong>left rotation</strong> and <strong>right rotation</strong>.<br><strong>Left rotation</strong> swaps the parent node with its right child,<br><strong>Right rotation</strong> swaps the parent node with its left child. </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>Left rotation</strong></th>\n<th>&nbsp;</th>\n<th style=\"text-align:center\"><strong>Right rotation</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_1.jpg\" alt=\" Left rotation\" title=\" Left rotation\"></td>\n<td>&nbsp;</td>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_1.jpg\" alt=\" Right rotation\" title=\" Right rotation\"></td>\n</tr>\n</tbody>\n</table>\n<p>Here are the steps involved in for left rotation (for right rotations just change “left” to “right” below):</p>\n<p>When do the left rotation on a <strong>pivot</strong>, assume its right child is not <strong>NIL[T]</strong>. <strong>pivot</strong> is a left child of any nodes but not <strong>NIL[T]</strong><br><strong>Left rotation</strong> is based on the axis between the <strong>pivot</strong> node and <strong>Y</strong> node, the steps are:</p>\n<ol>\n<li>Let node <strong>Y</strong> be the parent of the <strong>pivot</strong> node;</li>\n<li>Let the <strong>pivot</strong> node be the left child of node <strong>Y</strong>;</li>\n<li>Let the left child of node <strong>Y</strong> be the rigth child of the <strong>pivot</strong> node;</li>\n</ol>\n<p>The pesudo code for <strong>left rotation</strong> is below(use <strong>X</strong> as the <strong>pivot</strong> node which is mentioned above):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">LEFT-ROTATE(T, X)  </div><div class=\"line\"> Y ← right[X]            </div><div class=\"line\"> right[X] ← left[Y]      // Turn Y&apos;s left subtree into X&apos;s right subtree;</div><div class=\"line\"> p[left[Y]] ← X          // Set X as the parent of Y&apos;s left child;</div><div class=\"line\"> p[Y] ← p[X]             // Link X&apos;s parent to Y;</div><div class=\"line\"> if p[X] = nil[T]        // means X is root, so its parent is nil</div><div class=\"line\"> then root[T] ← Y        // case 1： first see whether we&apos;re at the root ;</div><div class=\"line\"> else if X = left[p[X]]  </div><div class=\"line\"> then left[p[X]] ← Y     // case 2： X was on the left of its parent;</div><div class=\"line\"> else right[p[X]] ← Y    // case 3: X must have been on the right, so set Y as the right child of X&apos;s parent;</div><div class=\"line\"> left[Y] ← X             // set X as Y&apos;s left child;</div><div class=\"line\"> p[X] ← Y                // set Y as X&apos;s parent;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h3><h5 id=\"BST-Binary-Search-Tree-Retrieval\"><a href=\"#BST-Binary-Search-Tree-Retrieval\" class=\"headerlink\" title=\"BST(Binary Search Tree) Retrieval\"></a>BST(Binary Search Tree) Retrieval</h5><p>Retrieving an element from <strong>BST</strong> requires simple navigation, starting from the root and going left, if the current node is larger than the node we are looking for, or going right otherwise.</p>\n<p><strong>Any of these primitive operations on BST run in $O(h)$ time, where $h$ is the tree height, so the smaller the tree height the better running time operations will achieve. Which means the time complexity of BST Retrieval is related to the height of the BST!</strong></p>\n<p>The problem with <strong>BST</strong> is that, depending on the order of inserting elements in the tree, the tree shape can vary. In the worst cases (such as inserting elements in order) the tree will look like a <strong>linked list</strong> in which each node has only a right child. This yields $O(n)$ for primitive operations on the <strong>BST</strong>, with $n$ the number of nodes in the tree, in the other words, the <strong>BST</strong> is turned to an <strong>ordered linked list</strong>.</p>\n<p>To solve this problem many variations of <strong>BST</strong> exist. Of these variations, <strong>Red-Black tree provides a well-balanced </strong>BST<strong> that guarantees a logarithmic bound on primitive operations</strong>.  </p>\n<hr>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p><strong>Red-Black Tree</strong>, an evolution of <strong>BST</strong> that aim to <strong>keep the tree balanced without affecting the complexity of the primitive operations</strong>. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that <strong>the deepest path in the tree is not longer than twice the shortest one</strong>.</p>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><ol>\n<li>Every node is colored with either red or black;</li>\n<li>All leaf (NULL Pointer) nodes are colored with black;<br> <strong>Note:</strong> <em>If a node’s child is missing then we will assume that it has a nil child(NULL Pointer) in that place and this nil child(NULL Pointer) is always colored black.</em></li>\n<li>Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>). We call this number the <strong>black height</strong> of node $x$, which is denoted by $bh(x)$;</li>\n<li>Both children of a red node must be black nodes;<br> <strong>Note:</strong> <em>So it’s impossible to have 2 consecutive reds on a path, so it ensures that the deepest path in the tree is not longer than twice the shortest one. Thus, the <strong>Red-Black Tree</strong> is a relatively balanced binary tree.</em></li>\n<li>The root is always black.</li>\n</ol>\n<img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_1.jpg\" alt=\"Figure 1 Red-Black Tree\" title=\"Figure 1 Red-Black Tree\">\n<hr>\n<h3 id=\"Application-of-Red-Black-Tree\"><a href=\"#Application-of-Red-Black-Tree\" class=\"headerlink\" title=\"Application of Red-Black Tree\"></a>Application of Red-Black Tree</h3><p><strong>Red-Black Tree</strong> is used widely, it is mainly used to store sorted/ordered data, its time complexity is $O(log_2(n))$ which has high efficiency.<br>For example, the Java collection classes <strong>TreeSet</strong> and <strong>TreeMap</strong> , the C++ STL classes <strong>set</strong>, <strong>map</strong>, and Linux virtual memory management, all of these are based on <strong>Red-Black Tree</strong>.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Basis </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">Height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h(x)$</td>\n<td style=\"text-align:left\">Height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh$</td>\n<td style=\"text-align:left\">Black height of the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$bh(x)$</td>\n<td style=\"text-align:left\">Black height of the node $x$;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">Number of nodes in the tree;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n(x)$</td>\n<td style=\"text-align:left\">Number of the nodes of the node $x$;</td>\n</tr>\n</tbody>\n</table>\n<p>If tree height is $h$, then its $bh &gt;= h/2$; (<strong><em>Why?</em></strong> – <em>According to the 4<sup>th</sup> property above as each red node strictly requires black children</em>)</p>\n<hr>\n<h3 id=\"Theorem\"><a href=\"#Theorem\" class=\"headerlink\" title=\"Theorem\"></a>Theorem</h3><p>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<h3 id=\"Proof-by-induction\"><a href=\"#Proof-by-induction\" class=\"headerlink\" title=\"Proof by induction\"></a>Proof by induction</h3><p><strong>Proof:</strong> A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$.<br>The <strong>contrapositive</strong> is “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.<br>So to proof the original <strong>theorem(or the proposition)</strong> is true, we only need to prove whether the <strong>contrapositive</strong> is true, which means just to prove “the height $h$ of the <strong>Red-Black Tree</strong> has at least $2^{h/2} – 1$ internal nodes”. That is $n &gt;= 2^{h/2} - 1$.</p>\n<p>Starting from a node $x$ (not including the node) to reach a leaf node of any path, the number of black nodes is <strong>black height</strong> of the node $x$, or $x$’s <strong>black height</strong>, that is $bh(x)$. There are two points as below regarding the $bh(x)$:</p>\n<p><strong>Point 1</strong>: According to the 3<sup>rd</sup> <strong>Red-Black Tree</strong> properties “Every path from a node $x$ to a descendent leaf has the same number of black nodes (<strong><em>not counting node $x$</em></strong>)”, so the $bh(x)$ is unique of the node $x$!<br><strong>Point 2</strong>: According to the 4<sup>th</sup> <strong>Red-Black Tree</strong> properties, “Both children of a red node must be black nodes”, we can say starting from the node x to leaf node, the number of black nodes &gt;= the number the red nodes, which means $bh(x) &gt;= h(x)/2$. Assuming that $x$ is the root node, we can come to the conclusion that $bh &gt;= h/2$. </p>\n<p>Thus, according to the above two points, we conclude that to proof $n &gt;= 2^{h/2} - 1$, we just need to proof $n &gt;= 2^{bh} - 1$, which means the <strong>Red-Black Tree</strong> with height $h$ should contain at least ($2^{bh} - 1$) internal nodes.</p>\n<p>So far, we turned the theorem needs to be proofed<br>“A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$”<br>to<br>“A <strong>Red-Black Tree</strong> with height $h$ contains at least ($2^{bh} - 1$) internal nodes, that is $n &gt;= 2^{bh} - 1$”.</p>\n<hr>\n<p><strong>Base case</strong>: $h(x) = 0$, which means that <strong>x</strong> is a leaft node and therefore $bh(x) = 0$ and the subtree rooted at node <strong>x</strong> has $2^{bh(x)} -1 = 2^0 - 1 = 1 - 1 = 0$ nodes.</p>\n<p><strong>Induction step</strong>:</p>\n<ol>\n<li>$x$ has positive height and 2 children, that is $h(x) &gt; 0, so each of its child has <strong>black height</strong> of $bh(x)$ or ($bh(x) - 1$); </li>\n<li>The height of a child $= h(x) - 1$, so the subtrees rooted at each child contain at least ($2^{bh(x) - 1} -1$) internal nodes;   </li>\n<li>Thus subtree at node $x$ contains $(2^{bh(x) - 1}) + (2^{bh(x) - 1}) + 1 = 2 * 2^{bh(x) - 1} - 1 = 2^{bh(x)} - 1$ nodes, that is $n(x) &gt;= 2^{bh(x)} - 1$.</li>\n<li>So consider $x$ as the root node, then $n &gt;= 2^{bh} - 1$.</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong> Thus </strong></th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n<th style=\"text-align:left\">&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{bh} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$n$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$2^{h/2} - 1$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$log_2(n + 1)$</td>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">$h/2$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$h$</td>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">$2 * log_2(n + 1)$</td>\n<td style=\"text-align:left\">&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Conclusion</strong>:<br>A <strong>Red-Black Tree</strong> with $n$ internal nodes has height $h&lt;=2 * log_2(n + 1)$, which means the time complexity is $O(log_2(n))$</p>\n<p><strong>Corollary</strong>:<br>All operations of a <strong>Red-Black Tree</strong> take $O(log_2(n))$ time complexity, e.g. Minimum(), Maximum(), Successor(), Predecessor(), Search();<br>Insert() and Delete() will also take $O(log_2(n))$ time complexity, but will need special care since they modify the tree;</p>\n<hr>\n<h3 id=\"Structure\"><a href=\"#Structure\" class=\"headerlink\" title=\"Structure\"></a>Structure</h3><p>Every node of <strong>Red-Black Tree</strong> has $5$ attributes:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> t_red_black_node &#123;</div><div class=\"line\">    <span class=\"keyword\">enum</span> &#123; </div><div class=\"line\">        red, black </div><div class=\"line\">    &#125; color;</div><div class=\"line\">    <span class=\"keyword\">void</span> *key;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *left;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *right;</div><div class=\"line\">    <span class=\"keyword\">struct</span> t_red_black_node *parent;</div><div class=\"line\">\t<span class=\"keyword\">void</span> *value;</div><div class=\"line\">\t<span class=\"keyword\">int</span> numLeft;      <span class=\"comment\">//optional</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> numRight;     <span class=\"comment\">//optional</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>A <strong>Red-Black Tree</strong> node has 6 mandatory instance variables, which are color，key，left，right，parent and value. For the pointers left, right and parent, these values are assigned to nil when a node is instantiated.<br>Of course we can add more variables like the count of its children nodes according to the requirements.</p>\n<hr>\n<h3 id=\"Operations-and-Rotations\"><a href=\"#Operations-and-Rotations\" class=\"headerlink\" title=\"Operations and Rotations\"></a>Operations and Rotations</h3><p>How does <strong>inserting</strong> or <strong>deleting</strong> nodes affect a <strong>Red-Black Tree</strong>? To ensure that its color scheme and properties don’t get thrown off, we can recolor or rotate the tree, that is modify the color or the structure of the corresponding nodes, to ensure after the tree modifying operations like <strong>inserting</strong> or <strong>deleting</strong>, the <strong>Red-Black Tree</strong> is continue to keep the its properties and balance.</p>\n<p><strong>Rotation</strong> is a binary operation, between a parent node and one of its children, that swaps nodes and modifies their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).</p>\n<p>There are two types of rotations: <strong>left rotation</strong> and <strong>right rotation</strong>.<br><strong>Left rotation</strong> swaps the parent node with its right child,<br><strong>Right rotation</strong> swaps the parent node with its left child. </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>Left rotation</strong></th>\n<th>&nbsp;</th>\n<th style=\"text-align:center\"><strong>Right rotation</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_left_rotation_1.jpg\" alt=\" Left rotation\" title=\" Left rotation\"></td>\n<td>&nbsp;</td>\n<td style=\"text-align:center\"><img src=\"/archive/2016/11/16/Red-Black-Tree/rbt_right_rotation_1.jpg\" alt=\" Right rotation\" title=\" Right rotation\"></td>\n</tr>\n</tbody>\n</table>\n<p>Here are the steps involved in for left rotation (for right rotations just change “left” to “right” below):</p>\n<p>When do the left rotation on a <strong>pivot</strong>, assume its right child is not <strong>NIL[T]</strong>. <strong>pivot</strong> is a left child of any nodes but not <strong>NIL[T]</strong><br><strong>Left rotation</strong> is based on the axis between the <strong>pivot</strong> node and <strong>Y</strong> node, the steps are:</p>\n<ol>\n<li>Let node <strong>Y</strong> be the parent of the <strong>pivot</strong> node;</li>\n<li>Let the <strong>pivot</strong> node be the left child of node <strong>Y</strong>;</li>\n<li>Let the left child of node <strong>Y</strong> be the rigth child of the <strong>pivot</strong> node;</li>\n</ol>\n<p>The pesudo code for <strong>left rotation</strong> is below(use <strong>X</strong> as the <strong>pivot</strong> node which is mentioned above):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">LEFT-ROTATE(T, X)  </div><div class=\"line\"> Y ← right[X]            </div><div class=\"line\"> right[X] ← left[Y]      // Turn Y&apos;s left subtree into X&apos;s right subtree;</div><div class=\"line\"> p[left[Y]] ← X          // Set X as the parent of Y&apos;s left child;</div><div class=\"line\"> p[Y] ← p[X]             // Link X&apos;s parent to Y;</div><div class=\"line\"> if p[X] = nil[T]        // means X is root, so its parent is nil</div><div class=\"line\"> then root[T] ← Y        // case 1： first see whether we&apos;re at the root ;</div><div class=\"line\"> else if X = left[p[X]]  </div><div class=\"line\"> then left[p[X]] ← Y     // case 2： X was on the left of its parent;</div><div class=\"line\"> else right[p[X]] ← Y    // case 3: X must have been on the right, so set Y as the right child of X&apos;s parent;</div><div class=\"line\"> left[Y] ← X             // set X as Y&apos;s left child;</div><div class=\"line\"> p[X] ← Y                // set Y as X&apos;s parent;</div></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_drafts/2016-10-27-t/red_black_tree_1.png","slug":"red_black_tree_1.png","post":"civlf2t150000golsnaf65omr","modified":0,"renderable":0},{"_id":"source/_drafts/red-black-tree/rbt_1.jpg","slug":"rbt_1.jpg","post":"civlf2t1d0001golsswk63flv","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_height_depth.png","slug":"tree_height_depth.png","post":"civlf2t1w0008golskqskfp2m","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-15-Tree-Properties/tree_properties_1.jpg","slug":"tree_properties_1.jpg","post":"civlf2t1w0008golskqskfp2m","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree1.gif","slug":"min_tree1.gif","post":"civlf2t1z0009golsblj1n5sy","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree2.gif","slug":"min_tree2.gif","post":"civlf2t1z0009golsblj1n5sy","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-09-Height-of-a-Complete-Binary-Tree/min_tree3.gif","slug":"min_tree3.gif","post":"civlf2t1z0009golsblj1n5sy","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_1.jpg","slug":"rbt_1.jpg","post":"civlf3grr00007clskotv4zxv","modified":0,"renderable":0},{"_id":"source/_drafts/red-black-tree/rbt_left_rotation_1.jpg","slug":"rbt_left_rotation_1.jpg","post":"civlf2t1d0001golsswk63flv","modified":0,"renderable":0},{"_id":"source/_drafts/red-black-tree/rbt_right_rotation_1.jpg","slug":"rbt_right_rotation_1.jpg","post":"civlf2t1d0001golsswk63flv","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_left_rotation_1.jpg","slug":"rbt_left_rotation_1.jpg","post":"civlf3grr00007clskotv4zxv","modified":0,"renderable":0},{"_id":"source/_posts/2016-11-16-Red-Black-Tree/rbt_right_rotation_1.jpg","slug":"rbt_right_rotation_1.jpg","post":"civlf3grr00007clskotv4zxv","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"civlf2t1w0008golskqskfp2m","tag_id":"civlf2t1k0003golskt9uwehn","_id":"civlf2t27000bgols8mx6jom1"},{"post_id":"civlf2t1w0008golskqskfp2m","tag_id":"civlf2t1v0007golswl7qubqq","_id":"civlf2t28000cgolsao6gtthy"},{"post_id":"civlf2t1d0001golsswk63flv","tag_id":"civlf2t1k0003golskt9uwehn","_id":"civlf2t29000egolsugshprnp"},{"post_id":"civlf2t1d0001golsswk63flv","tag_id":"civlf2t1v0007golswl7qubqq","_id":"civlf2t29000fgolsnbflbi1e"},{"post_id":"civlf2t1z0009golsblj1n5sy","tag_id":"civlf2t1k0003golskt9uwehn","_id":"civlf2t2a000ggolsa4fdxaph"},{"post_id":"civlf2t1z0009golsblj1n5sy","tag_id":"civlf2t1v0007golswl7qubqq","_id":"civlf2t2d000igolsnygqtirm"},{"post_id":"civlf2t1h0002golsp1lt42ya","tag_id":"civlf2t26000agolsswvjmpi1","_id":"civlf2t2d000jgols6ukoddfz"},{"post_id":"civlf2t1h0002golsp1lt42ya","tag_id":"civlf2t29000dgolsh5smumho","_id":"civlf2t2f000lgolsxh2s5mal"},{"post_id":"civlf2t1o0004gols5dpr0b1t","tag_id":"civlf2t29000dgolsh5smumho","_id":"civlf2t2g000ngolsx398rxqs"},{"post_id":"civlf2t1o0004gols5dpr0b1t","tag_id":"civlf2t2e000kgolsr0ppi88w","_id":"civlf2t2h000ogols3mj2z8mw"},{"post_id":"civlf2t1r0005golsk0djngk7","tag_id":"civlf2t2g000mgolsf0hk8jq0","_id":"civlf2t2h000qgolsrny4w4k8"},{"post_id":"civlf2t1u0006golsj3jg4wdq","tag_id":"civlf2t2h000pgols9mastp75","_id":"civlf2t2i000rgols3dby2y8j"},{"post_id":"civlf3grr00007clskotv4zxv","tag_id":"civlf2t1k0003golskt9uwehn","_id":"civlf3grz00017clsfs13gw4c"},{"post_id":"civlf3grr00007clskotv4zxv","tag_id":"civlf2t1v0007golswl7qubqq","_id":"civlf3gs000027cls7mcdjczb"}],"Tag":[{"name":"Algorithm","_id":"civlf2t1k0003golskt9uwehn"},{"name":"Tree","_id":"civlf2t1v0007golswl7qubqq"},{"name":"Hexo","_id":"civlf2t26000agolsswvjmpi1"},{"name":"GitHub","_id":"civlf2t29000dgolsh5smumho"},{"name":"Tools","_id":"civlf2t2e000kgolsr0ppi88w"},{"name":"随笔","_id":"civlf2t2g000mgolsf0hk8jq0"},{"name":"Math","_id":"civlf2t2h000pgols9mastp75"}]}}